#~~
# R. Hollines
# Core Objeck class libraries
# 
# H.W. Lang - merge sort implementations
~~#	

use IO;
use Structure;
use Net;

bundle Structure {
	# Integer Vector
	class IntVector {
		@values : Int[];
		@size : Int;
		
		New() {
			@values := Int->New[16];
			@size := 0;
		}

		method : native : Expand(), Nil {
			if(@size >= @values->Size()) {
				temp : Int[] := Int->New[@size * 2];
				for(i : Int := 0; i < @size; i := i + 1;) {
					temp[i] := @values[i];
				};
				@values := temp;
			};
		}

		method : public : AddBack(value : Int), Nil {
			Expand();
			@values[@size] := value;
			@size := @size + 1;
		}

		method : public : RemoveBack(), Nil {
			if(@size > 0) {
				@size := @size - 1;
			};
		}

		method : public : Get(index : Int), Int {
			if(index > -1 & index < @size) {
				return @values[index];
			};

			return 0;
		}

		method : public : Set(value : Int, index : Int), Bool {
			if(index > -1 & index < @size) {
				@values[index] := value;
				return true;
			};
			
			return false;
		}
		
		method : public : Size(), Int {
			return @size;
		}
		
		method : public : native : Average(), Int {
			if(@size <= 0) {
				return 0;
			};
			
			total := 0;
			for(i : Int := 0; i < @size; i := i + 1;) {
				total := total + @values[i];
			};
			
			return total / @size;
		}
		
		method : public : native : Min(), Int {
			if(@size <= 0) {
				return 0;
			};
			
			if(@size = 1) {
				return @values[0];
			};
			
			min := @values[0];
			for(i : Int := 1; i < @size; i := i + 1;) {
				if(@values[i] < min) {
					min := @values[i];
				};
			};
			
			return min;
		}
		
		method : public : native : Max(), Int {
			if(@size <= 0) {
				return 0;
			};
			
			if(@size = 1) {
				return @values[0];
			};
			
			max := @values[0];
			for(i : Int := 1; i < @size; i := i + 1;) {
				if(@values[i] > max) {
					max := @values[i];
				};
			};
			
			return max;
		}
		
		method : public : native : Sort(), Nil {
			a : Int[] := @values;
			b : Int[] := Int->New[@size];
			MergeSort(0, @size - 1, a, b);
		}
		
		method : public : native : MergeSort(low : Int, hi : Int, a : Int[], b : Int[]), Nil {
			if(low < hi) {
				mid := (low + hi) / 2;
				MergeSort(low, mid, a, b);
				MergeSort(mid + 1, hi, a, b);
				Merge(low, mid, hi, a, b);
			};	
		}
		
		method : public : native : Merge(low : Int, mid : Int, hi : Int, a : Int[], b : Int[]), Nil {
			# copy both halves of a to auxiliary array b
			for(i := low; i <= hi; i := i + 1;) {
				b[i] := a[i];
			};

			i := low; 
			j := mid + 1; 
			k := low;
			
			# copy back next-greatest element at each time
			while(i <= mid & j <= hi) {
				if(b[i] <= b[j]) {
					a[k] := b[i];
					k := k + 1;
					i := i + 1;
				}
				else {
					a[k] := b[j];
					k := k + 1;
					j := j + 1;
				};
			};
			
			# copy back remaining elements of first half (if any)
			while(i <= mid) {
				a[k] := b[i];
				k := k + 1;
				i := i + 1;
			};
		}
	}
	
	# Float Vector
	class FloatVector {
		@values : Float[];
		@size : Int;
		
		New() {
			@values := Float->New[16];
			@size := 0;
		}

		method : native : Expand(), Nil {
			if(@size >= @values->Size()) {
				temp : Float[] := Float->New[@size * 2];
				for(i : Int := 0; i < @size; i := i + 1;) {
					temp[i] := @values[i];
				};
				@values := temp;
			};
		}

		method : public : AddBack(value : Float), Nil {
			Expand();
			@values[@size] := value;
			@size := @size + 1;
		}

		method : public : RemoveBack(), Nil {
			if(@size > 0) {
				@size := @size - 1;
			};
		}

		method : public : Get(index : Int), Float {
			if(index > -1 & index < @size) {
				return @values[index];
			};

			return 0.0;
		}

		method : public : Set(value : Float, index : Int), Bool {
			if(index > -1 & index < @size) {
				@values[index] := value;
				return true;
			};
			
			return false;
		}
		
		method : public : Size(), Int {
			return @size;
		}

		method : public : native : Average(), Float {
			if(@size <= 0) {
				return 0.0;
			};
			
			total := 0.0;
			for(i : Int := 0; i < @size; i := i + 1;) {
				total := total + @values[i];
			};
			
			return total / @size;
		}
		
		method : public : native : Min(), Float {
			if(@size <= 0) {
				return 0.0;
			};
			
			if(@size = 1) {
				return @values[0];
			};
			
			min := @values[0];
			for(i : Int := 1; i < @size; i := i + 1;) {
				if(@values[i] < min) {
					min := @values[i];
				};
			};
			
			return min;
		}
		
		method : public : native : Max(), Float {
			if(@size <= 0) {
				return 0.0;
			};
			
			if(@size = 1) {
				return @values[0];
			};
			
			max := @values[0];
			for(i : Int := 1; i < @size; i := i + 1;) {
				if(@values[i] > max) {
					max := @values[i];
				};
			};
			
			return max;
		}
		
		method : public : native : Sort(), Nil {
			a : Float[] := @values;
			b : Float[] := Float->New[@size];
			MergeSort(0, @size - 1, a, b);
		}
		
		method : public : native : MergeSort(low : Int, hi : Int, a : Float[], b : Float[]), Nil {
			if(low < hi) {
				mid := (low + hi) / 2;
				MergeSort(low, mid, a, b);
				MergeSort(mid + 1, hi, a, b);
				Merge(low, mid, hi, a, b);
			};	
		}
		
		method : public : native : Merge(low : Int, mid : Int, hi : Int, a : Float[], b : Float[]), Nil {
			# copy both halves of a to auxiliary array b
			for(i := low; i <= hi; i := i + 1;) {
				b[i] := a[i];
			};

			i := low; 
			j := mid + 1; 
			k := low;
			
			# copy back next-greatest element at each time
			while(i <= mid & j <= hi) {
				if(b[i] <= b[j]) {
					a[k] := b[i];
					k := k + 1;
					i := i + 1;
				}
				else {
					a[k] := b[j];
					k := k + 1;
					j := j + 1;
				};
			};
			
			# copy back remaining elements of first half (if any)
			while(i <= mid) {
				a[k] := b[i];
				k := k + 1;
				i := i + 1;
			};
		}
	}
	
	# Compare Vector
	class CompareVector {
		@values : Compare[];
		@size : Int;
		
		New() {
			@values := Compare->New[16];
			@size := 0;
		}

		method : native : Expand(), Nil {
			if(@size >= @values->Size()) {
				temp : Compare[] := Compare->New[@size * 2];
				for(i : Int := 0; i < @size; i := i + 1;) {
					temp[i] := @values[i];
				};
				@values := temp;
			};
		}

		method : public : AddBack(value : Compare), Nil {
			Expand();
			@values[@size] := value;
			@size := @size + 1;
		}

		method : public : RemoveBack(), Nil {
			if(@size > 0) {
				@size := @size - 1;
			};
		}

		method : public : Get(index : Int), Compare {
			if(index > -1 & index < @size) {
				return @values[index];
			};

			return Nil;
		}

		method : public : Set(value : Compare, index : Int), Bool {
			if(index > -1 & index < @size) {
				@values[index] := value;
				return true;
			};
			
			return false;
		}
		
		method : public : Size(), Int {
			return @size;
		}
				
		method : public : native : Sort(), Nil {
			a : Compare[] := @values;
			b : Compare[] := Compare->New[@size];
			MergeSort(0, @size - 1, a, b);
		}
		
		method : public : native : MergeSort(low : Int, hi : Int, a : Compare[], b : Compare[]), Nil {
			if(low < hi) {
				mid := (low + hi) / 2;
				MergeSort(low, mid, a, b);
				MergeSort(mid + 1, hi, a, b);
				Merge(low, mid, hi, a, b);
			};	
		}
		
		method : public : native : Merge(low : Int, mid : Int, hi : Int, a : Compare[], b : Compare[]), Nil {
			# copy both halves of a to auxiliary array b
			for(i := low; i <= hi; i := i + 1;) {
				b[i] := a[i];
			};

			i := low; 
			j := mid + 1; 
			k := low;
			
			# copy back next-greatest element at each time
			while(i <= mid & j <= hi) {
				if(b[i]->Compare(b[j]) < 0 | b[i]->Compare(b[j]) = 0) {
					a[k] := b[i];
					k := k + 1;
					i := i + 1;
				}
				else {
					a[k] := b[j];
					k := k + 1;
					j := j + 1;
				};
			};
			
			# copy back remaining elements of first half (if any)
			while(i <= mid) {
				a[k] := b[i];
				k := k + 1;
				i := i + 1;
			};
		}
	}
	
	# Object Vector
	class Vector {
		@values : Base[];
		@size : Int;
		
		New() {
			@values := Base->New[16];
			@size := 0;
		}

		method : native : Expand(), Nil {
			if(@size >= @values->Size()) {
				temp : Base[] := Base->New[@size * 2];
				for(i : Int := 0; i < @size; i := i + 1;) {
					temp[i] := @values[i];
				};
				@values := temp;
			};
		}

		method : public : AddBack(value : Base), Nil {
			Expand();
			@values[@size] := value;
			@size := @size + 1;
		}

		method : public : RemoveBack(), Nil {
			if(@size > 0) {
				@size := @size - 1;
			};
		}

		method : public : Get(index : Int), Base {
			if(index > -1 & index < @size) {
				return @values[index];
			};

			return Nil;
		}

		method : public : Set(value : Base, index : Int), Bool {
			if(index > -1 & index < @size) {
				@values[index] := value;
				return true;
			};
			
			return false;
		}
		
		method : public : Size(), Int {
			return @size;
		}
	}
	
	# Stack
	class Stack {
		values : Vector;
		
		New() {
			values := Vector->New();
		}
		
		method : public: native : Push(value : Base), Nil {
			v := value;
			values->AddBack(v);
		}
		
		method : public : native : Pop(), Base {
			if(values->Size() > 0) {
				value : Base := values->Get(values->Size() - 1);
				values->RemoveBack();
				
				return value;
			};
			
			return Nil;
		}
		
		method : public: native : Top(), Base {
			if(values->Size() > 0) {
				return values->Get(values->Size() - 1);
			};
			
			return Nil;
		}
	}

	# Integer Stack
	class IntStack {
		values : IntVector;
		
		New() {
			values := IntVector->New();
		}
		
		method : public: native : Push(value : Int), Nil {
			v := value;
			values->AddBack(v);
		}
		
		method : public: native : Pop(), Int {
			if(values->Size() > 0) {
				value : Int := values->Get(values->Size() - 1);
				values->RemoveBack();
				
				return value;
			};
			
			return 0;
		}
		
		method : public: native : Top(), Int {
			if(values->Size() > 0) {
				return values->Get(values->Size() - 1);
			};
			
			return 0;
		}
	}
	
	# Float Stack
	class FloatStack {
		values : FloatVector;
		
		New() {
			values := FloatVector->New();
		}
		
		method : public : native : Push(value : Float), Nil {
			v := value;
			values->AddBack(v);
		}
		
		method : public: native : Pop(), Float {
			if(values->Size() > 0) {
				value : Float := values->Get(values->Size() - 1);
				values->RemoveBack();
				
				return value;
			};
			
			return 0.0;
		}
		
		method : public: native : Top(), Float {
			if(values->Size() > 0) {
				return values->Get(values->Size() - 1);
			};
			
			return 0.0;
		}
	}
	
	# TODO: refactor!
	# Integer Linked List
	class IntList {
		@list : List;
		
		New() {
			@list := List->New();
		}

		method : public : AddBack(value : Int), Nil {
			holder : IntHolder := IntHolder->New(value);
			@list->AddBack(holder->As(Compare));
		}

		method : public : AddFront(value : Int), Nil {
			holder : IntHolder := IntHolder->New(value);
			@list->AddFront(holder->As(Compare));
		}

		method : public : Get(), Int {
			temp : Compare := @list->Get();
			holder : IntHolder := temp->As(IntHolder);
			return holder->Get();
		}
		
		method : public : Find(value : Int), Bool {
			holder : IntHolder := IntHolder->New(value);
			return @list->Find(holder->As(Compare));
		}
		
		method : public : Insert(value : Int), Nil {
			holder : IntHolder := IntHolder->New(value);
			@list->Insert(holder->As(Compare));
		}

		method : public : RemoveBack(), Nil {
			@list->RemoveBack();
		}
		
		method : public : RemoveFront(), Nil {
			@list->RemoveFront();
		}
		
		method : public : Rewind(), Nil {
			@list->Rewind();
		}
		
		method : public : Forward(), Nil {
			@list->Forward();
		}
		
		method : public : Next(), Nil {
			@list->Next();
		}
		
		method : public : Previous(), Nil {
			@list->Previous();
		}
		
		method : public : Remove(), Nil {
			@list->Remove();
		}
		
		method : public : IsStart(), Bool {
			return @list->IsStart();
		}	
		
		method : public : IsEnd(), Bool {
			return @list->IsEnd();
		}
		
		method : public : Size(), Int {
			return @list->Size();
		}
	}

	class IntHolder from Compare {
		@value : Int;

		New(value : Int) {
			Parent();
			@value := value;
		}

		method : public : Get(), Int {
			return @value;
		}

		method : public : native : Compare(rhs : Compare), Int {
			right : IntHolder := rhs->As(IntHolder);
			if(@value = right->Get()) {
				return 0;
			}
			else if(@value < right->Get()) {
				return -1;
			};
			
			return 1;
		}

		method : public : HashID(), Int {
			return @value;
		}
	}
	
	# TODO: refactor!
	# Float Linked List
	class FloatList {
		@list : List;
		
		New() {
			@list := List->New();
		}

		method : public : AddBack(value : Float), Nil {
			holder : FloatHolder := FloatHolder->New(value);
			@list->AddBack(holder->As(Compare));
		}

		method : public : AddFront(value : Float), Nil {
			holder : FloatHolder := FloatHolder->New(value);
			@list->AddFront(holder->As(Compare));
		}

		method : public : Get(), Float {
			temp : Compare := @list->Get();
			holder : FloatHolder := temp->As(FloatHolder);
			return holder->Get();
		}
		
		method : public : Find(value : Float), Bool {
			holder : FloatHolder := FloatHolder->New(value);
			return @list->Find(holder->As(Compare));
		}
		
		method : public : Insert(value : Float), Nil {
			holder : FloatHolder := FloatHolder->New(value);
			@list->Insert(holder->As(Compare));
		}
		
		method : public : RemoveBack(), Nil {
			@list->RemoveBack();
		}
		
		method : public : RemoveFront(), Nil {
			@list->RemoveFront();
		}
		
		method : public : Rewind(), Nil {
			@list->Rewind();
		}
		
		method : public : Forward(), Nil {
			@list->Forward();
		}
		
		method : public : Next(), Nil {
			@list->Next();
		}
		
		method : public : Previous(), Nil {
			@list->Previous();
		}
		
		method : public : Remove(), Nil {
			@list->Remove();
		}
		
		method : public : IsStart(), Bool {
			return @list->IsStart();
		}	
		
		method : public : IsEnd(), Bool {
			return @list->IsEnd();
		}
		
		method : public : Size(), Int {
			return @list->Size();
		}
	}
	
	class FloatHolder from Compare {
		@value : Float;

		New(value : Float) {
			Parent();
			@value := value;
		}

		method : public : Get(), Float {
			return @value;
		}

		method : public : native : Compare(rhs : Compare), Int {
			right : FloatHolder := rhs->As(FloatHolder);
			if(@value = right->Get()) {
				return 0;
			}
			else if(@value < right->Get()) {
				return -1;
			};
			
			return 1;
		}
		
		method : public : HashID(), Int {
			return @value * 10000.0;
		}
	}

	# Linked List
	class ListNode {
		@value : Compare;
		@next : ListNode;
		@previous: ListNode;

		New(value : Compare) {
			@value := value;
		}
		
		method : public : Set(value : Compare), Nil {
			@value := value;
		}
	
		method : public : Get(), Compare {
			return @value;
		}

		method : public : SetNext(next : Structure.ListNode), Nil {
			@next := next;
		}
	
		method : public : GetNext(), ListNode {
			return @next;
		}

		method : public : SetPrevious(previous : Structure.ListNode), Nil {
			@previous := previous;
		}
	
		method : public : GetPrevious(), ListNode {
			return @previous;
		}
	}

	# Doubly linked-list
	class List {
		@size : Int;
		@head : ListNode;
		@tail : ListNode;
		@cursor : ListNode;

		New() {
			@size := 0;
		}

		method : public : native : AddBack(value : Compare), Nil {
			node : ListNode := ListNode->New(value);
			if(@head = Nil) {
				@head := node;
				@tail := @head;
				@cursor := @head;
				
			}
			else {
				@tail->SetNext(node);
			 	node->SetPrevious(@tail);	
				@tail := node;
			};
			@size := @size + 1;
		}
		
		method : public : RemoveBack(), Nil {
			Forward();
			Remove();
		}

		method : public : native : AddFront(value : Compare), Nil {
			node : ListNode := ListNode->New(value);
			if(@head = Nil) {
				@head := node;
				@tail := @head;
				@cursor := @head;
			}
			else {
				@head->SetPrevious(node);
				node->SetNext(@head);
				@head := node;
				@cursor := @head;
			};
			@size := @size + 1;
		}
		
		method : public : RemoveFront(), Nil {
			Rewind();
			Remove();
		}

		method : public : Rewind(), Nil {
			@cursor := @head;
		}		

		method : public : Forward(), Nil {
			@cursor := @tail;
		}		

		method : public : Next(), Nil {
			if(@cursor <> Nil) {
				@cursor := @cursor->GetNext();
			};
		}

		method : public : Previous(), Nil {
			if(@cursor <> Nil) {
				@cursor := @cursor->GetPrevious();
			};
		}

		method : public : Get(), Compare {
			if(@cursor <> Nil) {
				return @cursor->Get();
			};

			return Nil;
		}

		method : public : Find(value : Compare), Bool {
			@cursor := @head;
			while(@cursor <> Nil) {
				if(value->Compare(@cursor->Get()) = 0) {
					return true;
				};
				@cursor := @cursor->GetNext();
			};

			return false;
		}
		
		method : public : Insert(value : Compare), Bool {
			if(@cursor <> Nil) {
				node : ListNode := ListNode->New(value);
				@cursor->SetNext(node);
			 	node->SetPrevious(@cursor);
			 	if(@cursor = @head & @cursor = @tail) {
			 		@cursor := node;
			 		@head := @cursor;
			 		@tail := @cursor;
			 	}
			 	else if(@cursor = @head) {
			 		@cursor := node;
			 		@head := @cursor;
			 	}
			 	else if(@cursor = @tail) {
			 		@cursor := node;
			 		@tail := @cursor;
			 	}
			 	else {
			 		@cursor := node;
			 	};
			 	@size := @size + 1;
				
				return true;
			};
			
			return false;
		}
		
		method : public : Remove(), Nil {
			if(@cursor <> Nil) {
				if(@cursor->GetPrevious() <> Nil) {
					@cursor->GetPrevious()->SetNext(@cursor->GetNext());
				};
				if(@cursor = @head & @cursor = @tail) {
			 		@cursor := @cursor->GetNext();
			 		@head := @cursor;
			 		@tail := @cursor;
			 	}
			 	else if(@cursor = @head) {
			 		@cursor := @cursor->GetNext();
			 		@head := @cursor;
			 	}
			 	else if(@cursor = @tail) {
			 		@cursor := @cursor->GetNext();
			 		@tail := @cursor;
			 	}
			 	else {
			 		@cursor := @cursor->GetNext();
			 	};
				@size := @size - 1;
			};
		}

		method : public : IsStart(), Bool {
			return @cursor = Nil;
		}		
		
		method : public : IsEnd(), Bool {
			return @cursor = Nil;
		}		

		method : public : Size(), Int {
			return @size;
		}
	}

	

	# Tree
	class TreeNode {
		@key : Compare;
		@value : Base;
		@left : TreeNode;
		@right : TreeNode;
		@level : Int;
		
		New(key : Compare, value : Base, level : Int) {
			@key := key;
			@value := value;
			@level := level;
			@left := Nil;
			@right := Nil;
		}

		method : public : SetKey(key : Compare), Nil {
			@key := key;
				
		}
		
		method : public : native : GetKey(), Compare {
			return @key;
		}

		method : public : Get(), Base {
			return @value;
		}
		
		method : public : GetLevel(), Int {
			return @level;
		}

		method : public : SetLevel(level : Int), Nil {
			@level := level;
		}

		method : public : GetLeft(), TreeNode {
			return @left;
		}

		method : public : SetLeft(left : TreeNode), Nil {
			@left := left;
		}

		method : public : GetRight(), TreeNode {
			return @right;
		}

		method : public : SetRight(right : TreeNode), Nil {
			@right := right;
		}
	}
	
	class IntMap {
		@map : Map;

		New() {
			@map := Map->New();
		}

		method : public : Insert(key : Int, value : Base), Nil {
			@map->Insert(IntHolder->New(key)->As(Compare), value);
		}
		
		method : public : Remove(key : Int), Nil {
			@map->Remove(IntHolder->New(key)->As(Compare));
		}
    
		method : public : Find(key : Int), Int {
			result : IntHolder := @map->Find(IntHolder->New(key)->As(Compare))->As(IntHolder);
			if(result <> Nil) {
				return result->Get();
			};

			return 0;
		}
    
    method : public : GetKeys(), IntVector {
			keys := IntVector->New();
			holder_keys := @map->GetKeys();
			for(i := 0; i < keys->Size(); i := i + 1;) {
				holder_value : IntHolder := holder_keys->Get(i)->As(IntHolder);
				keys->AddBack(holder_value->Get());   
			};

			return keys;
		}
    
    method : public : GetValues(), Vector {
			return @map->GetValues();
		}

		method : public : native : Size(), Int {
			return @map->Size();
		}
	}

	class FloatMap {
		@map : Map;

		New() {
			@map := Map->New();
		}

		method : public : Insert(key : Float, value : Base), Nil {
			@map->Insert(FloatHolder->New(key)->As(Compare), value);
		}
		
		method : public : Remove(key : Float), Nil {
			@map->Remove(FloatHolder->New(key)->As(Compare));
		}
    
		method : public : Find(key : Float), Float {
			result : FloatHolder := @map->Find(FloatHolder->New(key)->As(Compare))->As(FloatHolder);
			if(result <> Nil) {
				return result->Get();
			};

			return 0;
		}
    
    method : public : GetKeys(), FloatVector {
			keys := FloatVector->New();
			holder_keys := @map->GetKeys();
			for(i := 0; i < keys->Size(); i := i + 1;) {
				holder_value : FloatHolder := holder_keys->Get(i)->As(FloatHolder);
				keys->AddBack(holder_value->Get());   
			};

			return keys;
		}
    
    method : public : GetValues(), Vector {
			return @map->GetValues();
		}

		method : public : native : Size(), Int {
			return @map->Size();
		}
	}

	class StringMap {
		@map : Map;

		New() {
			@map := Map->New();
		}

		method : public : Insert(key : String, value : Base), Nil {
			@map->Insert(key->As(Compare), value);
		}
		
		method : public : Remove(key : String), Nil {
			@map->Remove(key->As(Compare));
		}
    
		method : public : Find(key : String), String {
			return @map->Find(key->As(Compare))->As(String);
		}
    
    method : public : GetKeys(), Vector {
			return @map->GetKeys();
		}
    
    method : public : GetValues(), Vector {
			return @map->GetValues();
		}

		method : public : native : Size(), Int {
			return @map->Size();
		}
	}

	class Map {
		@root : TreeNode;
		@last : TreeNode;
		@Removed : TreeNode;
		@size : Int;
		@found : Bool;

		New() {
			@root := Nil;
			@size := 0;	
		}		

		method : native : Skew(node : Structure.TreeNode), TreeNode {
			if(node = Nil | node->GetLeft() = Nil) {
				return node;
			};
				
			if(node->GetLeft()->GetLevel() = node->GetLevel()) {
				left : TreeNode := node->GetLeft();
				node->SetLeft(left->GetRight());
				left->SetRight(node);
				return left;
			};
			
			return node;
		}

		method : public : native : Size(), Int {
			return @size;
		}

		method : native : Split(node : Structure.TreeNode), TreeNode {
			if(node = Nil | node->GetRight() = Nil | 
					node->GetRight()->GetRight() = Nil) {
				return node;
			};

			if(node->GetRight()->GetRight()->GetLevel() = node->GetLevel()) {
				right : TreeNode := node->GetRight();
				node->SetRight(right->GetLeft());
				right->SetLeft(node);
				right->SetLevel(right->GetLevel() + 1);
				
				return right;
			};
			
			return node;
		}
		
		method : public : Find(key : Compare), Base {
			return Find(key, @root);
		}
		
		method : Find(key : Compare, node : Structure.TreeNode), Base {
			if(node <> Nil) {
				if(key->Compare(node->GetKey()) < 0) {
					return Find(key, node->GetLeft());
				}
				else if(key->Compare(node->GetKey()) > 0) {
					return Find(key, node->GetRight());
				}
				else {
					return node->Get();		
				};
			};
			
			return Nil;
		}
		
		method : public : GetKeys(), Structure.Vector {
			vector : Vector := Vector->New();
			GetKeys(@root, vector);

			return vector;
		}
		
		method : native : GetKeys(node : Structure.TreeNode, vector : Structure.Vector), Nil {
			if(node <> Nil) {
				# process left 
				GetKeys(node->GetLeft(), vector);
				
				key : Compare := node->GetKey();
				vector->AddBack(key->As(Base));
				
				# process right
				GetKeys(node->GetRight(), vector);
			};
		}
		
		method : public : GetValues(), Structure.Vector {
			vector : Vector := Vector->New();
			GetValues(@root, vector);

			return vector;
		}

		method : native : GetValues(node : Structure.TreeNode, vector : Structure.Vector), Nil {
			if(node <> Nil) {
				# process left 
				GetValues(node->GetLeft(), vector);
				
				value : Base := node->Get();
				vector->AddBack(value);
				
				# process right
				GetValues(node->GetRight(), vector);
			};
		}
		
		method : public : native : Insert(key : Compare, value : Base), Nil {
			if(@root = Nil) {
				@root := Insert(key, value, Nil->As(Structure.TreeNode));
			}
			else {
				@root := Insert(key, value, @root);
			};
		}
		
		method : native : Insert(key : Compare, value : Base, node : Structure.TreeNode), Structure.TreeNode {
			if(node = Nil) {
				node := TreeNode->New(key, value, 1);
				@size := @size + 1;
			}
			else {
				if(key->Compare(node->GetKey()) < 0) {
					node->SetLeft(Insert(key, value, node->GetLeft()));
				}
				else if(key->Compare(node->GetKey()) > 0) {
					node->SetRight(Insert(key, value, node->GetRight()));
				}
				else {
					return node;		
				};
				node := Skew(node);
				node := Split(node);
			};	
			
			return node;
		}

		method : public : Remove(key : Compare), Nil {
			@found := true;
			@root := Remove(key, @root);
			if(@found) {
				@size := @size - 1;
			};
		}
		
		method : native : Remove(key : Compare, node : Structure.TreeNode), Structure.TreeNode {
			if(node = Nil) {
				@found := false;
				return Nil;
			};

			if(key->Compare(node->GetKey()) < 0) {
				node->SetLeft(Remove(key, node->GetLeft()));
			}
			else if(key->Compare(node->GetKey()) > 0) {
				node->SetRight(Remove(key, node->GetRight()));
			}
			else {
				if(node->GetLeft() = Nil & node->GetRight() = Nil) {
					return Nil;
				}
				else if(node->GetLeft() = Nil) {
					left : Compare := Successor(node);
					node->SetRight(Remove(left, node->GetRight()));
					node->SetKey(left);
				} 
				else {
					left : Compare := Predecessor(node);
					node->SetLeft(Remove(left, node->GetLeft()));
					node->SetKey(left);
				};
				
			};
			
			# rebalanced
			node := DecreaseLevel(node);				
			node := Skew(node);
			node->SetRight(Skew(node->GetRight()));
			if(node->GetRight() <> Nil & node->GetRight()->GetRight() <> Nil) {
				node->GetRight()->SetRight(Skew(node->GetRight()->GetRight()));
			};	
			node := Split(node);								
			node->SetRight(Split(node->GetRight()));

			return node;
		}
		
		method : Predecessor(node : Structure.TreeNode), Compare {
			if(node->GetLeft() <> Nil) {
				left : TreeNode := node->GetLeft();
				while(left->GetLeft() <> Nil) {
					left := left->GetLeft();
				};

				return left->GetKey();
			};

			return node->GetKey();
		}

		method : Successor(node : Structure.TreeNode), Compare {
			if(node->GetRight() <> Nil) {
				right : TreeNode := node->GetRight();
				while(right->GetRight() <> Nil) {
					right := right->GetRight();
				};

				return right->GetKey();
			};

			return node->GetKey();
		}

		 method : DecreaseLevel(node : Structure.TreeNode), TreeNode {
			if(node->GetLeft() <> Nil & node->GetRight() <> Nil) {
				left : Int := node->GetLeft()->GetLevel();
				right : Int := node->GetRight()->GetLevel();
				value : Int := left->Min(right);
			
				if(value < node->GetLevel()) {
					node->SetLevel(value);
					if(value < node->GetRight()->GetLevel()) {
						node->GetRight()->SetLevel(value);
					};
				};
			};
			
			return node;
		}
	}

	# Hash table
	class StringHash {
		@hash : Hash;

		New() {
			@hash := Hash->New();
		}

		method : public : Insert(key : String, value : Base), Nil {
			@hash->Insert(key->As(Compare), value);
		}
		
		method : public : Remove(key : String), Nil {
			@hash->Remove(key->As(Compare));
		}
    
		method : public : Find(key : String), String {
			return @hash->Find(key->As(Compare))->As(String);
		}
    
    method : public : GetKeys(), Vector {
			return @hash->GetKeys();
		}
    
    method : public : GetValues(), Vector {
			return @hash->GetValues();
		}

		method : public : native : Size(), Int {
			return @hash->Size();
		}
	}

	class HashPair from Compare {
		@key : Compare;
		@value : Base;

		New(key : Compare, value : Base) {
			Parent();
			@key := key;
			@value := value;
		}

		method : public : native : Compare(rhs : Compare), Int {		
			return @key->Compare(rhs);
		}

		method : public : HashID(), Int {
			return @key->HashID();
		}
		
		method : public : native : GetKey(), Compare {
			return @key;
		}

		method : public : native : Get(), Base {
			return @value;
		}
	}
	
	class Hash {
		@buckets : List[];
		@size : Int;
		
		New() {
			@buckets := List->New[337];
			@size := 0;
		}
		
		method : public : native : Insert(key : Compare, value : Base), Nil {
			hash := (2 xor key->HashID() % @buckets->Size())->Abs();
# hash->PrintLine();
			list := @buckets[hash];
			if(list = Nil) {
				list := List->New();
				@buckets[hash] := list;
			};
			list->AddBack(HashPair->New(key, value)->As(Compare));
			@size := @size + 1;
		}

		method : public : native : Find(key : Compare), Base {
			hash := (2 xor key->HashID() % @buckets->Size())->Abs();
# hash->PrintLine();
			list := @buckets[hash];
			if(list <> Nil) {
				list->Rewind();
				while(list->IsEnd() = false) {
					pair : HashPair := list->Get()->As(HashPair);
					if(pair->Compare(key) = 0) {
						return pair->Get();
					};
					list->Next();
				};

				return Nil;
			};

			return Nil;
		}
		
		method : public : Remove(key : Compare), Bool {
			hash := (2 xor key->HashID() % @buckets->Size())->Abs();
# hash->PrintLine();
			list := @buckets[hash];
			if(list <> Nil) {
				list->Rewind();
				while(list->IsEnd() = false) {
					pair : HashPair := list->Get()->As(HashPair);
					if(pair->Compare(key) = 0) {
						list->Remove();
						@size := @size - 1;
						return true;
					};
					list->Next();
				};

				return false;
			};

			return false;
		}
		
		method : public : native : GetKeys(), Vector {
			keys := Vector->New();
			for(i := 0; i < @buckets->Size(); i := i + 1;) {
				if(@buckets[i] <> Nil) {
					list := @buckets[i];
					list->Rewind();
					while(list->IsEnd() = false) {
						pair : HashPair := list->Get()->As(HashPair);
						keys->AddBack(pair->GetKey()->As(Base));
						list->Next();
					};
				};
			};
			
			return keys;
		}
		
		method : public : native : GetValues(), Vector {
			values := Vector->New();
			for(i := 0; i < @buckets->Size(); i := i + 1;) {
				if(@buckets[i] <> Nil) {
					list := @buckets[i];
					list->Rewind();
					while(list->IsEnd() = false) {
						pair : HashPair := list->Get()->As(HashPair);
						values->AddBack(pair->Get());
						list->Next();
					};
				};
			};
			
			return values;
		}
		
		method : public : Size(), Int {
			return @size;
		}
	}
}

bundle Net {
	class HttpClient {
		@headers : Map;
		@url : String;
		@port : Int;
		@content_type : String;
		
		New(url : String, port : Int) {
			@url := url;
			@port := port;
			@content_type := "text/plain";
			@headers := Map->New();
		}
		
		New(url : String, port : Int, content_type : String) {
			@url := url;
			@port := port;
			@content_type := content_type;
			@headers := Map->New();
		}
		
		method : GetHeaders(), Map {
			return @headers;
		}
		
		method : public : Post(content : String), Bool {
			if(@url->StartsWith("http://")) {
				@url := @url->SubString("http://"->Size(), 
					@url->Size() - "http://"->Size());
				index := @url->GetIndex('/');
				address := "";
				location := "/";
				if(index > -1) {
					address := @url->SubString(index);
					index->PrintLine();
					location := @url->SubString(index + 1, @url->Size() - index - 1);
				}
				else {
					address := @url;
				};
				
				socket := TCPSocket->New(address, @port);
				if(socket->IsOpen()) {
					post := "POST ";
					post->Append(location);
					post->Append(" HTTP/1.1\r\nHost: ");
					post->Append(address);
					post->Append("\r\nContent-Length: ");
					post->Append(content->Size()->ToString());
					post->Append("\r\nContent-Type: ");
					post->Append(@content_type);
					post->Append("\r\n\r\n");
					socket->WriteString(post);
					post->Append(content);
				};
			}
			else {
				return false;
			};
			
			return true;
		}
		
		method : public : native : Get(), Vector {
			content := Vector->New();
			if(@url->StartsWith("http://")) {
				@url := @url->SubString("http://"->Size(), @url->Size() - "http://"->Size());
				index := @url->GetIndex('/');
				address := "";
				location := "/";
				if(index > -1) {
					address := @url->SubString(index);
					location := @url->SubString(index + 1, @url->Size() - index - 1);
				}
				else {
					address := @url;
				};
				
				socket := TCPSocket->New(address, @port);
				if(socket->IsOpen()) {
					get := "GET ";
					get->Append(location);
					get->Append(" HTTP/1.1\r\nHost: ");
					get->Append(address);
					get->Append("\r\n\r\n");
					socket->WriteString(get);
	
					status_code := 500;
					status_line := socket->ReadString();
					if(status_line->StartsWith("HTTP/1.1")) {
						status_line := status_line->SubString("HTTP/1.1"->Size() + 1, 
							status_line->Size() - "HTTP/1.1"->Size() - 1);
						index := status_line->GetIndex(' ');
						status_code := status_line->SubString(index)->ToInt();
					};
					
					if(status_code <> 500) {
					  # get headers
						do {
							line := socket->ReadString();
							if(line->Size() > 0) {
								index := line->GetIndex(':');
								name := line->SubString(index);
								value := line->SubString(index + 1, line->Size() - index - 1)->Trim();			
								@headers->Insert(name->As(Compare), value->As(Base));
# IO.Console->Print("|")->Print(name)->Print("|, |")->Print(value)->PrintLine("|");
							};
						}
						while(line->Size() > 0);

						# look for chunked blocks
						encoding : String := @headers->Find("Transfer-Encoding"->As(Compare))->As(String);
						if(encoding <> Nil & encoding->Equals("chunked")) {
							done := false;
							do {
								size_line := "0x";
								size_line->Append(socket->ReadString());
								chunk_size := size_line->ToInt();
								line := "";
								if(chunk_size > 0) {
									for(i := 0; i < chunk_size; i := i + 1;) {
										line->Append(socket->ReadByte());
									};
									socket->ReadString();
									content->AddBack(line->As(Base));
								}
								else {
									done := true;
								};
							}
							while(done <> true);
						}
						else {
							length_header : String := @headers->Find("Content-Length"->As(Compare))->As(String);
							if(length_header <> Nil) {
								length := length_header->ToInt();
								buffer := Byte->New[length];
								for(i := 0; i < length; i := i + 1;) {
									buffer[i] := socket->ReadByte();
								};
								line := String->New(buffer);
								content->AddBack(line->As(Base));
							};						
						};
					};
					socket->Close();
				}
				else {
					return Nil;
				};
			};	
			
			return content;
		}
	}
}
