#~
Objeck system classes.
Copyright (c) 2008-2014 Randy Hollines
note: compile compiler with -D_SYSTEM flag
~#	

#~
System Bundle
~#
bundle System {
	#~
	Boolean class
	~#	
	class $Bool {
		#~
		Prints a boolean value
		@ignore-params
		~#
		function : Print(b : Bool) ~ Nil {
			STD_OUT_BOOL;
		}

		#~
		Prints a boolean value with a newline
		@ignore-params
		~#
		function : PrintLine(b : Bool) ~ Nil {
			STD_OUT_BOOL;
			'\n'->Print();
		}

		#~
		Prints an error boolean value
		@ignore-params
		~#
		function : Error(b : Bool) ~ Nil {
			STD_ERR_BOOL;
		}

		#~
		Prints an error boolean value with a newline
		@ignore-params
		~#
		function : ErrorLine(b : Bool) ~ Nil {
			STD_ERR_BOOL;
			'\n'->Print();
		}

		function : Size(b : Bool[]) ~ Int {
			LOAD_ARY_SIZE;
		}

		function : Size(b : Bool[,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		function : Size(b : Bool[,,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		#~
		Formats the boolean value into a string
		@ignore-params
		@return string value
		~#
		function : native : ToString(b : Bool) ~ String {
			string : String;

			if(b = true) {
				string := "true";
			}
			else {
			 	string := "false";
			};

			return string;			
		}
	}
	
	class Number {
		function : native : IntToString(value : Int, string : String) ~ Nil {
			values := Int->New[16];

			i := 0;
			if(value < 0) {
				value *= -1;
				string->Append('-');
			};

			while(value >= 10 & i < 16) {
				mod := value % 10;
				values[i] := mod;
				i += 1;
				value /= 10;
			};
			values[i] := value;
            
			while(i >= 0) {
				string->Append((values[i] + 48)->As(Char));
				i -= 1;
			};     
		}
		
		function : native : IntToHexString(value : Int, string : String) ~ Nil {
			values := Int->New[16];
			
			i := 0;
			if(value < 0) {
				value *= -1;
				string->Append('-');
			};

			while(value >= 16 & i < 16) {
				mod := value % 16;
				values[i] := mod;
				i += 1;
				value /= 16;
			};
			values[i] := value;
            
			while(i >= 0) {
				value := values[i];
				if(value > 9) {	
					string->Append((value + 55)->As(Char));
				}
				else {
					string->Append((value + 48)->As(Char));
				};
				i -= 1;
			};     
		}
	}
	
	#~
	The byte class represents a 1-byte value.
	~#
	class $Byte {
		#~
		Returns the smallest byte value
		@param r value to compare
		@ignore-param l
		@return smallest byte value
		~#
		function : native : Min(l : Byte, r : Byte) ~ Byte {
			if(l < r) {
				return l;
			};

			return r;
		}

		#~
		Returns the largest byte value
		@param r value to compare
		@ignore-param l
		@return largest byte value
		~#
		function : native : Max(l : Byte, r : Byte) ~ Byte {
			if(l > r) {
				return l;
			};

			return r;
		}

		#~
		Returns the absolute value
		@ignore-params l
		@return absolute value
		~#
		function : native : Abs(v : Byte) ~ Byte {
			if(v < 0) {
				return v * -1;
			};

			return v;
		}

		#~
		Prints value 
		@ignore-params
		~#
		function : Print(b : Byte) ~ Nil {
			STD_OUT_BYTE;
		}

		#~
		Prints value with newline
		@ignore-params
		~#
		function : PrintLine(b : Byte) ~ Nil {
			STD_OUT_BYTE;
			'\n'->Print();
		}

		#~
		Prints error value
		@ignore-params
		~#
		function : Error(b : Byte) ~ Nil {
			STD_ERR_BYTE;
		}

		#~
		Prints error value with newline
		@ignore-params
		~#
		function : ErrorLine(b : Byte) ~ Nil {
			STD_ERR_BYTE;
			'\n'->Print();
		}

		function : Size(b : Byte[]) ~ Int {
			LOAD_ARY_SIZE;
		}
		
		function : ToUnicode(b : Byte[]) ~ Char[] {
			BYTES_TO_UNICODE;
		}
		
		function : native :  Sort(v : Byte[]) ~ Byte[] {
			size := v->Size();
			if(size <= 1) {
				return v;
			};			
			array := Byte->New[size];
			Runtime->Copy(array, 0, v, 0, size);
			Sort(array, 0, size - 1);
			
			return array;
		}
		
		function : native : Sort(array : Byte[], low : Int, high : Int) ~ Nil {
			i := low; j := high;
			pivot := array[low + (high-low)/2];

			while(i <= j) {
				while(array[i] < pivot) {
					i+=1;
				};
	
				while(array[j] > pivot) {
					j-=1;
				};

				if (i <= j) {
					temp := array[i];
					array[i] := array[j];
					array[j] := temp;
					i+=1; j-=1;
				};
			};
	
			if(low < j) {
				Sort(array, low, j);
			};

			if(i < high) {
				Sort(array, i, high);
			};
		}

		function : Size(b : Byte[,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		function : Size(b : Byte[,,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}
		
		#~
		Returns a binary string representation of the value
		@ignore-params
		@return binary string representation of the value
		~#
		function : native : ToBinaryString(b : Byte) ~ String {
			out := String->New();
			while(b > 0) {
				v := b % 2;
				out->Append(v);
				b /= 2;
			};

			return out->Reverse();
		}

		#~
		Returns a hexadecimal string representation of the value
		@ignore-params
		@return hexadecimal string representation of the value
		~#
		function : native : ToHexString(b : Byte) ~ String {
			str := String->New();
			Number->IntToHexString(b->As(Int), str);
			return str;
		}
		
		function : native : ToHexString(b : Byte[]) ~ String {
			out := String->New();
			each(i : b) {
				str := String->New();
				Number->IntToHexString(b[i]->As(Int), str);
				out->Append(str);
			};
			
			return out;
		}
		
		#~
		Returns a string representation of the value
		@ignore-params
		@return string representation of the value
		~#
		function : native : ToString(b : Byte) ~ String {
			str := String->New();
			Number->IntToString(b->As(Int), str);
			return str;
		}
		
		function : native : ToString(b : Byte[]) ~ String {
			out := String->New();
			each(i : b) {
				ToString(b[i]);
				out->Append(ToString(b[i]));
			};
			
			return out;
		}
	}

	#~
	Character class represents a Unicode character value.
	~#	
	class $Char {
		#~
		Converts character to lower-case
		@ignore-params
		@return lower-case representation
		~#
		function : native : ToLower(c : Char) ~ Char {
			if(c >= 'A' & c <= 'Z') {
				return c + 32;
			};

			return c;
		}

		#~
		Converts character to upper-case
		@ignore-params
		@return upper-case representation
		~#
		function : native : ToUpper(c : Char) ~ Char {
			if(c >= 'a' & c <= 'z') {
				return c - 32;
			};

			return c;
		}

		#~
		Checks of the character is a numeric digit
		@ignore-params
		@return true if numeric digit, false otherwise
		~#
		function : native : IsDigit(c : Char) ~ Bool {
			if(c >= '0' & c <= '9') {
				return true;
			};
			
			return false;
		}

		#~
		Checks of the character is a alpha digit
		@ignore-params
		@return true if alpha digit, false otherwise
		~#
		function : native : IsChar(c : Char) ~ Bool {
			if((c >= 'a' & c <= 'z') | (c >= 'A' & c <= 'Z')) {
				return true;
			};
			
			return false;
		}
		
		#~
		Returns the smallest byte value
		@param r value to compare
		@ignore-param l
		@return smallest byte value
		~#
		function : native : Min(l : Char, r : Char) ~ Char {
			if(l < r) {
				return l;
			};

			return r;
		}

		#~
		Returns the largest byte value
		@param r value to compare
		@ignore-param l
		@return largest byte value
		~#
		function : native : Max(l : Char, r : Char) ~ Char {
			if(l > r) {
				return l;
			};

			return r;
		}

		#~
		Prints value 
		@ignore-params
		~#
		function : Print(c : Char) ~ Nil {
			STD_OUT_CHAR;
		}

		function : PrintLine(c : Char) ~ Nil {
			STD_OUT_CHAR;
			'\n'->Print();
		}
		
		#~
		Prints value with newline
		@ignore-params
		~#
		function : native :  Sort(c : Char[]) ~ Char[] {
			size := c->Size();
			if(size <= 1) {
				return c;
			};			
			array := Char->New[size];
			Runtime->Copy(array, 0, c, 0, size);
			Sort(array, 0, size - 1);
			
			return array;
		}
		
		function : native : Sort(array : Char[], low : Int, high : Int) ~ Nil {
			i := low; j := high;
			pivot := array[low + (high-low)/2];

			while(i <= j) {
				while(array[i] < pivot) {
					i+=1;
				};
	
				while(array[j] > pivot) {
					j-=1;
				};

				if (i <= j) {
					temp := array[i];
					array[i] := array[j];
					array[j] := temp;
					i+=1; j-=1;
				};
			};
	
			if(low < j) {
				Sort(array, low, j);
			};

			if(i < high) {
				Sort(array, i, high);
			};
		}

		function : native :  Print(c : Char[]) ~ Nil {
			STD_OUT_CHAR_ARY;
		}

		function : native :  PrintLine(c : Char[]) ~ Nil {
			STD_OUT_CHAR_ARY;
			'\n'->Print();
		}

		#~
		Prints error value
		@ignore-params
		~#
		function : Error(c : Char) ~ Nil {
			STD_ERR_CHAR;
		}

		#~
		Prints error value with newline
		@ignore-params
		~#
		function : ErrorLine(c : Char) ~ Nil {
			STD_ERR_CHAR;
			'\n'->Print();
		}

		function : native :  Error(c : Char[]) ~ Nil {
			STD_ERR_CHAR_ARY;
		}

		function : native :  ErrorLine(c : Char[]) ~ Nil {
			STD_ERR_CHAR_ARY;
			'\n'->Print();
		}
		
		function : Size(c : Char[]) ~ Int {
			LOAD_ARY_SIZE;
		}
		
		function : ToBytes(c : Char[]) ~ Byte[] {		
			UNICODE_TO_BYTES;
		}
		
		function : Size(c : Char[,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		function : Size(c : Char[,,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		#~
		Returns a string representation of the value
		@ignore-params
		@return string representation of the value
		~#
		function : native : ToString(c : Char) ~ String {
			string : String := String->New();
			string->Append(c);
			
			return string;
		}
	}
	
	#~
	Integer class represents an operating system long value
	~#
	class $Int {
		#~
		Returns the maximum size of an integer
		@return maximum size of an integer
		~#
		function : native : MaxSize() ~ Int {
			return 2147483647;
		}
		
		#~
		Calculates the factorial of existing value
		@return factorial of existing value
		~#
		function : native : Factorial(n : Int) ~ Int {
			result := 1;
			for (i := 1; i <= n; i += 1;) {
				result *= i;
			};

			return result;
		}

		#~
		Returns the smallest integer value
		@param r value to compare
		@ignore-param l
		@return smallest integer value
		~#
		function : native : Min(l : Int, r : Int) ~ Int {
			if(l < r) {
				return l;
			};

			return r;
		}
	
		#~
		Returns the largest integer value
		@param r value to compare
		@ignore-param l
		@return largest integer value
		~#
		function : native : Max(l : Int, r : Int) ~ Int {
			if(l > r) {
				return l;
			};

			return r;
		}

		#~
		Returns the absolute value
		@ignore-params l
		@return absolute value
		~#
		function : native : Abs(v : Int) ~ Int {
			if(v < 0) {
				return v * -1;
			};

			return v;
		}

		#~
		Prints value 
		@ignore-params
		~#
		function : Print(i : Int) ~ Nil {
			STD_OUT_INT;
		}

		#~
		Prints value with newline
		@ignore-params
		~#
		function : PrintLine(i : Int) ~ Nil {
			STD_OUT_INT;
			'\n'->Print();
		}
		
		#~
		Prints error value
		@ignore-params
		~#
		function : Error(i : Int) ~ Nil {
			STD_ERR_INT;
		}

		#~
		Prints error value with newline
		@ignore-params
		~#
		function : ErrorLine(i : Int) ~ Nil {
			STD_ERR_INT;
			'\n'->Print();
		}

		function : Size(i : Int[]) ~ Int {
			LOAD_ARY_SIZE;
		}

		function : Size(i : Int[,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		function : Size(i : Int[,,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		function : native : ToBinaryString(v : Int) ~ String {
			out := String->New();
			while(v > 0) {
				v := v % 2;
				out->Append(v);
				v /= 2;
			};

			return out->Reverse();
		}
		
		function : native : ToHexString(v : Int) ~ String {
			str := String->New();
			Number->IntToHexString(v->As(Int), str);
			return str;
		}
		
		function : native : ToHexString(v : Int[]) ~ String {
			out := String->New();
			each(i : v) {
				str := String->New();
				Number->IntToHexString(v[i]->As(Int), str);
				out->Append(str);
			};
			
			return out;
		}
		
		function : native :  Sort(v : Int[]) ~ Int[] {
			size := v->Size();
			if(size <= 1) {
				return v;
			};			
			array := Int->New[size];
			Runtime->Copy(array, 0, v, 0, size);
			Sort(array, 0, size - 1);
			
			return array;
		}
		
		function : native : Sort(array : Int[], low : Int, high : Int) ~ Nil {
			i := low; j := high;
			pivot := array[low + (high-low)/2];

			while(i <= j) {
				while(array[i] < pivot) {
					i+=1;
				};
	
				while(array[j] > pivot) {
					j-=1;
				};

				if (i <= j) {
					temp := array[i];
					array[i] := array[j];
					array[j] := temp;
					i+=1; j-=1;
				};
			};
	
			if(low < j) {
				Sort(array, low, j);
			};

			if(i < high) {
				Sort(array, i, high);
			};
		}
		
		function : native : ToString(v : Int) ~ String {
			str := String->New();
			Number->IntToString(v->As(Int), str);
			return str;
		}
		
		#~
		Returns a string representation of the value
		@ignore-params
		@return string representation of the value
		~#
		function : native : ToString(v : Int[]) ~ String {
			out := "[";
			each(i : v) {
				str := String->New();
				Number->IntToString(v[i]->As(Int), str);
				out->Append(str);
				if(i + i < v->Size()) {
					out->Append(',');
				};
			};
			out->Append(']');
			return out;
		}
	}

	#~
	Float class represents a double-precision floating-point value
	~#	
	class $Float {
		#~
		Value of Pi
		@return value of Pi
		~#
		function : native : Pi() ~ Float {
			return 3.1415926536;
		}

		#~
		Value of E
		@return value of E
		~#
		function : native : E() ~ Float {
			return 2.7182818285;
		}	

		#~
		Converts the value into radians
		@ignore-params
		@return radian value
		~#
		function : native : ToRadians(v : Float) ~ Float {
			return v * 3.1415926536 / 180.0;
		}
		
		#~
		Converts the value into degrees
		@ignore-params
		@return degree value
		~#
		function : native : ToDegrees(v : Float) ~ Float {
			return v * 180.0 / 3.1415926536;
		}

		#~
		Returns the smallest float value
		@param r value to compare
		@ignore-param l
		@return smallest float value
		~#
		function : native : Min(l : Float, r : Float) ~ Float {
			if(l < r) {
				return l;
			};

			return r;
		}

		#~
		Returns the largest float value
		@param r value to compare
		@ignore-param l
		@return largest float value
		~#
		function : native : Max(l : Float, r : Float) ~ Float {
			if(l > r) {
				return l;
			};

			return r;
		}

		#~
		Returns the absolute value
		@ignore-params l
		@return absolute value
		~#
		function : native : Abs(v : Float) ~ Float {
			if(v < 0) {
				return v * -1;
			};

			return v;
		}
		
		#~
		Calculates the floor value
		@ignore-params l
		@return floor value
		~#
		function : Floor(f : Float) ~ Float {
			FLOR_FLOAT;
		}
		
		#~
		Calculates the ceiling value
		@ignore-params l
		@return ceiling value
		~#
		function : Ceiling(f : Float) ~ Float {
			CEIL_FLOAT;
		}
		
		#~
		Calculates the sine value
		@ignore-params l
		@return sine value
		~#
		function : Sin(f : Float) ~ Float {
			SIN_FLOAT;
		}
		
		#~
		Calculates the cosine value
		@ignore-params l
		@return cosine value
		~#
		function : Cos(f : Float) ~ Float {
			COS_FLOAT;
		}
		
		#~
		Calculates the tangent value
		@ignore-params l
		@return tangent value
		~#
		function : Tan(f : Float) ~ Float {
			TAN_FLOAT;
		}

		#~
		Calculates the arc-sine value
		@ignore-params l
		@return arc-sine value
		~#
		function : ArcSin(f : Float) ~ Float {
			ASIN_FLOAT;
		}
		
		#~
		Calculates the cosine value
		@ignore-params l
		@return cosine value
		~#
		function : ArcCos(f : Float) ~ Float {
			ACOS_FLOAT;
		}
		
		#~
		Calculates the arc-tangent value
		@ignore-params l
		@return arc-tangent value
		~#
		function : ArcTan(f : Float) ~ Float {
			ATAN_FLOAT;
		}
		
		#~
		Calculates the log value
		@ignore-params l
		@return log value
		~#
		function : Log(f : Float) ~ Float {
			LOG_FLOAT;
		}
		
		#~
		Calculates the natural log value
		@ignore-params l
		@return natural log value
		~#
		function : SquareRoot(f : Float) ~ Float {
			SQRT_FLOAT;
		}
		
		#~
		Returns a pseudo random value between 0.0 and 1.0
		@ignore-params
		@return pseudo random value
		~#
		function : Random() ~ Float {
			RAND_FLOAT;
		}
		
		#~
		Calculates the power value
		@ignore-param f
		@param r power to raise
		@return pseudo power value
		~#
		function : Power(f : Float, r : Float) ~ Float {
			POW_FLOAT;
		}

		#~
		Prints value 
		@ignore-params
		~#
		function : Print(f : Float) ~ Nil {
			STD_OUT_FLOAT;
		}

		#~
		Prints value with newline
		@ignore-params
		~#
		function : PrintLine(f : Float) ~ Nil {
			STD_OUT_FLOAT;
			'\n'->Print();
		}

		#~
		Prints error value
		@ignore-params
		~#
		function : Error(f : Float) ~ Nil {
			STD_ERR_FLOAT;
		}

		#~
		Prints error value with newline
		@ignore-params
		~#
		function : ErrorLine(f : Float) ~ Nil {
			STD_ERR_FLOAT;
			'\n'->Print();
		}
		
		function : Size(f : Float[]) ~ Int {
			LOAD_ARY_SIZE;
		}

		function : Size(f : Float[,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		function : Size(f : Float[,,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		#~
		Returns a string representation of the value
		@ignore-params
		@return string representation of the value
		~#
		function : native : ToString(f : Float) ~ String {
			str := String->New();
			if(f < 0.0) {
				str->Append('-');
				f *= -1.0;
			};
		
			zero := 0;
			remainder := f - f->Floor();
			if(remainder <> 0.0) {
				while(remainder < 0.099) {
					f *= 10.0;
					remainder := f - f->Floor();
					zero += 1;
				};
			};

			Number->IntToString(f->Floor()->As(Int), str);
			str->Append('.');
			for(i := 0; i < zero; i+=1;) {
				str->Append('0');
			};
			Number->IntToString((1001.0 * remainder)->As(Int), str);

			return str;
		}

		function : native : ToString(v : Float[]) ~ String {
			out := "[";
			each(i : v) {
				out->Append(ToString(v[i]));
				if(i + i < v->Size()) {
				  out->Append(',');
				};
			};
			out->Append(']');
			return out;
		}
		
		function : native :  Sort(v : Float[]) ~ Float[] {
			size := v->Size();
			if(size <= 1) {
				return v;
			};			
			array := Float->New[size];
			Runtime->Copy(array, 0, v, 0, size);
			Sort(array, 0, size - 1);
			
			return array;
		}
		
		function : native : Sort(array : Float[], low : Int, high : Int) ~ Nil {
			i := low; j := high;
			pivot := array[low + (high-low)/2];

			while(i <= j) {
				while(array[i] < pivot) {
					i+=1;
				};
	
				while(array[j] > pivot) {
					j-=1;
				};

				if (i <= j) {
					temp := array[i];
					array[i] := array[j];
					array[j] := temp;
					i+=1; j-=1;
				};
			};
	
			if(low < j) {
				Sort(array, low, j);
			};

			if(i < high) {
				Sort(array, i, high);
			};
		}
	}

	#~~
	# Array class support
	~~#	
	class $BaseArray {
		function : Size(f : System.Base[]) ~ Int {
			LOAD_ARY_SIZE;
		}

		function : Size(f : System.Base[,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		function : Size(f : System.Base[,,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}
	}

	#~
	Holds an integer value
	~#
	class IntHolder implements Compare {
		@value : Int;

		#~
		Default constructor
		~#
		New() {
			Parent();
			@value := 0;
		}

		#~
		Copy constructor
		@param value integer value
		~#
		New(value : Int) {
			Parent();
			@value := value;
		}

		#~
		Get integer value
		@return integer value
		~#
		method : public : Get() ~ Int {
			return @value;
		}

		#~
		Compares two objects
		@param rhs compare object
		@return true if objects are equal, false otherwise
		~#
		method : public : native : Compare(rhs : System.Compare) ~ Int {
			right : IntHolder := rhs->As(IntHolder);
			if(@value = right->Get()) {
				return 0;
			}
			else if(@value < right->Get()) {
				return -1;
			};
			
			return 1;
		}

		#~
		Returns a unique hash ID for a integer
		@return hash ID
		~#
		method : public : HashID() ~ Int {
			return @value;
		}
	}

	#~
	Holds an integer array
	~#
	class IntArrayHolder {
		@values : Int[];

		#~
		Copy constructor 
		@param values integer array
		~#
		New(values : Int[]) {
			Parent();
			@values := values;
		}

		#~
		Gets the value
		@return value
		~#
		method : public : Get() ~ Int[] {
			return @values;
		}
	}

	#~
	Holds a float
	~#
	class FloatHolder implements Compare {
		@value : Float;

		#~
		Default constructor
		~#
		New() {
			Parent();
			@value := 0.0;
		}

		#~
		Copy constructor 
		@param value float value
		~#
		New(value : Float) {
			Parent();
			@value := value;
		}

		#~
		Gets the value
		@return value
		~#
		method : public : Get() ~ Float {
			return @value;
		}

		#~
		Compares two objects
		@param rhs compare object
		@return true if objects are equal, false otherwise
		~#
		method : public : native : Compare(rhs : System.Compare) ~ Int {
			right : FloatHolder := rhs->As(FloatHolder);
			if(@value = right->Get()) {
				return 0;
			}
			else if(@value < right->Get()) {
				return -1;
			};
			
			return 1;
		}
		
		#~
		Returns a unique hash ID for a float
		@return hash ID
		~#
		method : public : HashID() ~ Int {
			return @value * 10000.0;
		}
	}
	
	#~
	Holds a float array
	~#
	class FloatArrayHolder {
		@values : Float[];

		#~
		Copy constructor 
		@param values float array
		~#
		New(values : Float[]) {
			Parent();
			@values := values;
		}

		#~
		Gets the value
		@return value
		~#
		method : public : Get() ~ Float[] {
			return @values;
		}
	}

	#~
	Holds a byte array
	~#
	class ByteArrayHolder {
		@values : Byte[];

		#~
		Copy constructor 
		@param values byte array
		~#
		New(values : Byte[]) {
			Parent();
			@values := values;
		}

		#~
		Gets the value
		@return value
		~#
		method : public : Get() ~ Byte[] {
			return @values;
		}
	}

	#~
	Holds a character array
	~#
	class CharArrayHolder {
		@values : Char[];

		#~
		Copy constructor 
		@param values character array
		~#
		New(values : Char[]) {
			Parent();
			@values := values;
		}

		#~
		Gets the value
		@return value
		~#
		method : public : Get() ~ Char[] {
			return @values;
		}
	}

	#~~
	# Class identifier
	~~#	
	enum ClassID {
	}

	#~~
	# Provides useful base class functionality
	~~#	
	class Base {
		New() {
		}

		method : public : GetClass() ~ Introspection.Class {
			cls : Class;
			LOAD_CLS_BY_INST;
			return cls;
		}
		
		method : public : native : GetClassID() ~ ClassID {
			LOAD_CLS_INST_ID;
		}

		method : public : native : GetInstanceID() ~ Int {
			LOAD_INST_UID;
		}
	}
	
	#~
	Used to compare two abstract values
	~#	
	interface Compare {
		#~
		Compares two objects
		@param rhs compare object
		@return true if objects are equal, false otherwise
		~#
		method : virtual : public : Compare(rhs : System.Compare) ~ Int;

		#~
		Returns a hash ID for the given class
		@return hash ID
		~#
		method : virtual : public : HashID() ~ Int;
	}

	#~
	Provides rudimentary compare functionality 
	~#
	class BasicCompare implements System.Compare {
		#~
		Default constructor
		~#
		New() {
			Parent();
		}

		#~
		Compares two objects
		@param rhs compare object
		@return true if objects are equal, false otherwise
		~#
		method : public : Compare(rhs : System.Compare) ~ Int {
			if(GetInstanceID() = rhs->GetInstanceID()) {
				return 0;
			}
			else if(GetInstanceID() < rhs->GetInstanceID()) {
				return 1;
			};

			return -1;
		}

		#~
		Returns the class default hash ID
		@return hash ID
		~#
		method : public : HashID() ~ Int {
			return GetInstanceID();
		}
	}
	
	#~
	Resizeable Unicode string class that supports typical string operations.
	~#	
	class String implements System.Compare {
		@string : Char[];
		@max : Int;
		@pos : Int;

		#~
		Default constructor
		~#
		New() {
			Parent();

			@max := 8;
			@string := Char->New[@max];
			@pos := 0;
		}

		#~
		Copy constructor
		@param string string to be copied
		~#
		New(string : String) {
			Parent();

			@max := 8;
			@string := Char->New[@max];
			@pos := 0;
			
			if(string <> Nil) {
				Append(string->ToCharArray());
			};
		}
		
		#~
		Copy constructor
		@param array array to be copied
		~#		
		New(array : Char[]) {
			Parent();

			if(array->Size() < 8) {
				@max := 8;
			}
			else {
				@max := array->Size();
			};
			
			@string := Char->New[@max];
			@pos := 0;

			Append(array);
		}
		
		#~
		Copy constructor
		@param array array to be copied
		@param offset offset array index offset
		@param max offset max max number of characters to copy
		~#
		New(array : Char[], offset : Int, max : Int) {
			Parent();

			if(array->Size() < 8) {
				@max := 8;
			}
			else {
				@max := array->Size();
			};

			@string := Char->New[@max];
			@pos := 0;

			Append(array, offset, max);
		}
		
		#~
		Copy constructor
		@param array array to be copied
		~#
		New(array : Byte[]) {
			Parent();

			if(array->Size() < 8) {
				@max := 8;
			}
			else {
				@max := array->Size();
			};
			
			@string := Char->New[@max];
			@pos := 0;

			Append(array);
		}

		#~
		Copy constructor
		@param array array to be copied
		@param offset offset array index offset
		@param max max number of characters to copy
		~#
		New(array : Byte[], offset : Int, max : Int) {
			Parent();

			if(array->Size() < 8) {
				@max := 8;
			}
			else {
				@max := array->Size();
			};

			@string := Char->New[@max];
			@pos := 0;

			Append(array, offset, max);
		}

		#~
		Returns a character array representation of the String
		@return character array
		~#
		method : public : native : ToCharArray() ~ Char[] {
			array : Char[] := Char->New[@pos];
			for(i : Int := 0; i < @pos; i += 1;) {
				array[i] := @string[i];
			};

			return array;
		}
		
		#~
		Returns a byte array representation of the String
		@return byte array
		~#
		method : public : native : ToByteArray() ~ Byte[] {
			array : Byte[] := Byte->New[@pos];
			for(i : Int := 0; i < @pos; i += 1;) {
				array[i] := @string[i];
			};

			return array;
		}
		
		#~
		Appends a boolean value
		@param b boolean value
		~#
		method : public : native : Append(b : Bool) ~ Nil {
			if(b) {
				Append("true"->ToCharArray());
			}
			else {
				Append("false"->ToCharArray());
			};
		}

		#~
		Appends a integer value
		@param i integer value
		~#
		method : public : native : Append(i : Int) ~ Nil {
			Append(i->ToString()->ToCharArray());
		}

		#~
		Appends a float value
		@param f float value
		~#
		method : public : native : Append(f : Float) ~ Nil {
			Append(f->ToString()->ToCharArray());
		}

		#~
		Appends a string
		@param str string object
		~#
		method : public : native : Append(str : String) ~ Nil {
			Append(str->ToCharArray());
		}
		
		#~
		Appends a character array
		@param array character array
		~#
		method : public : native : Append(array : Char[]) ~ Nil {
			if(@pos + array->Size() >= @max) {
				# expand string
				@max := (@max + array->Size()) * 2;
				tmp : Char[] := Char->New[@max];
				# copy elements				
				Runtime->Copy(tmp, 0, @string, 0, @string->Size());
				@string := tmp;
			};
			
			max := array->Size();
			for(i : Int := 0; i < max & array[i] <> '\0'; i += 1;) {
				@string[@pos] := array[i];
				@pos += 1;
			};
		}

		#~
		Appends a portion of character array
		@param array array to be copied
		@param offset offset array index offset
		@param max max number of characters to copy
		~#
		method : public : native : Append(array : Char[], offset : Int, max : Int) ~ Nil {
			if(offset < 0) {
				return;
			};
			
			if(@pos + max >= @max) {
				# expand string
				@max := (@max + max) * 2;
				tmp : Char[] := Char->New[@max];
				# copy elements
				Runtime->Copy(tmp, 0, @string, 0, @string->Size());
				@string := tmp;
			};

			end := offset + max;
			for(i : Int := offset; i < end & array[i] <> '\0'; i += 1;) {
				@string[@pos] := array[i];
				@pos += 1;
			};
		}
		
		#~
		Appends a character array
		@param array array to be copied
		~#
		method : public : native : Append(array : Byte[]) ~ Nil {
			if(@pos + array->Size() >= @max) {
				# expand string
				@max := (@max + array->Size()) * 2;
				tmp : Char[] := Char->New[@max];
				# copy elements
				Runtime->Copy(tmp, 0, @string, 0, @string->Size());
				@string := tmp;
			};
			
			max := array->Size();
			for(i : Int := 0; i < max & array[i] <> '\0'; i += 1;) {
				@string[@pos] := array[i];
				@pos += 1;
			};
		}

		#~
		Appends a portion of byte array
		@param array array to be copied
		@param offset offset array index offset
		@param max max number of bytes to copy
		~#
		method : public : native : Append(array : Byte[], offset : Int, max : Int) ~ Nil {
			if(offset < 0) {
				return;
			};
			
			if(@pos + max >= @max) {
				# expand string
				@max := (@max + max) * 2;
				tmp : Char[] := Char->New[@max];
				# copy elements
				Runtime->Copy(tmp, 0, @string, 0, @string->Size());
				@string := tmp;
			};

			end := offset + max;
			for(i : Int := offset; i < end & array[i] <> '\0'; i += 1;) {
				@string[@pos] := array[i];
				@pos += 1;
			};
		}

		#~
		Appends a character
		@param c character to append
		~#
		method : public : native : Append(c : Char) ~ Nil {
			if(@pos >= @max) {
				# expand string
				@max := @max * 2;
				tmp : Char[] := Char->New[@max];
				# copy elements
				Runtime->Copy(tmp, 0, @string, 0, @string->Size());
				@string := tmp;
			};

			@string[@pos] := c;
			@pos += 1;
		}
		
		#~
		Appends a byte
		@param c byte to append
		~#
		method : public : native : Append(c : Byte) ~ Nil {
			if(@pos >= @max) {
				# expand string
				@max := @max * 2;
				tmp : Char[] := Char->New[@max];
				# copy elements
				Runtime->Copy(tmp, 0, @string, 0, @string->Size());
				@string := tmp;
			};

			@string[@pos] := c;
			@pos += 1;
		}
		
		#~
		Searches for the first occurrence of a character
		@param char character to search for
		@return index of first occurrence, -1 otherwise
		~#
		method : public : Find(char : Char) ~ Int {
			return Find(0, char);
		}
		
		#~
		Searches for the first occurrence of a character
		@param offset search offset
		@param char character to search for
		@return index of first occurrence, -1 otherwise
		~#
		method : public : native : Find(offset : Int, char : Char) ~ Int {
			if(offset < @pos & offset > -1) {
				for(i := offset; i < @pos; i += 1;) {
					if(@string[i] = char) {
						return i;
					};
				};
			};

			return -1;
		}
		
		#~
		Searches for the last occurrence of a character
		@param char character to search for
		@return index of last occurrence, -1 otherwise
		~#
		method : public : FindLast(char : Char) ~ Int {
			return FindLast(0, char);
		}
		
		#~
		Searches for the last occurrence of a character
		@param offset search offset
		@param char character to search for
		@return index of last occurrence, -1 otherwise
		~#
		method : public : native : FindLast(offset : Int, char : Char) ~ Int {
			if(offset < @pos & offset > -1) {
				for(i := @pos - 1; i > -1; i -= 1;) {
					if(@string[i] = char) {
						return i;
					};
				};
			};

			return -1;
		}

		#~
		Searches for the first occurrence of a string
		@param find string to search for
		@return index of first occurrence, -1 otherwise
		~#
		method : public : Find(find : String) ~ Int {
			return Find(0, find);
		}

		#~
		Searches for all occurrences of a string
		@param find string to search for
		@return an array of indexes
		~#
		method : public : FindAll(find : String) ~ Int[] {
			buffer_max := 8;
			buffer := Int->New[buffer_max];
			
			count := 0;
			offset := 0;
			do {
				# check
				offset := Find(offset, find);
				# found
				if(offset > -1) {
					count += 1;
					if(count < buffer_max) {
						buffer[count - 1] := offset;
					}
					# copy elements
					else {
						temp := Int->New[buffer_max * 2];
						Runtime->Copy(temp, 0, buffer, 0, buffer_max);
						buffer_max *= 2;
						buffer := temp;
					};
					offset += find->Size();
				};
			}
			while(offset > -1);
			
			results := Int->New[count];
			each(i : results) {
				results[i] := buffer[i];
			};

			return results;
		}

		#~
		Searches for the first occurrence of a string
		@param offset search index offset
		@param find string to search for
		@return index of first occurrence, -1 otherwise
		~#
		method : public : native : Find(offset : Int, find : String) ~ Int {
			size := find->Size();
			if(size > 0 & offset < @pos) {
				found_index := Find(offset, find->Get(0));
				while(found_index > -1) {
					j := found_index;
					match := true;
					i : Int;
					for(i := 0; match & i < find->Size() & j < @pos; i += 1;) {
						if(find->Get(i) <> @string[j]) {
							match := false;
						};
						j += 1;
					};

					if(match & i = find->Size()) {
						return found_index;
					};
					
					found_index := Find(found_index + 1, find->Get(0));
				};

				return -1;
			};

			return -1;
		}
		
		#~
		Replaces all occurrences the search string
		@param find string to search for
		@param replace string to replace with
		@return new string instance
		~#
		method : public : native : ReplaceAll(find : String, replace : String) ~ String {
			last := @self;
			result := last->Replace(find, replace);
			while(result <> last) {
				last := result;
				result := last->Replace(find, replace);
			};
			
			return result;
		}
		
		#~
		Replaces the first occurrence the search string
		@param find string to search for
		@param replace string to replace with
		@return new string instance
		~#
		method : public : native : Replace(find : String, replace : String) ~ String {
			index := Find(find);
			if(index < 0) {
				return @self;
			};
			
			begin := SubString(0, index);
			index += find->Size();
			
			length :=   Size() - index;
			end := SubString(index, length);
			if(end = Nil) {
				return @self;
			};
			
			new_string := String->New(begin);
			new_string->Append(replace);
			new_string->Append(end);
			
			return new_string;
		}
		
		#~
		Deletes the character at the given index
		@param index delete index
		@return true if deleted, false otherwise 
		~#
		method : public : native : Delete(index : Int) ~ Bool {
			if(index < 0 | index >= @pos) {
				return false;
			};
			
			size := @pos - 1;
			tmp : Char[] := Char->New[size];
			Runtime->Copy(tmp, 0, @string, 0, index);
			Runtime->Copy(tmp, index, @string, index + 1, @pos - index - 1);
			
			@string := tmp;
			@pos := size;
			@max := @pos;
			
			return true;
		}

		#~
		Deletes the characters at the given range
		@param start start index
		@param end end index
		@return true if deleted, false otherwise 
		~#
		method : public : native : Delete(start : Int, end : Int) ~ Bool {
			if(start < 0 | start >= @pos | end < 0 | end >= @pos | start >= end) {
				return false;
			};

			length := end - start + 1;
			size := @pos - length;
			tmp : Char[] := Char->New[size];
			Runtime->Copy(tmp, 0, @string, 0, start);
			Runtime->Copy(tmp, start, @string, end + 1, size - start);

			@string := tmp;
			@pos := size;
			@max := @pos;
			
			return true;
		}

		#~
		Insert inserts a string
		@param index insert offset
		@param s string to insert
		@return true if inserted, false otherwise 
		~#
		method : public : native : Insert(index : Int, s : String) ~ Bool {
			if(index < 0 | index > @pos) {
				return false;
			};
			
			size := @pos + s->Size();
			tmp : Char[] := Char->New[size];
			Runtime->Copy(tmp, 0, @string, 0, index);

			buf := s->ToCharArray();
			Runtime->Copy(tmp, index, buf, 0, buf->Size());

			Runtime->Copy(tmp, index + buf->Size(), @string, index, @pos - index);

			@string := tmp;
			@pos := size;
			@max := @pos;
			
			return true;

		}

		#~
		Returns rather the string is empty
		@return true if empty, false otherwise 
		~#
		method : public : native : IsEmpty() ~ Bool {
			return @pos = 0 ? true : false; 			
		}

		#~
		Return the size of the string
		@return size of the string
		~#
		method : public : native : Size() ~ Int {
			return @pos;			
		}
  
		#~
		Returns character at the given index
		@param index index offset
		@return character at index
		~#
		method : public : native : Get(index : Int) ~ Char {
			if(index < @pos) {
				return @string[index];
			};

			return '\0';
		}

		#~
		Pops the last character from the string reducing the
		size by 1
		@return last character of the string
		~#
		method : public : native : Pop() ~ Char {
			if(@pos > 0) {
				@pos -= 1;
				c := @string[@pos];
				@string[@pos] := '\0';
				return c;
			};

			return '\0';
		}
		
		#~
		Parses the string into an integer
		@return integer value
		~#
		method : public : native : ToInt() ~ Int {
			if(@pos > 1 & @string[0] = '0' & @string[1] = 'x') {
				end := 1;			
				mag : Int := 1;
				val : Int := 0;
				for(i : Int := @pos - 1; i > end; i := i - 1;) {
					pos_val : Int := @string[i];
					if(pos_val >= '0' & pos_val <= '9') {
						pos_val := pos_val - 48;
					}
					else if(pos_val >= 'A' & pos_val <= 'F') {
						pos_val := pos_val - 55;
					}
					else if(pos_val >= 'a' & pos_val <= 'f') {
						pos_val := pos_val - 87;
					}
					else {
						return 0;
					};
					
					if(mag = 1) {
						val := pos_val;
					}
					else {
						val := val + pos_val * mag;	
					};
					# update
					mag := mag * 16;
				};
				
				return val;
			}
			else if(@string->Size() > 0) {
				is_neg : Bool := false;
				if(@string[0] = '-') {
					is_neg := true;
				};

				end : Int;
				if(is_neg) {
					end := 0;
				}
				else {
					end := -1;
				};

				val : Int := 0;
				mag : Int := 1;
				for(i : Int := @pos - 1; i > end; i := i - 1;) {
					pos_val : Int := @string[i] - 48;
					if(pos_val < 0 | pos_val > 9) {
						return 0;
					};

					if(mag = 1) {
						val := pos_val;
					}
					else {
						val := val + pos_val * mag;	
					};
					# update
					mag := mag * 10;
				};

				if(is_neg) {
					return val * -1;
				}
				else {
					return val;
				};
			};

			return 0;
		}

		#~
		Parses the string into a float
		@return float value
		~#
		method : public : native : ToFloat() ~ Float {
			if(@string->Size() > 0) {
				val : Float := 0;
				is_neg : Bool := false;
				if(@string[0] = '-') {
					is_neg := true;
				};

				end : Int;
				if(is_neg) {
					end := 0.0;
				}
				else {
					end := -1.0;
				};

				# find decimal point
				dec_index : Int := -1;
				i : Int := 0;
				while(dec_index = -1 & i < @pos) {
					if(@string[i] = '.') {
						dec_index := i;
					};
					i += 1;
				};

				# calculate decimal number 
				if(dec_index <> -1) {
					mag : Float := .1;
					dec_index := dec_index + 1;
					
					for(j : Int := dec_index; j < @pos; j := j + 1;) {
						pos_val : Int := @string[j] - 48;
						if(pos_val < 0 | pos_val > 9) {
							return 0;
						};

						if(mag = 1) {
							val := pos_val;
						}
						else {
							val := val + pos_val * mag;	
						};
						# update
						mag := mag * .1;
					};
					
					dec_index := dec_index - 1;
					mag := 1.0;
					for(j : Int := dec_index - 1; j > end; j := j - 1;) {
						pos_val : Int := @string[j] - 48;
						if(pos_val < 0 | pos_val > 9) {
							return 0;
						};

						if(mag = 1) {
							val := val + pos_val;
						}
						else {
							val := val + pos_val * mag;	
						};
						# update
						mag := mag * 10.0;
					};
				}
				# calculate non-decimal number 
				else {
					mag : Int := 1;
					for(j : Int := @pos - 1; j > end; j := j - 1;) {
						pos_val : Int := @string[j] - 48;
						if(pos_val < 0 | pos_val > 9) {
							return 0.0;
						};

						if(mag = 1) {
							val := pos_val;
						}
						else {
							val := val + pos_val * mag;	
						};
						# update
						mag := mag * 10.0;
					};
				};

				if(is_neg) {
					return val * -1.0;
				}
				else {
					return val;
				};
			};

			return 0.0;
		}

		#~
		Checks if the string starts with the given character
		@param c character to compare
		@return true if starts with character, false otherwise
		~#
		method : public : native : StartsWith(c : Char) ~ Bool {
			sc : Char := Get(0);
			return sc <> '\0' & c = sc;
		}
		
		#~
		Checks if the string ends with the given character
		@param c character to compare
		@return true if ends with character, false otherwise
		~#
		method : public : native : EndsWith(c : Char) ~ Bool {
			if(@pos > 0) {
				sc := @string[@pos - 1];
				return sc <> '\0' & c = sc;
			};
			
			return false;
		}

		#~
		Checks if the string starts with the given string
		@return true if starts with string, false otherwise
		~#
		method : public : native : StartsWith(s : String) ~ Bool {
			if(s->Size() <= @pos) {
				for(i := 0; i < s->Size(); i += 1;) {
					if(s->Get(i) <> @string[i]) {
						return false;
					};
				};

				return true;
			};

			return false;
		}

		#~
		Checks if the string ends with the given character
		@return true if ends with character, false otherwise
		~#
		method : public : native : EndsWith(s : String) ~ Bool {
			if(s->Size() <= @pos) {
				i := s->Size() - 1;
				j := @pos - 1;
				while(i > -1) {
					if(s->Get(i) <> @string[j]) {
						return false;
					};
					i := i - 1;
					j := j - 1;
				};

				return true;
			};

			return false;
		}
		
		#~
		Reverses a string
		@return reversed string 
		~#
		method : public : native : Reverse() ~ String {
			tmp : Char[] := Char->New[@max];
			i := 0; j := @pos - 1;
			while(j > -1) {
				tmp[i] := @string[j];
				j -= 1;	i += 1;
			};
			
			return String->New(tmp);
		}
		
		#~
		Removes all leading and ending white space
		@return trimmed string
		~#
		method : public : native : Trim() ~ String {
			if(@pos = 0) {
				return "";
			};

			start := 0;
			c := @string[start];
			while(start < @pos & (c = ' ' | c = '\t' | c = '\r' | c = '\n')) {
				start += 1;
				c := @string[start];
			};

			end := @pos;
			do {
				end -= 1;
			} 
			while(end > -1 & (@string[end] = ' ' | @string[end] = '\t' | @string[end] = '\r' | @string[end] = '\n'));

			if(end < start) {
				return "";
			};
	
			return String->New(@string, start, end - start + 1);
		}
		
		#~
		Splits a string based upon delimiter
		@param delim splitting delimiter
		@return array of split sub strings 
		~#
		method : public : native : Split(delim : String) ~ String[] {
			if(delim->Size() = 0 | @pos = 0) {
				return Nil;
			};
			
			# first-pass count tokens
			count := 0;
			start_index := 0;
			found_index := -1;
			delim_index := 0;
			
			for(i : Int := 0; i < @pos; i += 1;) {
				if(found_index = -1 & delim->Get(0) = @string[i]) {
					found_index := i;
				};
				
				if(found_index > -1) {
					if(delim_index < delim->Size() & delim->Get(delim_index) = @string[i]) {
						delim_index += 1;
					}
					else if(delim_index = delim->Size()) {
						count += 1;
						start_index := found_index + delim->Size();
						found_index := -1;
						delim_index := 0;
					}
					else {
						found_index := -1;
						delim_index := 0;
					};
				};
			};
			
			if(start_index <> 0) {
				count += 1;
				SubString(start_index, @pos - start_index);
			};
			
			# second-pass parse tokens
			parsed_strings : String[] := String->New[count];
			count := 0;
			start_index := 0;
			found_index := -1;
			delim_index := 0;
			
			for(i : Int := 0; i < @pos; i += 1;) {
				if(found_index = -1 & delim->Get(0) = @string[i]) {
					found_index := i;
				};
				
				if(found_index > -1) {
					if(delim_index < delim->Size() & delim->Get(delim_index) = @string[i]) {
						delim_index += 1;
					}
					else if(delim_index = delim->Size()) {
						parsed_strings[count] := SubString(start_index, found_index - start_index);
						count += 1;
						
						start_index := found_index + delim->Size();
						found_index := -1;
						delim_index := 0;
					}
					else {
						found_index := -1;
						delim_index := 0;
					};
				};
			};
			
			if(start_index <> 0) {
				parsed_strings[count] := SubString(start_index, @pos - start_index);
				count += 1;
			};
			
			return parsed_strings;
		}
		
		#~
		Transforms a to upper case
		@return upper case string
		~#
		method : public : native : ToUpper() ~ String {
			array : Char[] := Char->New[@pos];
			for(i : Int := 0; i < @pos; i += 1;) {
				c := @string[i];
				if(c > 96 & c < 123) {
					c := c - 32;
				};
				array[i] := c;
			};
			
			return String->New(array);
		}
		
		#~
		Transforms a to lower case
		@return lower case string
		~#
		method : public : native : ToLower() ~ String {
			array : Char[] := Char->New[@pos];
			for(i : Int := 0; i < @pos; i += 1;) {
				c := @string[i];
				if(c > 64 & c < 91) {
					c := c + 32;
				};
				array[i] := c;
			};
			
			return String->New(array);
		}

		#~
		Creates a sub-string
		@param length max length of sub-string
		@return sub-string
		~#
		method : public : SubString(length : Int) ~ String {
			return SubString(0, length);
		}

		#~
		Creates a sub-string
		@param offset index offset
		@param length max length of sub-string
		@return sub-string
		~#
		method : public : native : SubString(offset : Int, length : Int) ~ String {
			if(offset < 0 | offset > @pos) {
				return Nil;
			};

			end : Int := length + offset;
			if(end < 0 | end > @pos) {
				return Nil;
			};

			array : Char[] := Char->New[length];
			for(i : Int := 0; i < length; i += 1;) {
				array[i] := @string[i + offset];
			};

			return String->New(array);
		}
	
		#~
		Compares two strings
		@param rhs string to compare
		@return true if strings are equal, false otherwise
		~#
		method : public : Equals(rhs : String) ~ Bool {
			return Compare(rhs->As(System.Compare)) = 0;
		}

		#~
		Returns a unique hash ID for a given string sequence
		@return hash ID
		~#
		method : public : native : HashID() ~ Int {
			hash := 0;
			for(i := 0; i < @pos; i += 1;) {
				c := @string[i];
				hash += c * 101;
			};
			
			return hash;
		}

		#~
		Compares two objects
		@param rhs compare object
		@return true if objects are equal, false otherwise
		~#
		method : public : Compare(rhs : System.Compare) ~ Int {
			# check class type
			if(GetClassID() = rhs->GetClassID()) {
				right_string : String := rhs->As(String);
				
				# check each character
				for(i : Int := 0; i < @pos; i += 1;) {
					left : Char := @string[i];
					right : Char := right_string->Get(i);
					if(left > right) {
						return 1;
					}
					else if(left < right) {
						return -1;
					};
				};
				
				# check length
				if(@pos > right_string->Size()) {
					return 1;
				};
				
				if(@pos < right_string->Size()) {
					return -1;
				};
				
				# equal
				return 0;
			};
			
			return -1;
		}

		#~
		Print a string
		~#
		method : public : native : Print() ~ Nil {
			@string->Print();
		}

		#~
		Print a string with a newline
		~#
		method : public : native : PrintLine() ~ Nil {
			@string->PrintLine();
		}

		#~
		Print an error string
		~#
		method : public : native : Error() ~ Nil {
			@string->Error();
		}

		#~
		Print an error string with a newline
		~#
		method : public : native : ErrorLine() ~ Nil {
			@string->ErrorLine();
		}
	}
	
	#~
	Provides access to runtime system
	~#	
	class Runtime {
		#~
		Causes the executing program to halt
		@param code exit code
		~#
		function : Exit(code : Int) ~ Nil {
			EXIT;
		}
		
		#~
		Returns an OS platform string
		@return OS platform string
		~#
		function : GetPlatform() ~ String {
			PLTFRM;
		}
		
		#~
		Fetches a runtime property 
		@param key property key
		@return runtime property 
		~#
		function : GetProperty(key : String) ~ String {
			GET_SYS_PROP;
		}
		
		#~
		Sets a runtime property 
		@param key property key
		@param key property value
		~#
		function : SetProperty(key : String, value : String) ~ Nil {
			SET_SYS_PROP;
		}
		
		#~
		Returns the current time
		@return current time
		~#
		function : GetTime() ~ Time.Date {
			return Time.Date->New();
		}
		
		#~
		Copies data between two byte arrays
		@param dest destination array
		@param dest_offset destination array copy offset
		@param src source array
		@param src_offset source array copy offset
		@param len number of bytes to copy
		@return true if successful, false otherwise
		~#
		function : Copy(dest : Byte[], dest_offset : Int, src : Byte[], src_offset : Int, len : Int) ~ Bool {
			CPY_BYTE_ARY;
		}
		
		#~
		Copies data between two character arrays
		@param dest destination array
		@param dest_offset destination array copy offset
		@param src source array
		@param src_offset source array copy offset
		@param len number of characters to copy
		@return true if successful, false otherwise
		~#
		function : Copy(dest : Char[], dest_offset : Int, src : Char[], src_offset : Int, len : Int) ~ Bool {
			CPY_CHAR_ARY;
		}
		
		#~
		Copies data between two integer arrays
		@param dest destination array
		@param dest_offset destination array copy offset
		@param src source array
		@param src_offset source array copy offset
		@param len number of values to copy
		@return true if successful, false otherwise
		~#
		function : Copy(dest : Int[], dest_offset : Int, src : Int[], src_offset : Int, len : Int) ~ Bool {
			CPY_INT_ARY;
		}
		
		#~
		Copies data between two Base arrays
		@param dest destination array
		@param dest_offset destination array copy offset
		@param src source array
		@param src_offset source array copy offset
		@param len number of values to copy
		@return true if successful, false otherwise
		~#
		function : Copy(dest : Base[], dest_offset : Int, src : Base[], src_offset : Int, len : Int) ~ Bool {
			CPY_INT_ARY;
		}
		
		#~
		Copies data between two Compare arrays
		@param dest destination array
		@param dest_offset destination array copy offset
		@param src source array
		@param src_offset source array copy offset
		@param len number of values to copy
		@return true if successful, false otherwise
		~#
		function : Copy(dest : Compare[], dest_offset : Int, src : Compare[], src_offset : Int, len : Int) ~ Bool {
			CPY_INT_ARY;
		}
		
		#~
		Copies data between two float arrays
		@param dest destination array
		@param dest_offset destination array copy offset
		@param src source array
		@param src_offset source array copy offset
		@param len number of values to copy
		@return true if successful, false otherwise
		~#
		function : Copy(dest : Float[], dest_offset : Int, src : Float[], src_offset : Int, len : Int) ~ Bool {
			CPY_FLOAT_ARY;
		}
	}
}

#~
System API Bundle
~#
bundle System.API {
	#~
	Class allow programmers to load native shared 
	libraries that can be called by Objeck classes. 
	Programmers can call native C functions within these 
	libraries.
	~#	
	class DllProxy {
		@name : String;
		@ptr : Int;
		
		#~
		Path to the shared library. The path should not include the 
		extension name (i.e. .dll, .so, etc.) for platform portability
		@name shared library path
		~#
		New(name : String) {
			Parent();

			@name := name;
			DLL_LOAD;
		}
		
		#~
		Returns rather the shared library has been successfully loaded
		@return returns true if the the library has been successfully loaded, false otherwise
		~#
		method : public : IsLoaded() ~ Bool {
			return @ptr <> 0;
		}
		
		#~
		Unloads the shared library
		~#
		method : public : Unload() ~ Nil {
			DLL_UNLOAD;
		}
		
		#~
		Calls a native C function.
		@param name of the native C function
		@param args argument to the native function
		~#
		method : public : CallFunction(name : String, args : Base[]) ~ Nil {
			DLL_FUNC_CALL;
		}
	}
}

#~
Provides time
~#	
bundle System.Time {	
	#~
	Provides date and time functionality 
	~#	
	class Date {
		@day : Int;
		@month : Int;
		@year : Int;
		@hours : Int;
		@mins : Int;
		@secs : Int;
		@is_savings : Bool;
		@week_day : Int;
		@is_gmt : Bool;
		
		#~
		Default constructor 
		~#
		New() {
			Parent();
			SYS_TIME;
		}

		#~
		Constructor 
		@param gmt true of time is in GMT, false for system time zone
		~#
		New(gmt : Bool) {
			Parent();
			if(gmt) {
				GMT_TIME;
			}
			else {
				SYS_TIME;
			};
		}
		
		#~
		Constructor 
		@param day day of month
		@param month day of year
		@param year year
		@param gmt true of time is in GMT, false for system time zone
		~#
		New(day : Int, month : Int, year : Int, gmt : Bool) {
			Parent();
			DATE_TIME_SET_1;
		}
		
		#~
		Constructor 
		@param day day of month
		@param month day of year
		@param year year
		@hours hours
		@mins mins
		@secs secs
		@param gmt true of time is in GMT, false for system time zone
		~#
		New(day : Int, month : Int, year : Int, hours : Int, mins : Int, secs : Int, gmt : Bool) {
			Parent();
			DATE_TIME_SET_2;
		}

#~ TODO
		New(date : String, format : String) {
			Parent();
			DATE_TIME_SET_3;
		}
~#

		#~
		Returns the day
		@return day
		~#
		method : public : GetDay() ~ Int {
			return @day;
		}

		#~
		Returns name of the day
		@return name of the day
		~#
		method : public : GetDayName() ~ String {
			days_of_week := ["Sunday", "Monday", "Tuesday", "Wednesday","Thursday","Friday","Saturday"];
			if(@week_day > -1 & @week_day < days_of_week->Size()) {
				return days_of_week[@week_day];
			};

			return "";
		}
		
		#~
		Returns the month 
		@return month
		~#
		method : public : GetMonth() ~ Int {
			return @month;
		}
		
		#~
		Returns name of the month
		@return name of the month
		~#
		method : public : GetMonthName() ~ String {
			days_of_month := ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
			if(@month > -1 & @month - 1 < days_of_month->Size()) {
				return days_of_month[@month - 1];
			};

			return "";
		}

		#~
		Returns the year 
		@return year
		~#
		method : public : GetYear() ~ Int {
			return @year;
		}
		
		#~
		Returns the hours 
		@return hours
		~#
		method : public : GetHours() ~ Int {
			return @hours;
		}
		
		#~
		Returns the minutes  
		@return minutes
		~#
		method : public : GetMinutes() ~ Int {
			return @mins;
		}
		
		#~
		Returns the seconds  
		@return seconds
		~#
		method : public : GetSeconds() ~ Int {
			return @secs;
		}

		#~
		Add days to the date
		@param days to add
		~#
		method : public : AddDays(value : Int) ~ Nil {
			DATE_TIME_ADD_DAYS;
		}

		#~
		Add hours to the date
		@param hours to add
		~#
		method : public : AddHours(value : Int) ~ Nil {
			DATE_TIME_ADD_HOURS;
		}
   
		#~
		Add minutes to the date
		@param minutes to add
		~#
		method : public : AddMinutes(value : Int) ~ Nil {
			DATE_TIME_ADD_MINS;
		}

		#~
		Add seconds to the date
		@param seconds to add
		~#
		method : public : AddSeconds(value : Int) ~ Nil {
			DATE_TIME_ADD_SECS;
		}

		#~
		Checks rather the date is in daylight savings time
		@param true if daylight savings time, false otherwise
		~#
		method : public : IsSavingsTime() ~ Bool {
			return @is_savings;
		}

		#~
		Creates a string representation of the date
		@return string representation of the date
		~#
		method : public : ToString() ~ String {
			out := String->New();

			out->Append(GetDayName());
			out->Append(", ");
			out->Append(GetMonthName());
			out->Append(" ");
			out->Append(@day);
			out->Append(", ");
			out->Append(@year);
			out->Append(", ");
			out->Append(@hours);
			out->Append(":");
			if(@mins < 10) {
				out->Append('0');
			};
			out->Append(@mins);
			out->Append(":");
			out->Append(@secs);

			return out;
		}
	}
	
	#~
	Provides elapsed time 
	~#	
	class Timer {
		@elapsed : Int;
		
		New() {
			Parent();
		}
		
		#~
		Starts the timer
		~#
		method : public : Start() ~ Nil {
			TIMER_START;
		}
		
		#~
		Ends the timer
		~#
		method : public : End() ~ Nil {
			TIMER_END;
		}
		
		#~
		Gets the elapsed time
		~#
		method : public : GetElapsedTime() ~ Int {
			return @elapsed;
		}
	}
}

#~
Provides concurrency
~#
bundle System.Concurrency {	
	#~
	Abstracts native system thread execution 
	~#	
	class Thread {
		@id : Int;
		@name : String;
		@param : System.Base;
		
		#~
		Name of the thread
		@param name name of the thread
		~#
		New(name : String) {
			Parent();
			@name := name;
		}
		
		#~
		Called to execute a new thread 
		@param param parameter to be passed into the newly executing thread 
		~#
		method : public : Execute(param : System.Base) ~ Nil {
			@param := param;
			ASYNC_MTHD_CALL;
		}

		#~
		Sleeps the executing thread
		@param t sleep time in milliseconds
		~#
		function : Sleep(t : Int) ~ Nil {
			THREAD_SLEEP;
		}
		
		#~
		Joins the executing thread with the caller
		~#
		method : public : Join() ~ Nil {
			THREAD_JOIN;
		}
		
		#~
		Returns the thread's name
		@param thread's name
		~#
		method : public : GetName() ~ String {
			return @name;
		}
		
		#~
		Returns a unique execution ID
		@param execution ID
		~#
		method : public : GetExecuteID() ~ Int {
			return @id;
		}
		
		#~
		Prototype for the thread to be executed
		@param param parameter to be passed into the thread 
		~#
		method : virtual : public : Run(param : System.Base) ~ Nil;
	}	
	
	#~
	Thread mutex used to protect critical sections 
	~#	
	class ThreadMutex {
		@name : String;
		# hack to hold a mutex struct.  Largest struct 
		# is 64-bytes for x64 POSIX
		@m0 : Int;
		@m1 : Int;
		@m2 : Int;
		@m3 : Int;
		@m4 : Int;
		@m5 : Int;
		@m6 : Int;
		@m7 : Int;
		
		#~
		Name of the mutex
		@param name name of the mutex
		~#
		New(name : String) {
			Parent();
			@name := name;
			THREAD_MUTEX;
		}
		
		#~
		Name of the mutex
		@param name name of the mutex
		~#
		method : public : GetName() ~ String {
			return @name;
		}
	}
}

#~
Provides I/O functions
~#
bundle System.IO {
	#~
	An abstract input stream
	~#
	interface InputStream {
		#~
		Reads a byte
		@return byte read
		~#
		method : virtual : public : ReadByte() ~ Byte;
		
		#~
		Reads bytes into a byte buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : virtual : public : ReadBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int;
		
		#~
		Reads bytes into a character buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : virtual : public : ReadBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int;
		
		#~
		Reads a string until a newline or character return is detected 
		@return character string
		~#
		method : virtual : public : ReadString() ~ System.String;
	}
	
	#~
	An abstract output stream
	~#
	interface OutputStream {
		#~
		Writes a byte
		@return ture if byte was written, false otherwise
		~#
		method : virtual : public : WriteByte(b : Int) ~ Bool;
		
		#~
		Writes bytes from a character buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : virtual : public : WriteBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int;
		
		#~
		Writes characters from a character buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : virtual : public : WriteBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int;
		
		#~
		Writes a character string
		@param string to be written
		~#
		method : virtual : public : WriteString(str : System.String) ~ Nil;
		
		#~
		Flushes the output buffer
		~#
		method : virtual : public : Flush() ~ Nil;
	}
	
 	#~
	Provides I/O console access
	~#
	class Console {
		#~
		Reads a string from STDIN
		@return string read
		~#
		function : ReadString() ~ System.String {
			console := IO.ConsoleIO->Instance();
			return console->ReadString();
		}

		#~
		Write a byte buffer to STDOUT
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return true if successful, false otherwise
		~#
		function : public : WriteBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Bool {
			STD_OUT_BYTE_ARY_LEN;	
		}

		#~
		Write a character buffer to STDOUT
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return true if successful, false otherwise
		~#
		function : public : WriteBuffer(offset : Int, num : Int, buffer : Char[]) ~ Bool {
			STD_OUT_CHAR_ARY_LEN;
		}

		#~
		Write a byte buffer to STDERR
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return true if successful, false otherwise
		~#
		function : public : WriteErrorBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Bool {
			STD_ERR_BYTE_ARY;	
		}

		#~
		Write a character buffer to STDERR
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return true if successful, false otherwise
		~#
		function : public : WriteErrorBuffer(offset : Int, num : Int, buffer : Char[]) ~ Bool {
			STD_ERR_BYTE_ARY;
		}
		
		#~
		Writes a value
		@param b value
		@return I/O console instance
		~#
		function : Print(b : Bool) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(b);
		}
		
		#~
		Writes a value
		@param b value
		@return I/O console instance
		~#
		function : PrintLine(b : Bool) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(b);
		}
	
		#~
		Writes a value
		@param b value
		@return I/O console instance
		~#
		function : Print(b : Byte) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(b);
		}
	
		#~
		Writes a value
		@param b value
		@return I/O console instance
		~#
		function : PrintLine(b : Byte) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(b);
		}
		
		#~
		Writes a value
		@param c value
		@return I/O console instance
		~#
		function : Print(c : Char) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(c);
		}
	
		#~
		Writes a value
		@param c value
		@return I/O console instance
		~#
		function : PrintLine(c : Char) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(c);
		}
	
		#~
		Writes a value
		@param i value
		@return I/O console instance
		~#
		function : Print(i : Int) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(i);
		}
	
		#~
		Writes a value
		@param i value
		@return I/O console instance
		~#
		function : PrintLine(i : Int) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(i);
		}
		
		#~
		Writes a value
		@param f value
		@return I/O console instance
		~#
		function : Print(f : Float) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(f);
		}
	
		#~
		Writes a value
		@param f value
		@return I/O console instance
		~#
		function : PrintLine(f : Float) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(f);
		}
	
		#~
		Writes a value
		@param cc value
		@return I/O console instance
		~#
		function : Print(cc : Char[]) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(cc);
		}
	
		#~
		Writes a value
		@param cc value
		@return I/O console instance
		~#
		function : PrintLine(cc : Char[]) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(cc);
		}
		
		#~
		Writes a value
		@param s value
		@return I/O console instance
		~#
		function : Print(s : System.String) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(s);
		}
	
		#~
		Writes a value
		@param s value
		@return I/O console instance
		~#
		function : PrintLine(s : System.String) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(s);
		}
	
		#~
		Prints a character return
		@return I/O console instance
		~#
		function : PrintLine() ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine();
		}

		#~
		Writes an error value
		@param b value
		@return I/O console instance
		~#
		function : Error(b : Bool) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Error(b);
		}
		
		#~
		Writes an error value
		@param b value
		@return I/O console instance
		~#
		function : ErrorLine(b : Bool) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine(b);
		}
	
		#~
		Writes an error value
		@param b value
		@return I/O console instance
		~#
		function : Error(b : Byte) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Error(b);
		}
	
		#~
		Writes an error value
		@param b value
		@return I/O console instance
		~#
		function : ErrorLine(b : Byte) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine(b);
		}
		
		#~
		Writes an error value
		@param c value
		@return I/O console instance
		~#
		function : Error(c : Char) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Error(c);
		}
	
		#~
		Writes an error value
		@param c value
		@return I/O console instance
		~#
		function : ErrorLine(c : Char) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine(c);
		}
	
		#~
		Writes an error value
		@param i value
		@return I/O console instance
		~#
		function : Error(i : Int) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Error(i);
		}
	
		#~
		Writes an error value
		@param i value
		@return I/O console instance
		~#
		function : ErrorLine(i : Int) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine(i);
		}
		
		#~
		Writes an error value
		@param f value
		@return I/O console instance
		~#
		function : Error(f : Float) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Error(f);
		}
	
		#~
		Writes an error value
		@param f value
		@return I/O console instance
		~#
		function : ErrorLine(f : Float) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine(f);
		}
	
		#~
		Writes an error value
		@param cc value
		@return I/O console instance
		~#
		function : Error(cc : Char[]) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Error(cc);
		}
	
		#~
		Writes an error value
		@param cc value
		@return I/O console instance
		~#
		function : ErrorLine(cc : Char[]) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine(cc);
		}
		
		#~
		Writes an error value
		@param s value
		@return I/O console instance
		~#
		function : Error(s : System.String) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Error(s);
		}
	
		#~
		Writes an error value
		@param s value
		@return I/O console instance
		~#
		function : ErrorLine(s : System.String) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine(s);
		}
	
		#~
		Writes an error character return
		@return I/O console instance
		~#
		function : ErrorLine() ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine();
		}
	}
 	
 	#~
	Provides support for the Console class
	~#
 	class ConsoleIO {
		@console : static : ConsoleIO;

		New : private () {
			Parent();
		}

		function : Instance() ~ ConsoleIO {
			if(@console <> Nil) {
				@console := ConsoleIO->New();
			};

			return @console;
		}

		method : public : ReadString() ~ System.String {
			buffer : Char[] := Char->New[1024];
			ReadString(buffer);
			return System.String->New(buffer);
		}
		
		method : public : Print(b : Bool) ~ ConsoleIO {
			b->Print();
			return @console;
		}
		
		method : public : PrintLine(b : Bool) ~ ConsoleIO {
			b->PrintLine();
			return @console;
		}

		method : ReadString(buffer : Char[]) ~ Nil {
			STD_IN_STRING;
		}
		
		method : public : Print(b : Byte) ~ ConsoleIO {
			b->Print();
			return @console;
		}

		method : public : PrintLine(b : Byte) ~ ConsoleIO {
			b->PrintLine();
			return @console;
		}
		
		method : public : Print(c : Char) ~ ConsoleIO {
			c->Print();
			return @console;
		}

		method : public : PrintLine(c : Char) ~ ConsoleIO {
			c->PrintLine();
			return @console;
		}

		method : public : Print(i : Int) ~ ConsoleIO {
			i->Print();
			return @console;
		}

		method : public : PrintLine(i : Int) ~ ConsoleIO {
			i->PrintLine();
			return @console;
		}
		
		method : public : Print(f : Float) ~ ConsoleIO {
			f->Print();
			return @console;
		}

		method : public : PrintLine(f : Float) ~ ConsoleIO {
			f->PrintLine();
			return @console;
		}

		method : public : Print(cc : Char[]) ~ ConsoleIO {
			cc->Print();
			return @console;
		}

		method : public : PrintLine(cc : Char[]) ~ ConsoleIO {
			cc->PrintLine();
			return @console;
		}
		
		method : public : Print(s : System.String) ~ ConsoleIO {
			s->Print();
			return @console;
		}

		method : public : PrintLine(s : System.String) ~ ConsoleIO {
			s->PrintLine();
			return @console;
		}

		method : public : PrintLine() ~ ConsoleIO {
			"\r\n"->Print();
			return @console;
		}
		
		method : public : Error(b : Bool) ~ ConsoleIO {
			b->Error();
			return @console;
		}
		
		method : public : ErrorLine(b : Bool) ~ ConsoleIO {
			b->ErrorLine();
			return @console;
		}

		method : public : Error(b : Byte) ~ ConsoleIO {
			b->Error();
			return @console;
		}

		method : public : ErrorLine(b : Byte) ~ ConsoleIO {
			b->ErrorLine();
			return @console;
		}
		
		method : public : Error(c : Char) ~ ConsoleIO {
			c->Error();
			return @console;
		}

		method : public : ErrorLine(c : Char) ~ ConsoleIO {
			c->ErrorLine();
			return @console;
		}

		method : public : Error(i : Int) ~ ConsoleIO {
			i->Error();
			return @console;
		}

		method : public : ErrorLine(i : Int) ~ ConsoleIO {
			i->ErrorLine();
			return @console;
		}
		
		method : public : Error(f : Float) ~ ConsoleIO {
			f->Error();
			return @console;
		}

		method : public : ErrorLine(f : Float) ~ ConsoleIO {
			f->ErrorLine();
			return @console;
		}

		method : public : Error(cc : Char[]) ~ ConsoleIO {
			cc->Error();
			return @console;
		}

		method : public : ErrorLine(cc : Char[]) ~ ConsoleIO {
			cc->ErrorLine();
			return @console;
		}
		
		method : public : Error(s : System.String) ~ ConsoleIO {
			s->Error();
			return @console;
		}

		method : public : ErrorLine(s : System.String) ~ ConsoleIO {
			s->ErrorLine();
			return @console;
		}

		method : public : ErrorLine() ~ ConsoleIO {
			'\n'->ErrorLine();
			return @console;
		}
	}
	
	#~
	Used to serialize objects
	~#
	class Serializer  {
		@buffer : Byte[];
		@pos : Int;

		
		New() {
			Parent();
			@buffer := Byte->New[16];
			@pos := 0;
		}

		#~
		Serializes a value
		@param b value to serialize
		~#
		method : public : Write(b : Bool) ~ Nil {
			SERL_INT;
		}

		#~
		Serializes a value
		@param c value to serialize
		~#
		method : public : Write(c : Char) ~ Nil {
			SERL_CHAR;
		}
		
		#~
		Serializes a value
		@param i value to serialize
		~#
		method : public : Write(i : Int) ~ Nil {
			SERL_INT;
		}
		
		#~
		Serializes a value
		@param f value to serialize
		~#
		method : public : Write(f : Float) ~ Nil {
			SERL_FLOAT;
		}
		
		#~
		Serializes a base object
		@param o value to serialize
		~#
		method : public : Write(o : Base) ~ Nil {
			SERL_OBJ_INST;
		}

		#~
		Serializes a base object
		@param o value to serialize
		~#
		method : public : Write(b : Bool[]) ~ Nil {
			SERL_INT_ARY;
		}

		#~
		Serializes a value
		@param b value to serialize
		~#
		method : public : Write(b : Byte[]) ~ Nil {
			SERL_BYTE_ARY;
		}

		#~
		Serializes an array of values
		@param c value to serialize
		~#
		method : public : Write(c : Char[]) ~ Nil {
			SERL_CHAR_ARY;
		}

		#~
		Serializes an array of values
		@param i value to serialize
		~#
		method : public : Write(i : Int[]) ~ Nil {
			SERL_INT_ARY;
		}
		
		#~
		Serializes an array of values
		@param f value to serialize
		~#
		method : public : Write(f : Float[]) ~ Nil {
			SERL_FLOAT_ARY;
		}
		
		#~
		Create a byte stream of the objects that 
		have been serialized
		@return f byte stream of the objects that have been serialized
		~#
		method : public : Serialize() ~ Byte[] {
			temp := Byte->New[@pos];
			for(i := 0; i < @pos; i += 1;) {
				temp[i] := @buffer[i];
			};		

			return temp;
		}
	}
	
	#~
	Used to deserialize objects
	~#
	class Deserializer  {
		@buffer : Byte[];
		@pos : Int;
		
		#~
		Default constructor
		@param buffer input byte buffer to read from
		~#
		New(buffer : Byte[]) {
			Parent();
			@buffer := buffer;
			@pos := 0;
		}

		#~
		Reads a value
		@return value read
		~#
		method : public : ReadBool() ~ Bool {
			DESERL_INT;
		}

		#~
		Reads a value
		@return value read
		~#
		method : public : ReadChar() ~ Char {
			DESERL_CHAR;
		}

		#~
		Reads a value
		@return value read
		~#		
		method : public : ReadInt() ~ Int {
			DESERL_INT;
		}

		#~
		Reads a value
		@return value read
		~#		
		method : public : ReadFloat() ~ Float {
			DESERL_FLOAT;
		}
		
		#~
		Reads an object
		@return value read
		~#
		method : public : ReadObject() ~ Base {
			DESERL_OBJ_INST;
		}

		#~
		Reads an array of values
		@return array of values
		~#
		method : public : ReadBoolArray() ~ Bool[] {
			DESERL_INT_ARY;
		}

		#~
		Reads an array of values
		@return array of values
		~#
		method : public : ReadByteArray() ~ Byte[] {
			DESERL_BYTE_ARY;
		}

		#~
		Reads an array of values
		@return array of values
		~#
		method : public : ReadCharArray() ~ Char[] {
			DESERL_CHAR_ARY;
		}

		#~
		Reads an array of values
		@return array of values
		~#
		method : public : ReadIntArray() ~ Int[] {
			DESERL_INT_ARY;
		}

		#~
		Reads an array of values
		@return array of values
		~#		
		method : public : ReadFloatArray() ~ Float[] {
			DESERL_FLOAT_ARY;
		}
	}
}

#~
Supports file I/O operations
~#
bundle System.IO.File {	
	#~
	Provides file operations
	~#
	class File {
		@handle : Int;
		@name : System.String;
		
		#~
		Default constructor
		@param name file name
		~#
		New(name : System.String) {
			Parent();
			@name := name;
		}
		
		#~
		Checks of the file is open
		@return ture if the file was opened, false otherwise
		~#
		method : public : IsOpen() ~ Bool {
			FILE_IS_OPEN;
		}

		#~
		Seeks to a point in the file
		@param p seek offset
		@return ture if operation was successful, false otherwise
		~#
		method : public : Seek(p : Int) ~ Bool {
			FILE_SEEK;
		}
		
		#~
		Rewinds the seek pointer
		~#
		method : public : Rewind() ~ Nil {
			FILE_REWIND;
		}

		#~
		Check if seek pointer is at the end-of-file
		@return true if at the end-of-file, false otherwise
		~#
		method : public : IsEOF() ~ Bool {
			FILE_EOF;
		}
		
		#~
		Returns the size of the file
		@param n file name
		@return size of the file
		~#
		function : Size(n : System.String) ~ Int {
			FILE_SIZE;
		}		
		
		function : CreateTime(n : System.String) ~ Date {
			return CreateTime(n, false);
		}

		function : CreateTime(n : System.String, gmt : Bool) ~ Date {
			day : Int; 
			month : Int; 
			year : Int; 
			hours : Int; 
			mins : Int; 
			secs : Int; 

			FILE_CREATE_TIME;

			return Date->New(day, month, year, hours, mins, secs, gmt);
		}		
		
		function : ModifiedTime(n : System.String) ~ Date {
			return ModifiedTime(n, false);
		}

		function : ModifiedTime(n : System.String, gmt : Bool) ~ Date {
			day : Int; 
			month : Int; 
			year : Int; 
			hours : Int; 
			mins : Int; 
			secs : Int; 

			FILE_MODIFIED_TIME;

			return Date->New(day, month, year, hours, mins, secs, gmt);
		}		

		function : AccessedTime(n : System.String) ~ Date {
			return AccessedTime(n, false);
		}

		function : AccessedTime(n : System.String, gmt : Bool) ~ Date {
			day : Int;
			month : Int;
			year : Int;
			hours : Int;
			mins : Int;
			secs : Int;
			
			FILE_ACCESSED_TIME;
			
			return Date->New(day, month, year, hours, mins, secs, gmt);
		}
		
		function : Delete(n : System.String) ~ Bool {
			FILE_DELETE;
		}
		
		function : Exists(n : System.String) ~ Bool {
			FILE_EXISTS;
		}
		
		function : Rename(o : System.String, n : System.String) ~ Bool {
			FILE_RENAME;
		}
	}

	class FileReader from File implements InputStream {
		New(name : System.String) {
			Parent(name);
			FILE_OPEN_READ;
		}	
		
		method : public : Close() ~ Nil {
			FILE_CLOSE;
		}

		method : public : ReadByte() ~ Byte {
			FILE_IN_BYTE;
		}

		method : public : ReadBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			FILE_IN_CHAR_ARY;
		}

		method : public : ReadBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			FILE_IN_BYTE_ARY;
		}

		method : public : ReadString() ~ System.String {
			buffer : Char[] := Char->New[1024];
			ReadString(buffer);
			return System.String->New(buffer);
		}

		method : ReadString(buffer : Char[]) ~ Nil {
			FILE_IN_STRING;
		}
		
		function : ReadFile(name : String) ~ String {
			len := File->Size(name);
			if(len > 0) {
				buffer := Char->New[len + 1];
				in := FileReader->New(name);
				if(in->IsOpen()) {
					in->ReadBuffer(0, len, buffer);
					in->Close();
					
					return String->New(buffer);
				};
			};
	
			return Nil;
		}
		
		function : ReadBinaryFile(name : String) ~ Byte[] {
			len := File->Size(name);
			buffer := Byte->New[len];
			in := FileReader->New(name);
			if(in->IsOpen()) {
				in->ReadBuffer(0, len, buffer);
				in->Close();
				
				return buffer;
			};
			
			return Nil;
		}
	}
	
	class FileWriter from File implements OutputStream {
		New(name : System.String) {
			Parent(name);
			FILE_OPEN_WRITE;
		}	
		
		method : public : Close() ~ Nil {
			FILE_CLOSE;
		}

		method : public : Flush() ~ Nil {
			FILE_FLUSH;
		}

		method : public : WriteByte(b : Int) ~ Bool {
			FILE_OUT_BYTE;
		}

		method : public : WriteBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			FILE_OUT_BYTE_ARY;
		}
		
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			FILE_OUT_CHAR_ARY;
		}

		method : public : WriteBuffer(buffer : Byte[]) ~ Int {
			return WriteBuffer(0, buffer->Size(), buffer);
		}
		
		method : public : WriteString(str : System.String) ~ Nil {
			WriteString(str->ToCharArray());
		}

		method : WriteString(buffer : Char[]) ~ Nil {
			FILE_OUT_STRING;
		}
	}
	
	class Directory {
		function : Create(n : System.String) ~ Bool {
			DIR_CREATE;
		}
		
		function : Exists(n : System.String) ~ Bool {
			DIR_EXISTS;
		}
		
		function : List(n : System.String) ~ System.String[] {
			DIR_LIST;
		}
	}
}

#------------ Socket I/O ------------
bundle System.IO.Net {
	class TCPSocket implements InputStream, OutputStream {
		@handle : Int;
		@address : System.String;
		@port : Int;
		
		New(address : System.String, port : Int) {
			Parent();
			@address := address;
			@port := port;
			SOCK_TCP_CONNECT;
		}

		method : public : GetAddress() ~ String {
			return @address;
		}
		
		method : public : GetPort() ~ Int {
			return @port;
		}

		method : public : IsOpen() ~ Bool {
			SOCK_TCP_IS_CONNECTED;
		}
		
		method : public : WriteByte(b : Int) ~ Bool {
			SOCK_TCP_OUT_BYTE;
		}
		
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			SOCK_TCP_OUT_BYTE_ARY;
		}
		
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			SOCK_TCP_OUT_CHAR_ARY;
		}
		
		method : public : ReadByte() ~ Byte {
			SOCK_TCP_IN_BYTE;
		}
		
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			SOCK_TCP_IN_BYTE_ARY;
		}
		
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			SOCK_TCP_IN_CHAR_ARY;
		}
				
		method : public : WriteString(str : System.String) ~ Nil {
			WriteString(str->ToCharArray());
		}

		method : WriteString(buffer : Char[]) ~ Nil {
			SOCK_TCP_OUT_STRING;
		}
		
		method : public : native : ReadString() ~ System.String {
			buffer : Char[] := Char->New[1024];
			ReadString(buffer);
			return System.String->New(buffer);
		}

		method : ReadString(buffer : Char[]) ~ Nil {
			SOCK_TCP_IN_STRING;
		}

		function : HostName() ~ String {
			SOCK_TCP_HOST_NAME;
		}

		method : public : Flush() ~ Nil {}

		method : public : Close() ~ Nil {
			SOCK_TCP_CLOSE;
		}
	}
	
	class TCPSecureSocket implements InputStream, OutputStream {
		@ctx : Int;
		@bio : Int;
		@is_open : Bool;
		@address : System.String;
		@port : Int;
		
		New(address : System.String, port : Int) {
			Parent();
			@address := address;
			@port := port;
			SOCK_TCP_SSL_CONNECT;
		}

		method : public : GetAddress() ~ String {
			return @address;
		}
		
		method : public : GetPort() ~ Int {
			return @port;
		}

		method : public : IsOpen() ~ Bool {
			return @is_open;		
		}
		
		method : public : WriteByte(b : Int) ~ Bool {
			SOCK_TCP_SSL_OUT_BYTE;
		}
		
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			SOCK_TCP_SSL_OUT_BYTE_ARY;
		}
		
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			SOCK_TCP_SSL_OUT_CHAR_ARY;
		}
		
		method : public : ReadByte() ~ Byte {
			SOCK_TCP_SSL_IN_BYTE;
		}
		
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			SOCK_TCP_SSL_IN_BYTE_ARY;
		}
		
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			SOCK_TCP_SSL_IN_CHAR_ARY;
		}
		
		method : public : WriteString(str : System.String) ~ Nil {
			WriteString(str->ToCharArray());
		}

		method : WriteString(buffer : Char[]) ~ Nil {
			SOCK_TCP_SSL_OUT_STRING;
		}
		
		method : public : native : ReadString() ~ System.String {
			buffer : Char[] := Char->New[1024];
			ReadString(buffer);
			return System.String->New(buffer);
		}

		method : ReadString(buffer : Char[]) ~ Nil {
			SOCK_TCP_SSL_IN_STRING;
		}

		method : public : Flush() ~ Nil {}

		method : public : Close() ~ Nil {
			SOCK_TCP_SSL_CLOSE;
		}
	}
	
	class TCPSocketServer {
		@handle : Int;
		@port : Int;
	   
		New(port : Int) {
		  Parent();
		  @port := port;
		  SOCK_TCP_BIND;
		}
	
		method : public : Listen(backlog : Int) ~ Bool {
			SOCK_TCP_LISTEN;
		}
	
		method : public : Accept() ~ TCPSocket {
			SOCK_TCP_ACCEPT;
		}
	
		method : public : Close() ~ Nil {
			SOCK_TCP_CLOSE;
		}
	}
}

#------------ Introspection ------------#
bundle System.Introspection {
	class Class {
		@name : String;
		@methods : Method[];
	
		function : Instance(name : System.String) ~ System.Base {
			LOAD_NEW_OBJ_INST;
		}

		method : public : IsLoaded() ~ Bool {
			return @methods <> Nil;
		}
		
		method : public : GetName() ~ String {
			return @name;
		}
		
		method : public : GetMethods() ~ Method[] {
			return @methods;
		}
		
		method : public : GetMethodNumber() ~ Int {
			if(@methods <> Nil) {
				return @methods->Size();
			};

			return 0;
		}
	}
	
	class Method {
		@native_mthd_ptr : Int;
		@cls : Class;
		@name : String;
		@parameters : DataType[];
		@rtrn_type  : DataType;
	
		method : public : GetClass() ~ Class {
			return @cls;
		}

		method : public : GetName() ~ String {
			return @name;
		}
		
		method : public : GetParameters() ~ DataType[] {
			return @parameters;
		}
		
		method : public : GetReturn() ~ DataType {
			return @rtrn_type;
		}
	}
	
	class DataType {
		@type  : TypeId;
		@cls_name : String;
		@dimension : Int;
		
		method : public : GetType() ~ TypeId {
			return @type;
		}
		
		method : public : GetDimension() ~ Int {
			return @dimension;
		}
		
		method : public : GetClassName() ~ String {
			return @cls_name;
		}
	}
	
	enum TypeId := -1000 {
		BOOL,
		BYTE,
		CHAR,
		INT,
		FLOAT,
		CLASS,
		FUNC
	}	
}	
