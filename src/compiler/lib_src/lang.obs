#~~
# Objeck system classes.
# Copyright (c) 2008-2010 Randy Hollines
#
# note: this file is a system file and can only be compiled using -D_SYSTEM option
~~#	

bundle System {
	#~~
	# Boolean class support
	~~#	
	class $Bool {
		function : native : Print(b : Bool) ~ Nil {
			STD_OUT_BOOL;
		}

		function : native : PrintLine(b : Bool) ~ Nil {
			STD_OUT_BOOL;
			'\n'->Print();
		}

		function : native : Size(b : Bool[]) ~ Int {
			LOAD_ARY_SIZE;
		}

		function : native : ToString(b : Bool) ~ String {
			string : String;

			if(b = true) {
				string := "true";
			}
			else {
			 	string := "false";
			};

			return string;			
		}
	}
	
	#~~
	# Byte class support
	~~#	
	class $Byte {
		function : native : Min(l : Byte, r : Byte) ~ Byte {
			if(l < r) {
				return l;
			};

			return r;
		}

		function : native : Max(l : Byte, r : Byte) ~ Byte {
			if(l > r) {
				return l;
			};

			return r;
		}

		function : native : Abs(v : Byte) ~ Byte {
			if(v < 0) {
				return v * -1;
			};

			return v;
		}

		function : native : Print(b : Byte) ~ Nil {
			STD_OUT_BYTE;
		}

		function : native : PrintLine(b : Byte) ~ Nil {
			STD_OUT_BYTE;
			'\n'->Print();
		}

		function : native : Size(b : Byte[]) ~ Int {
			LOAD_ARY_SIZE;
		}

		function : native : ToString(b : Byte) ~ String {
			string : String := String->New();
			
			if(b = 0) {
				string->Append(48->As(Char));
				return string;
			};

			if(b < 0) {
				string->Append(45->As(Char));
				b := b * -1;
			};		
		
			result : Int := b / 100;
			if(result > 0 & result < 10) {
				string->Append((result + 48)->As(Char));
			};
			b := b % 100;
			if(b = 0) {
				string->Append(48->As(Char));
			};

			result := b / 10;
			if(result > 0 & result < 10) {
				string->Append((result + 48)->As(Char));
			};
			b := b % 10;
			if(b = 0) {
				string->Append(48->As(Char));
			};
						
			if(b <> 0) {
				string->Append((b + 48)->As(Char));
			};

			return string;
		}
	}

	#~~
	# Character class support
	~~#	
	class $Char {
		function : native : ToLower(c : Char) ~ Char {
			if(c >= 'A' & c <= 'Z') {
				return c + 32;
			};

			return c;
		}

		function : native : ToUpper(c : Char) ~ Char {
			if(c >= 'a' & c <= 'z') {
				return c - 32;
			};

			return c;
		}

		function : native : IsDigit(c : Char) ~ Bool {
			if(c >= '0' & c <= '9') {
				return true;
			};
			
			return false;
		}

		function : native : IsChar(c : Char) ~ Bool {
			if((c >= 'a' & c <= 'z') | (c >= 'A' & c <= 'Z')) {
				return true;
			};
			
			return false;
		}
		
		function : native : Min(l : Char, r : Char) ~ Char {
			if(l < r) {
				return l;
			};

			return r;
		}

		function : native : Max(l : Char, r : Char) ~ Char {
			if(l > r) {
				return l;
			};

			return r;
		}

		function : native : Print(c : Char) ~ Nil {
			STD_OUT_CHAR;
		}

		function : native : PrintLine(c : Char) ~ Nil {
			STD_OUT_CHAR;
			'\n'->Print();
		}

		function : native :  Print(c : Char[]) ~ Nil {
			STD_OUT_CHAR_ARY;
		}

		function : native :  PrintLine(c : Char[]) ~ Nil {
			STD_OUT_CHAR_ARY;
			'\n'->Print();
		}

		function : native : Size(c : Char[]) ~ Int {
			LOAD_ARY_SIZE;
		}

		function : native : ToString(c : Char) ~ String {
			string : String := String->New();
			string->Append(c);
			
			return string;
		}
	}
	
	class Number {
		function : native : IntToString(value : Int, string : String) ~ Nil {
			values := Int->New[16];
			i := 0;
			while(value >= 10 & i < 16) {
				mod := value % 10;
				values[i] := mod;
				i += 1;
				value := value / 10;
			};
			values[i] := value;
            
			while(i >= 0) {
				string->Append((values[i] + 48)->As(Char));
				i := i - 1;
			};     
		}
	}

	#~~
	# Int class support
	~~#	
	class $Int {
		function : native : MaxSize() ~ Int {
			return 2147483647;
		}
		
		function : native : Factorial(n : Int) ~ Int {
			result := 1;
			for (i := 1; i <= n; i += 1;) {
				result *= i;
			};

			return result;
		}

		function : native : Min(l : Int, r : Int) ~ Int {
			if(l < r) {
				return l;
			};

			return r;
		}
	
		function : native : Max(l : Int, r : Int) ~ Int {
			if(l > r) {
				return l;
			};

			return r;
		}

		function : native : Abs(v : Int) ~ Int {
			if(v < 0) {
				return v * -1;
			};

			return v;
		}

		function : native : Print(i : Int) ~ Nil {
			STD_OUT_INT;
		}

		function : native : PrintLine(i : Int) ~ Nil {
			STD_OUT_INT;
			'\n'->Print();
		}

		function : native : Size(i : Int[]) ~ Int {
			LOAD_ARY_SIZE;
		}

		function : native : ToString(i : Int) ~ String {
			str := String->New();
			Number->IntToString(i, str);
			return str;
		}
	}

	#~~
	# Float class support
	~~#	
	class $Float {
		function : native : Pi() ~ Float {
			return 3.14159265;
		}

		function : native : E() ~ Float {
			return 2.71828183;
		}	
		
		function : native : Min(l : Float, r : Float) ~ Float {
			if(l < r) {
				return l;
			};

			return r;
		}

		function : native : Max(l : Float, r : Float) ~ Float {
			if(l > r) {
				return l;
			};

			return r;
		}

		function : native : Abs(v : Float) ~ Float {
			if(v < 0) {
				return v * -1;
			};

			return v;
		}
		
		# note: sse4 instruction
		function : Floor(f : Float) ~ Float {
			FLOR_FLOAT;
		}
		
		# note: sse4 instruction
		function : Ceiling(f : Float) ~ Float {
			CEIL_FLOAT;
		}
		
		function : Sin(f : Float) ~ Float {
			SIN_FLOAT;
		}
		
		function : Cos(f : Float) ~ Float {
			COS_FLOAT;
		}
		
		function : Tan(f : Float) ~ Float {
			TAN_FLOAT;
		}
		
		function : Log(f : Float) ~ Float {
			LOG_FLOAT;
		}
		
		function : SquareRoot(f : Float) ~ Float {
			SQRT_FLOAT;
		}
		
		function : Random() ~ Float {
			RAND_FLOAT;
		}
		
		function : Power(f : Float, r : Float) ~ Float {
			POW_FLOAT;
		}

		function : native : Print(f : Float) ~ Nil {
			STD_OUT_FLOAT;
		}

		function : native : PrintLine(f : Float) ~ Nil {
			STD_OUT_FLOAT;
			'\n'->Print();
		}

		function : native : Size(f : Float[]) ~ Int {
			LOAD_ARY_SIZE;
		}

		function : native : ToString(f : Float) ~ String {
			str := String->New();
			remainder := f - f->Floor();
			Number->IntToString(f->Floor()->As(Int), str);
            str->Append('.');
            Number->IntToString((1001.0 * remainder)->As(Int), str);

			return str;
		}
	}

	#~~
	# Array class support
	~~#	
	class $BaseArray {
		function : native : Size(f : System.Base[]) ~ Int {
			LOAD_ARY_SIZE;
		}
	}

	#~~
	# Class identifier
	~~#	
	enum ClassID {
	}

	#~~
	# Provides useful base class functionality
	~~#	
	class Base {
		New() {
		}

		method : public : GetClass() ~ Introspection.Class {
			cls : Class;
			LOAD_CLS_BY_INST;
			return cls;
		}
		
		method : public : native : GetClassID() ~ ClassID {
			LOAD_CLS_INST_ID;
		}

		method : public : native : GetInstanceID() ~ Int {
			LOAD_INST_UID;
		}
	}
	
	#~~
	# Provides useful base class functionality
	~~#	
	class Compare from System.Base {
		New() {
			Parent();
		}

		#~~
		# Compares two objects.
		# @return 1 if greater, -1 if less, otherwise 0
		~~#
		method : virtual : public : Compare(rhs : System.Compare) ~ Int;

		#~~
		# Returns a unique hash ID for the given class
		# @return hash ID
		~~#
		method : virtual : public : HashID() ~ Int;
	}
	
	#~~
	# Provides useful base class functionality
	
	class Hash from Compare {
		method : virtual : public : Compare(rhs : Compare) ~ Int;
		method : virtual : public : Hash() ~ Int;
	}
	~~#	
	
	#~~
	# Character string class
	~~#	
	class String from Compare {
		@string : Char[];
		@max : Int;
		@pos : Int;

		New() {
			Parent();

			@max := 8;
			@string := Char->New[@max];
			@pos := 0;
		}

		New(string : String) {
			Parent();

			@max := 8;
			@string := Char->New[@max];
			@pos := 0;
			
			Append(string->ToCharArray());
		}
					
		New(array : Char[]) {
			Parent();
			
			if(array->Size() < 8) {
				@max := 8;
			}
			else {
				@max := array->Size();
			};
			
			@string := Char->New[@max];
			@pos := 0;

			Append(array);
		}
		
		New(array : Byte[]) {
			Parent();
			
			if(array->Size() < 8) {
				@max := 8;
			}
			else {
				@max := array->Size();
			};
			
			@string := Char->New[@max];
			@pos := 0;

			Append(array);
		}

		method : public : native : ToCharArray() ~ Char[] {
			array : Char[] := Char->New[@pos];
			for(i : Int := 0; i < @pos; i += 1;) {
				array[i] := @string[i];
			};

			return array;
		}

		method : public : native : Append(i : Int) ~ Nil {
			Append(i->ToString()->ToCharArray());
		}

		method : public : native : Append(f : Float) ~ Nil {
			Append(f->ToString()->ToCharArray());
		}

		method : public : native : Append(str : String) ~ Nil {
			Append(str->ToCharArray());
		}
		
#		method : public : native : Append(array : Char[]) ~ Nil {
		method : public : Append(array : Char[]) ~ Nil {
			if(@pos + array->Size() >= @max) {
				# expand string
				@max := (@max + array->Size()) * 2;
				tmp : Char[] := Char->New[@max];
				# copy elements
				for(i : Int := 0; i < @string->Size(); i += 1;) {
					tmp[i] := @string[i];	
				};
				@string := tmp;
			};
			
			for(i : Int := 0; i < array->Size() & array[i] <> '\0'; i += 1;) {
				@string[@pos] := array[i];
				@pos := @pos + 1;
			};
		}
		
		method : public : native : Append(array : Byte[]) ~ Nil {
			if(@pos + array->Size() >= @max) {
				# expand string
				@max := (@max + array->Size()) * 2;
				tmp : Char[] := Char->New[@max];
				# copy elements
				for(i : Int := 0; i < @string->Size(); i += 1;) {
					tmp[i] := @string[i];	
				};
				@string := tmp;
			};
			
			for(i : Int := 0; i < array->Size() & array[i] <> '\0'; i += 1;) {
				@string[@pos] := array[i];
				@pos := @pos + 1;
			};
		}

		method : public : native : Append(c : Char) ~ Nil {
			if(@pos >= @max) {
				# expand string
                		@max := @max * 2;
                		tmp : Char[] := Char->New[@max];
                		# copy elements
                		for(i : Int := 0; i < @string->Size(); i += 1;) {
                        		tmp[i] := @string[i];
                		};
                		@string := tmp;
			};

			@string[@pos] := c;
			@pos := @pos + 1;
		}
		
		method : public : native : Append(c : Byte) ~ Nil {
			if(@pos >= @max) {
				# expand string
                		@max := @max * 2;
                		tmp : Char[] := Char->New[@max];
                		# copy elements
                		for(i : Int := 0; i < @string->Size(); i += 1;) {
                        		tmp[i] := @string[i];
                		};
                		@string := tmp;
			};

			@string[@pos] := c;
			@pos := @pos + 1;
		}
		
		method : public : Find(char : Char) ~ Int {
			return Find(0, char);
		}
		
		method : public : Find(offset : Int, char : Char) ~ Int {
			if(offset < @pos) {
				found_index := -1;
				for(i := offset; i < @pos; i += 1;) {
					if(@string[i] = char) {
						return i;
					};
				};
			};

			return -1;
		}

		method : public : native : Find(find : String) ~ Int {
			return Find(find, 0);
		}

		method : public : native : Find(find : String, offset : Int) ~ Int {
			size := find->Size();
			if(size > 0 & offset < size) {
				found_index := Find(find->Get(offset));
				while(found_index > -1) {
					j := found_index;
					match := true;
					i : Int;
					for(i := 0; match & i < find->Size() & j < @pos; i += 1;) {
						if(find->Get(i) <> @string[j]) {
							match := false;
						};
						j += 1;
					};

					if(match & i = find->Size()) {
						return found_index;
					};
					
					found_index := Find(found_index + 1, find->Get(0));
				};

				return -1;
			};

			return -1;
		}
		
		method : public : native : Size() ~ Int {
			return @pos;			
		}
  
		method : public : native : Get(index : Int) ~ Char {
			if(index < @pos) {
				return @string[index];
			};

			return '\0';
		}
		
		method : public : native : ToInt() ~ Int {
			if(@pos > 1 & @string[0] = '0' & @string[1] = 'x') {
				end := 1;			
				mag : Int := 1;
				val : Int := 0;
				for(i : Int := @pos - 1; i > end; i := i - 1;) {
					pos_val : Int := @string[i];
					if(pos_val >= '0' & pos_val <= '9') {
						pos_val := pos_val - 48;
					}
					else if(pos_val >= 'A' & pos_val <= 'F') {
						pos_val := pos_val - 55;
					}
					else if(pos_val >= 'a' & pos_val <= 'f') {
						pos_val := pos_val - 87;
					}
					else {
						return 0;
					};
					
					if(mag = 1) {
						val := pos_val;
					}
					else {
						val := val + pos_val * mag;	
					};
					# update
					mag := mag * 16;
				};
				
				return val;
			}
			else if(@string->Size() > 0) {
				is_neg : Bool := false;
				if(@string[0] = '-') {
					is_neg := true;
				};

				end : Int;
				if(is_neg) {
					end := 0;
				}
				else {
					end := -1;
				};

				val : Int := 0;
				mag : Int := 1;
				for(i : Int := @pos - 1; i > end; i := i - 1;) {
					pos_val : Int := @string[i] - 48;
					if(pos_val < 0 | pos_val > 9) {
						return 0;
					};

					if(mag = 1) {
						val := pos_val;
					}
					else {
						val := val + pos_val * mag;	
					};
					# update
					mag := mag * 10;
				};

				if(is_neg) {
					return val * -1;
				}
				else {
					return val;
				};
			};

			return 0;
		}

		method : public : native : ToFloat() ~ Float {
			if(@string->Size() > 0) {
				val : Float := 0;
				is_neg : Bool := false;
				if(@string[0] = '-') {
					is_neg := true;
				};

				end : Int;
				if(is_neg) {
					end := 0.0;
				}
				else {
					end := -1.0;
				};

				# find decimal point
				dec_index : Int := -1;
				i : Int := 0;
				while(dec_index = -1 & i < @pos) {
					if(@string[i] = '.') {
						dec_index := i;
					};
					i += 1;
				};

				# calculate decimal number 
				if(dec_index <> -1) {
					mag : Float := .1;
					dec_index := dec_index + 1;
					
					for(j : Int := dec_index; j < @pos; j := j + 1;) {
						pos_val : Int := @string[j] - 48;
						if(pos_val < 0 | pos_val > 9) {
							return 0;
						};

						if(mag = 1) {
							val := pos_val;
						}
						else {
							val := val + pos_val * mag;	
						};
						# update
						mag := mag * .1;
					};
					
					dec_index := dec_index - 1;
					mag := 1.0;
					for(j : Int := dec_index - 1; j > end; j := j - 1;) {
						pos_val : Int := @string[j] - 48;
						if(pos_val < 0 | pos_val > 9) {
							return 0;
						};

						if(mag = 1) {
							val := val + pos_val;
						}
						else {
							val := val + pos_val * mag;	
						};
						# update
						mag := mag * 10.0;
					};
				}
				# calculate non-decimal number 
				else {
					mag : Int := 1;
					for(j : Int := @pos - 1; j > end; j := j - 1;) {
						pos_val : Int := @string[j] - 48;
						if(pos_val < 0 | pos_val > 9) {
							return 0.0;
						};

						if(mag = 1) {
							val := pos_val;
						}
						else {
							val := val + pos_val * mag;	
						};
						# update
						mag := mag * 10.0;
					};
				};

				if(is_neg) {
					return val * -1.0;
				}
				else {
					return val;
				};
			};

			return 0.0;
		}

		method : public : native : StartsWith(c : Char) ~ Bool {
			sc : Char := Get(0);
			return sc <> '\0' & c = sc;
		}

		method : public : native : StartsWith(s : String) ~ Bool {
			if(s->Size() <= @pos) {
				for(i := 0; i < s->Size(); i += 1;) {
					if(s->Get(i) <> @string[i]) {
						return false;
					};
				};

				return true;
			};

			return false;
		}

		method : public : native : EndsWith(s : String) ~ Bool {
			if(s->Size() <= @pos) {
				i := s->Size() - 1;
				j := @pos - 1;
				while(i > -1) {
					if(s->Get(i) <> @string[j]) {
						return false;
					};
					i := i - 1;
					j := j - 1;
				};

				return true;
			};

			return false;
		}
		
		method : public : native : Reverse() ~ String {
			tmp : Char[] := Char->New[@max];
			i := 0; j := @pos - 1;
			while(j > -1) {
				tmp[i] := @string[j];
				j -= 1;	i += 1;
			};
			
			return String->New(tmp);
		}
		
		method : public : native : Trim() ~ String {
			# copy elements

			i := 0;	
			c : Char := @string[i];
			while((c = ' ' | c = '\r' | c = '\n' | c = '\t') & i < @string->Size()) {
				i += 1;
				c := @string[i];
			};

			j := @string->Size() - 1;
			c := @string[j];
			while((c = ' ' | c = '\r' | c = '\n' | c = '\t') & j > -1) {
				j := j - 1;
				c := @string[j];
			};	
		
			k := 0;		
			tmp : Char[] := Char->New[@max];
			while(i < j) {
				tmp[k] := @string[i];
				i += 1;
				k := k + 1;
			};
            
			return String->New(tmp);
		}
		
		method : public : native : Split(delim : String) ~ String[] {
			if(delim->Size() = 0 | @pos = 0) {
				return Nil;
			};
			
			# first-pass count tokens
			count := 0;
			start_index := 0;
			found_index := -1;
			delim_index := 0;
			
			for(i : Int := 0; i < @pos; i += 1;) {
				if(found_index = -1 & delim->Get(0) = @string[i]) {
					found_index := i;
				};
				
				if(found_index > -1) {
					if(delim_index < delim->Size() & delim->Get(delim_index) = @string[i]) {
						delim_index += 1;
					}
					else if(delim_index = delim->Size()) {
						count += 1;
						start_index := found_index + delim->Size();
						found_index := -1;
						delim_index := 0;
					}
					else {
						found_index := -1;
						delim_index := 0;
					};
				};
			};
			
			if(start_index <> 0) {
				count += 1;
				SubString(start_index, @pos - start_index);
			};
			
			# second-pass parse tokens
			parsed_strings : String[] := String->New[count];
			count := 0;
			start_index := 0;
			found_index := -1;
			delim_index := 0;
			
			for(i : Int := 0; i < @pos; i += 1;) {
				if(found_index = -1 & delim->Get(0) = @string[i]) {
					found_index := i;
				};
				
				if(found_index > -1) {
					if(delim_index < delim->Size() & delim->Get(delim_index) = @string[i]) {
						delim_index += 1;
					}
					else if(delim_index = delim->Size()) {
						parsed_strings[count] := SubString(start_index, found_index + delim->Size() - start_index);
						count += 1;
						
						start_index := found_index + delim->Size();
						found_index := -1;
						delim_index := 0;
					}
					else {
						found_index := -1;
						delim_index := 0;
					};
				};
			};
			
			if(start_index <> 0) {
				parsed_strings[count] := SubString(start_index, @pos - start_index);
				count += 1;
			};
			
			return parsed_strings;
		}
		
		method : public : native : ToUpper() ~ String {
			array : Char[] := Char->New[@pos];
			for(i : Int := 0; i < @pos; i += 1;) {
				c := @string[i];
				if(c > 96 & c < 123) {
					c := c - 32;
				};
				array[i] := c;
			};
			
			return String->New(array);
		}
		
		method : public : native : ToLower() ~ String {
			array : Char[] := Char->New[@pos];
			for(i : Int := 0; i < @pos; i += 1;) {
				c := @string[i];
				if(c > 64 & c < 91) {
					c := c + 32;
				};
				array[i] := c;
			};
			
			return String->New(array);
		}

		method : public : SubString(offset : Int) ~ String {
			return SubString(0, offset);
		}

		method : public : native : SubString(offset : Int, length : Int) ~ String {
			if(offset < 0 | offset > @pos) {
				return Nil;
			};

			end : Int := length + offset;
			if(end < 0 | end > @pos) {
				return Nil;
			};

			array : Char[] := Char->New[length];
			for(i : Int := 0; i < length; i += 1;) {
				array[i] := @string[i + offset];
			};

			return String->New(array);
		}
	
		method : public : Equals(rhs : String) ~ Bool {
			return Compare(rhs->As(System.Compare)) = 0;
		}

		method : public : native : HashID() ~ Int {
			hash := 0;
			for(i := 0; i < @pos; i += 1;) {
				c := @string[i];
				hash += c * (c + 1);
			};
			
			return hash;
		}

		method : public : Compare(rhs : System.Compare) ~ Int {
			if(GetClassID() = rhs->GetClassID()) {
				right_string : String := rhs->As(String);
				for(i : Int := 0; i < @pos; i += 1;) {
					left : Char := @string[i];
					right : Char := right_string->Get(i);
					if(left > right) {
						return 1;
					}
					else if(left < right) {
						return -1;
					};
				};

				return 0;
			};

			return -1;
		}

		method : public : native : Print() ~ Nil {
			@string->Print();
		}

		method : public : native : PrintLine() ~ Nil {
			@string->PrintLine();
		}
	}
	
	#~~
	# Runtime system class
	~~#	
	class Runtime {
		function : Exit(code : Int) ~ Nil {
			EXIT;
		}
		
		function : GetPlatform() ~ String {
			PLTFRM;
		}
		
		function : GetTime() ~ Time.Date {
			return Time.Date->New();
		}
		
		function : Copy(dest : Byte[], dest_len : Int, src : Byte[], src_len : Int, offset : Int) ~ Bool {
			CPY_BYTE_ARY;
		}
		
		function : Copy(dest : Char[], dest_len : Int, src : Char[], src_len : Int, offset : Int) ~ Bool {
			CPY_BYTE_ARY;
		}
		
		function : Copy(dest : Int[], dest_len : Int, src : Int[], src_len : Int, offset : Int) ~ Bool {
			CPY_INT_ARY;
		}
		
		function : Copy(dest : Float[], dest_len : Int, src : Float[], src_len : Int, offset : Int) ~ Bool {
			CPY_FLOAT_ARY;
		}
	}
}

#------------ API ------------
bundle API {	
  class DllProxy {
		@name : String;
		@ptr : Int;
		
		New(name : String) {
			@name := name;
			DLL_LOAD;
		}
		
		method : public : IsLoaded() ~ Bool {
			return @ptr <> 0;
		}
		
		method : public : Unload() ~ Nil {
			DLL_UNLOAD;
		}
		
		method : public : CallFunction(name : String, args : Base[]) ~ Nil {
			DLL_FUNC_CALL;
		}
	}
}

#------------ Time ------------
bundle Time {	
  #~~
	# Date class
	~~#	
	class Date {
		@day : Int;
		@month : Int;
		@year : Int;
		@hours : Int;
		@mins : Int;
		@secs : Int;
		@is_savings : Bool;
		
		New() {
			SYS_TIME;
		}
		
		method : public : GetDay() ~ Int {
			return @day;
		}
		
		method : public : GetMonth() ~ Int {
			return @month;
		}
		
		method : public : GetYear() ~ Int {
			return @year;
		}
		
		method : public : GetHours() ~ Int {
			return @hours;
		}
		
		method : public : GetMinutes() ~ Int {
			return @mins;
		}
		
		method : public : GetSeconds() ~ Int {
			return @secs;
		}
		
		method : public : IsSavingsTime() ~ Bool {
			return @is_savings;
		}
	}
	
	#~~
	# Timer class
	~~#	
	class Timer {
		@elapsed : Int;
		
		New() {
		}
		
		method : public : Start() ~ Nil {
			TIMER_START;
		}
		
		method : public : End() ~ Nil {
			TIMER_END;
		}
		
		method : public : GetElapsedTime() ~ Int {
			return @elapsed;
		}
	}
}

#------------ Concurrency ------------
bundle Concurrency {	
	#~~
	# System thread class
	~~#	
	class Thread {
		@id : Int;
		@name : String;
		@param : System.Base;
		
		New(name : String) {
			@name := name;
		}
		
		method : public : Execute(param : System.Base) ~ Nil {
			@param := param;
			ASYNC_MTHD_CALL;
		}

		#~~
		# Sleeps worker thread
		~~#
		function : Sleep(t : Int) ~ Nil {
			THREAD_SLEEP;
		}
		
		#~~
		# Joins a thread
		~~#
		method : public : Join() ~ Nil {
			THREAD_JOIN;
		}
		
		#~~
		# Returns the name
		~~#
		method : public : GetName() ~ String {
			return @name;
		}
		
		#~~
		# Returns the run ID
		~~#
		method : public : GetRunID() ~ Int {
			return @id;
		}
		
		#~~
		# Method to execute in new worker thread
		~~#
		method : virtual : public : Run(param : System.Base) ~ Nil;
	}	
	
	#~~
	# System thread class
	~~#	
	class ThreadMutex {
		@name : String;
		# hack to hold a mutext struct.  Largest struct 
		# is 64-bytes for x64 POSIX
		@m0 : Int;
		@m1 : Int;
		@m2 : Int;
		@m3 : Int;
		@m4 : Int;
		@m5 : Int;
		@m6 : Int;
		@m7 : Int;
		
		New(name : String) {
			@name := name;
			THREAD_MUTEX;
		}
		
		#~~
		# Returns the name
		~~#
		method : public : GetName() ~ String {
			return @name;
		}
	}
}

#------------ I/O ------------
bundle IO {
 	#~~
	# Returns the name
	~~#
	class Console {
		function : ReadString() ~ System.String {
			console := IO.ConsoleIO->Instance();
			return console->ReadString();
		}
		
		function : Print(b : Bool) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(b);
		}
		
		function : PrintLine(b : Bool) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(b);
		}
	
		function : Print(b : Byte) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(b);
		}
	
		function : PrintLine(b : Byte) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(b);
		}
		
		function : Print(c : Char) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(c);
		}
	
		function : PrintLine(c : Char) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(c);
		}
	
		function : Print(i : Int) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(i);
		}
	
		function : PrintLine(i : Int) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(i);
		}
		
		function : Print(f : Float) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(f);
		}
	
		function : PrintLine(f : Float) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(f);
		}
	
		function : Print(cc : Char[]) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(cc);
		}
	
		function : PrintLine(cc : Char[]) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(cc);
		}
		
		function : Print(s : System.String) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(s);
		}
	
		function : PrintLine(s : System.String) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(s);
		}
	
		function : PrintLine() ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine();
		}
	}
 	
 	#~~
	# Support for Console class
	~~#
 	class ConsoleIO {
		@console : static : ConsoleIO;

		New : private () {
		}

		function : Instance() ~ ConsoleIO {
			if(@console <> Nil) {
				@console := ConsoleIO->New();
			};

			return @console;
		}

		method : public : ReadString() ~ System.String {
			buffer : Char[] := Char->New[256];
			ReadString(buffer);
			return System.String->New(buffer);
		}
		
		method : public : Print(b : Bool) ~ ConsoleIO {
			b->Print();
			return @console;
		}
		
		method : public : PrintLine(b : Bool) ~ ConsoleIO {
			b->PrintLine();
			return @console;
		}

		method : ReadString(buffer : Char[]) ~ Nil {
			STD_IN_STRING;
		}
		
		method : public : Print(b : Byte) ~ ConsoleIO {
			b->Print();
			return @console;
		}

		method : public : PrintLine(b : Byte) ~ ConsoleIO {
			b->PrintLine();
			return @console;
		}
		
		method : public : Print(c : Char) ~ ConsoleIO {
			c->Print();
			return @console;
		}

		method : public : PrintLine(c : Char) ~ ConsoleIO {
			c->PrintLine();
			return @console;
		}

		method : public : Print(i : Int) ~ ConsoleIO {
			i->Print();
			return @console;
		}

		method : public : PrintLine(i : Int) ~ ConsoleIO {
			i->PrintLine();
			return @console;
		}
		
		method : public : Print(f : Float) ~ ConsoleIO {
			f->Print();
			return @console;
		}

		method : public : PrintLine(f : Float) ~ ConsoleIO {
			f->PrintLine();
			return @console;
		}

		method : public : Print(cc : Char[]) ~ ConsoleIO {
			cc->Print();
			return @console;
		}

		method : public : PrintLine(cc : Char[]) ~ ConsoleIO {
			cc->PrintLine();
			return @console;
		}
		
		method : public : Print(s : System.String) ~ ConsoleIO {
			s->Print();
			return @console;
		}

		method : public : PrintLine(s : System.String) ~ ConsoleIO {
			s->PrintLine();
			return @console;
		}

		method : public : PrintLine() ~ ConsoleIO {
			'\n'->PrintLine();
			return @console;
		}
	}
	
	class File {
		@handle : Int;
		@name : System.String;
		
		New(name : System.String) {
			@name := name;
		}
		
		method : public : IsOpen() ~ Bool {
			FILE_IS_OPEN;
		}

		method : public : Seek(p : Int) ~ Bool {
			FILE_SEEK;
		}
		
		method : public : Rewind() ~ Nil {
			FILE_REWIND;
		}

		method : public : IsEOF() ~ Bool {
			FILE_EOF;
		}
		
		function : Size(n : System.String) ~ Int {
			FILE_SIZE;
		}		
		
		function : Delete(n : System.String) ~ Bool {
			FILE_DELETE;
		}
		
		function : Exists(n : System.String) ~ Bool {
			FILE_EXISTS;
		}
		
		function : Rename(o : System.String, n : System.String) ~ Bool {
			FILE_RENAME;
		}
	}

	class FileReader from File {
		New(name : System.String) {
			Parent(name);
			FILE_OPEN_READ;
		}	
		
		method : public : Close() ~ Nil {
			FILE_CLOSE;
		}

		method : public : ReadByte() ~ Byte {
			FILE_IN_BYTE;
		}

		method : public : ReadBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			FILE_IN_BYTE_ARY;
		}
		
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			FILE_IN_BYTE_ARY;
		}

		method : public : ReadString() ~ System.String {
			buffer : Char[] := Char->New[256];
			ReadString(buffer);
			return System.String->New(buffer);
		}

		method : ReadString(buffer : Char[]) ~ Nil {
			FILE_IN_STRING;
		}
		
		function : ReadFile(name : String) ~ String {
			len := File->Size(name);
			buffer := Char->New[len];
			in := FileReader->New(name);
			if(in->IsOpen()) {
				in->ReadBuffer(0, len, buffer);
				in->Close();
				
				return String->New(buffer);
			};
			
			return Nil;
		}
		
		function : ReadBinaryFile(name : String) ~ Byte[] {
			len := File->Size(name);
			buffer := Byte->New[len];
			in := FileReader->New(name);
			if(in->IsOpen()) {
				in->ReadBuffer(0, len, buffer);
				in->Close();
				
				return buffer;
			};
			
			return Nil;
		}
	}
	
	class FileWriter from File {
		New(name : System.String) {
			Parent(name);
			FILE_OPEN_WRITE;
		}	
		
		method : public : Close() ~ Nil {
			FILE_CLOSE;
		}

		method : public : WriteByte(b : Int) ~ Bool {
			FILE_OUT_BYTE;
		}

		method : public : WriteBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			FILE_OUT_BYTE_ARY;
		}

		method : public : WriteBuffer(buffer : Byte[]) ~ Int {
			return WriteBuffer(0, buffer->Size(), buffer);
		}
		
		method : public : WriteString(str : System.String) ~ Nil {
			WriteString(str->ToCharArray());
		}

		method : WriteString(buffer : Char[]) ~ Nil {
			FILE_OUT_STRING;
		}
	}
	
	class Directory {
		function : Create(n : System.String) ~ Bool {
			DIR_CREATE;
		}
		
		function : Exists(n : System.String) ~ Bool {
			DIR_EXISTS;
		}
		
		function : List(n : System.String) ~ System.String[] {
			DIR_LIST;
		}
	}

	class Serializer  {
		@buffer : Byte[];
		@pos : Int;

		New() {
			@buffer := Byte->New[16];
			@pos := 0;
		}

		method : public : Write(b : Bool) ~ Nil {
			SERL_INT;
		}

		method : public : Write(i : Int) ~ Nil {
			SERL_INT;
		}
		
		method : public : Write(f : Float) ~ Nil {
			SERL_FLOAT;
		}
		
		method : public : Write(o : Base) ~ Nil {
			SERL_OBJ_INST;
		}

		method : public : Write(b : Bool[]) ~ Nil {
			SERL_INT_ARY;
		}

		method : public : Write(b : Byte[]) ~ Nil {
			SERL_BYTE_ARY;
		}

		method : public : Write(c : Char[]) ~ Nil {
			SERL_BYTE_ARY;
		}

		method : public : Write(i : Int[]) ~ Nil {
			SERL_INT_ARY;
		}
		
		method : public : Write(f : Float[]) ~ Nil {
			SERL_FLOAT_ARY;
		}
		
		method : public : Serialize() ~ Byte[] {
			temp := Byte->New[@pos];
			for(i := 0; i < @pos; i += 1;) {
				temp[i] := @buffer[i];
			};		

			return temp;
		}
	}
	
	class Deserializer  {
		@buffer : Byte[];
		@pos : Int;
		
		New(buffer : Byte[]) {
			@buffer := buffer;
			@pos := 0;
		}

		method : public : ReadBool() ~ Bool {
			DESERL_INT;
		}

		method : public : ReadInt() ~ Int {
			DESERL_INT;
		}
		
		method : public : ReadFloat() ~ Float {
			DESERL_FLOAT;
		}
		
		method : public : ReadObject() ~ Base {
			DESERL_OBJ_INST;
		}

		method : public : ReadBoolArray() ~ Bool[] {
			DESERL_INT_ARY;
		}

		method : public : ReadByteArray() ~ Byte[] {
			DESERL_BYTE_ARY;
		}

		method : public : ReadCharArray() ~ Char[] {
			DESERL_BYTE_ARY;
		}

		method : public : ReadIntArray() ~ Int[] {
			DESERL_INT_ARY;
		}
		
		method : public : ReadFloatArray() ~ Float[] {
			DESERL_FLOAT_ARY;
		}
	}
}

#------------ Socket ------------
bundle Net {
	class TCPSocket {
		@handle : Int;
		@address : System.String;
		@port : Int;
		
		New(address : System.String, port : Int) {
			@address := address;
			@port := port;
			SOCK_TCP_CONNECT;
		}
		
		method : public : IsOpen() ~ Bool {
			SOCK_TCP_IS_CONNECTED;
		}
		
		method : public : Close() ~ Nil {
			SOCK_TCP_CLOSE;
		}
	
		method : public : WriteByte(b : Int) ~ Bool {
			SOCK_TCP_OUT_BYTE;
		}
		
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			SOCK_TCP_OUT_BYTE_ARY;
		}
		
		method : public : ReadByte() ~ Byte {
			SOCK_TCP_IN_BYTE;
		}
		
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			SOCK_TCP_IN_BYTE_ARY;
		}
		
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			SOCK_TCP_IN_BYTE_ARY;
		}
		
		method : public : WriteString(str : System.String) ~ Nil {
			WriteString(str->ToCharArray());
		}

		method : WriteString(buffer : Char[]) ~ Nil {
			SOCK_TCP_OUT_STRING;
		}
		
		method : public : native : ReadString() ~ System.String {
			buffer : Char[] := Char->New[256];
			ReadString(buffer);
			return System.String->New(buffer);
		}

		method : ReadString(buffer : Char[]) ~ Nil {
			SOCK_TCP_IN_STRING;
		}

		function : HostName() ~ String {
			SOCK_TCP_HOST_NAME;
		}
	}	
}

#------------ Introspection ------------#
bundle Introspection {
	class Class {
		@name : String;
		@methods : Method[];
		
		New(name : String) {
			LOAD_CLS_BY_NAME;
		}
		
		method : public : IsLoaded() ~ Bool {
			return @methods <> Nil;
		}
		
		method : public : GetName() ~ String {
			return @name;
		}
		
		method : public : GetMethods() ~ Method[] {
			return @methods;
		}
		
		method : public : GetMethodNumber() ~ Int {
			return @methods->Size();
		}
	}
	
	class Method {
		@native_mthd_ptr : Int;
		@cls : Class;
		@name : String;
		@parameters : DataType[];
		@rtrn_type  : DataType;
	
		method : public : GetClass() ~ Class {
			return @cls;
		}

		method : public : GetName() ~ String {
			return @name;
		}
		
		method : public : GetParameters() ~ DataType[] {
			return @parameters;
		}
		
		method : public : GetReturn() ~ DataType {
			return @rtrn_type;
		}
	}
	
	class DataType {
		@type  : TypeId;
		@cls_name : String;
		@dimension : Int;
		
		method : public : GetType() ~ TypeId {
			return @type;
		}
		
		method : public : GetDimension() ~ Int {
			return @dimension;
		}
		
		method : public : GetClassName() ~ String {
			return @cls_name;
		}
	}
	
	enum TypeId := -1000 {
		BOOL,
		BYTE,
		CHAR,
		INT,
		FLOAT,
		CLASS,
		FUNC
	}	
}	
