#~~
# Objeck system classes.
# Copyright (c) 2012 Randy Hollines
#
# New regular expression engine
~~#

use Struct;

bundle RegEx {
	# ---------- sub-expression ----------
	class Expression {
		@type : ExpressionType;
		@value : Char;
		@char_class : String;
		@expression : Expression;
		@left : Vector;
		@right : Vector;
		
		New() {
			@type := ExpressionType->ANY;
		}

		New(value : Char) {
			@type := ExpressionType->CHAR;
			@value := value;
		}

		New(char_class : String, is_range : Bool) {
			if(is_range) {
				@type := ExpressionType->CHAR_CLASS_RANGE;
			}
			else {
				@type := ExpressionType->CHAR_CLASS;
			};
			@char_class := char_class;
		}
		
		New(left : Vector) {
			@type := ExpressionType->SUB_EXPR;
			@left := left;
		}
		
		New(type : ExpressionType) {
			@type := type;
		}
		
		New(type : ExpressionType, expression : Expression) {
			@type := type;
			@expression := expression;
		}

		New(left : Vector, right : Vector) {
			@type := ExpressionType->OR;
			@left := left;
			@right := right;
		}

		method : public : GetType() ~ ExpressionType {
			return @type;
		}
		
		method : public : GetValue() ~ Char {
			return @value;
		}

		method : public : GetClass() ~ String {
			return @char_class;
		}
		
		method : public : GetLeft() ~ Vector {
			return @left;
		}
		
		method : public : GetRight() ~ Vector {
			return @right;
		}
		
		method : public : GetExpression() ~ Expression {
			return @expression;
		}
	}

	enum ExpressionType := -100 {
		CHAR,
		ANY,
		OPTIONAL,
		ZERO_MORE,
		ONE_MORE,		
		OR,
		CHAR_CLASS,
		CHAR_CLASS_RANGE,
		ENDS_ANCHOR,
		STARTS_ANCHOR,
		SUB_EXPR
	}
		
	# ---------- match types ----------
	enum EvalType := -200 {
		MATCH,
		MATCH_NEXT,
		NO_MATCH
	}
	
	class RegExParser {
		# parser
		@tokens : Char[];
		@token_pos : Int;
		@token : Char;		
		@expressions : Vector;
		@error : String;
		@starts_anchor : Bool;
		# evaluation
		@input : Char[];
		@input_pos : Int;
		@input_char : Char;
		@is_exact : Bool;
		
		New(input : String) {
			@tokens := input->ToCharArray();
			@expressions := Vector->New();
			
			Parse();
		}

		# ---------- regex evaluation ----------
		
		method : public : MatchExact(input : String) ~ Bool {
			return Evaluate(input, 0) > -1 & @is_exact;
		}

		method : public : Match(input : String) ~ String {
			return Match(input, 0);
		}
		
		method : public : Match(input : String, offset : Int) ~ String {
			right := Evaluate(input, 0);
			if(right > -1) {
				return input->SubString(offset, right - offset);
			};
			
			return "";
		}

		method : public : native : FindFirst(input : String) ~ String {
			matches := Vector->New();
			left := 0;
			while(left < input->Size()) {
				right := Evaluate(input, left);
				if(right > -1) {
					return input->SubString(left, right - left);
				};
				left += 1;
			};

			return "";
		}

		method : public : native : Find(input : String) ~ Vector {
			matches := Vector->New();
			left := 0;
			while(left < input->Size()) {
				right := Evaluate(input, left);
				if(right > -1 & left <> right) {
# IO.Console->Print("\t=== left=")->Print(left)->Print(", right=")->Print(right)->PrintLine(" ===");
					matches->AddBack(input->SubString(left, right - left));
					left += right - 1;
				};
				left += 1;
			};

			return matches;
		}

		method : public : native : ReplaceFirst(input : String, replace : String) ~ String {
			left := 0;
			while(left < input->Size()) {
				right := Evaluate(input, left);
				if(right > -1 & left <> right) {
					# identify start and end of input string
					start := input->SubString(left);
					end := input->SubString(right, input->Size() - right);
					# insert the replacement string
					input := String->New(start);
					input->Append(replace);
					input->Append(end);	
					
					return input;
				};
				left += 1;
			};

			return input;
		}

		method : public : native : ReplaceAll(input : String, replace : String) ~ String {
			left := 0;
			while(left < input->Size()) {
				right := Evaluate(input, left);
				if(right > -1 & left <> right) {
					# identify start and end of input string
					start := input->SubString(left);
					end := input->SubString(right, input->Size() - right);
					# insert the replacement string
					input := String->New(start);
					input->Append(replace);
					input->Append(end);	
					# update search index
					left += replace->Size() - 1;
				};
				left += 1;
			};

			return input;
		}

		method : native : Evaluate(input : String, offset : Int) ~ Int {
			if(@error <> Nil) {
				@error->PrintLine();
				return -1;
			};

			if(offset >= input->Size()) {
				return -1;
			};
			
			@is_exact := false;
			@input_pos := offset;			
			@input := input->ToCharArray();
			NextInput();
			
			# evaluate and check final position
			match := Evaluate(@expressions);

# IO.Console->Print("@@@ pos=")->Print(@input_pos)->Print(", match=")->Print(match)->Print(", end=")->PrintLine(@input_char);

			if(match & @input_char <> '\0') {
				return @input_pos - 1;
			}
			else if(match) {
				@is_exact := true;
				return @input_pos;
			};
			
			return -1;
		}
		
		method : private : NextInput() ~ Nil {
			if(@input_pos < @input->Size()) {
				@input_char := @input[@input_pos];
				@input_pos += 1;
			}
			else {
				@input_char := '\0';
			};
		}	
		
		method : private : Evaluate(expressions : Vector) ~ Bool {
			each(i : expressions) {
				next : Expression;
				if(i + i < expressions->Size()) {
					next := expressions->Get(i + 1);
				};
					
				result := Evaluate(expressions->Get(i)->As(Expression), next);
				if(result = false) {
					return false;
				};
			};
			
			return true;
		}

		method : private : InRange(char_class : String, check : Char) ~ Bool {
			return char_class->Get(0) <= check & char_class->Get(2) >= check;
		}

		method : private : InClass(char_class : String, check : Char) ~ Bool {
			for(i := 0; i < char_class->Size(); i += 1;) {
				if(char_class->Get(i) = check) {
					return true;
				};
			};
			
			return false;
		}
		
		method : native : Evaluate(expression : Expression, next : Expression) ~ Bool {
			if(expression <> Nil) {
				if(expression->GetType() = ExpressionType->SUB_EXPR) {
					Evaluate(expression->GetLeft());
				}
				else {
					select(expression->GetType()) {
						#
						# single character
						#
						label ExpressionType->CHAR: {
IO.Console->Print("[### matching: expr='")->Print(expression->GetValue())->Print("', input='")->Print(@input_char)->PrintLine("' ###]");
							if(expression->GetValue() = @input_char) {
								NextInput();
								return true;
							};
						}
		
						#
						# any character
						#
						label ExpressionType->ANY: {
"[### any ###]"->PrintLine();
							NextInput();
							return true;							
						}

						#
						# class of characters
						#
						label ExpressionType->CHAR_CLASS: {
							char_class := expression->GetClass();
# IO.Console->Print("[### matching range: expr='")->Print(expression->GetClass())->Print("', input='")->Print(@input_char)->PrintLine("' ###]");
							if(InClass(char_class, @input_char)) {
								NextInput();
								return true;
							};
						}

						#
						# range of characters
						#
						label ExpressionType->CHAR_CLASS_RANGE: {
							char_class := expression->GetClass();
							if(InRange(char_class, @input_char)) {
								NextInput();
								return true;
							};
						}

						#
						# logical OR
						#
						label ExpressionType->OR: {
# "[### or ###]"->PrintLine();
							last := @input_pos - 1;
							if(Evaluate(expression->GetLeft()) = false) {
								@input_pos := last;
								NextInput();
								if(Evaluate(expression->GetRight())) {
									return true;
								};
							};

							return true;
						}
		
						#
						# zero or more
						#
						label ExpressionType->ZERO_MORE: {
"[### zero_or_more ###]"->PrintLine();
							type := expression->GetExpression()->GetType();
							if(type = ExpressionType->CHAR) {
								test := expression->GetExpression()->GetValue();
								while(test = @input_char) {
									NextInput();
								};
							}
							else if(type = ExpressionType->CHAR_CLASS_RANGE) {
								char_class := expression->GetExpression()->GetClass();
# IO.Console->Print("[### matching zero_or_more: range='")->Print(char_class)->Print("', input='")->Print(@input_char)->PrintLine("' ###]");
								while(InRange(char_class, @input_char)) {
									NextInput();	
								};
							}
							else if(type = ExpressionType->CHAR_CLASS) {
								char_class := expression->GetExpression()->GetClass();
# IO.Console->Print("[### matching zero_or_more: class='")->Print(char_class)->Print("', input='")->Print(@input_char)->PrintLine("' ###]");
								while(InClass(char_class, @input_char)) {
									NextInput();
								};
							}
							else if(type = ExpressionType->ANY) {
								if(next = Nil) {
									return false;
								};
								
								while(@input_char <> '\0' & Evaluate(next, Nil) = false) {
									NextInput();
								};
								
								# backup to previous character, if we're not at the end
								if(@input_char <> '\0') {
									@input_pos -= 2;
									NextInput();
								};								
							};	

							return true;
						}
		
						#
						# one or more
						#
						label ExpressionType->ONE_MORE: {
# "[### one_or_more ###]"->PrintLine();
							type := expression->GetExpression()->GetType();
							if(type = ExpressionType->CHAR) {
								test := expression->GetExpression()->GetValue();
								if(test = @input_char) {
									NextInput();
									while(test = @input_char) {
										NextInput();
									};
	
									return true;
								};
							}
							else if(type = ExpressionType->CHAR_CLASS_RANGE) {
								char_class := expression->GetExpression()->GetClass();
								if(InRange(char_class, @input_char)) {
									NextInput();
									while(InRange(char_class, @input_char)) {
										NextInput();
									};
	
									return true;
								};
							}
							else if(type = ExpressionType->CHAR_CLASS) {
								char_class := expression->GetExpression()->GetClass();
								if(InClass(char_class, @input_char)) {
									NextInput();
									while(InClass(char_class, @input_char)) {
										NextInput();
									};
	
									return true;
								};
							}
							else if(type = ExpressionType->ANY) {
								if(next = Nil) {
									return false;
								};
								
								if(@input_char <> '\0') {
									NextInput();
									while(@input_char <> '\0' & Evaluate(next, Nil) = false) {
										NextInput();
									};

									# backup to previous character, if we're not at the end
									if(@input_char <> '\0') {
										@input_pos -= 2;
										NextInput();
									};

									return true;
								};								
							};
						}
						
						#
						# single optional
						#
						label ExpressionType->OPTIONAL: {
# "[### optional ###]"->PrintLine();
							type := expression->GetExpression()->GetType();
							if(type = ExpressionType->CHAR) {
								test := expression->GetExpression()->GetValue();
								if(test = @input_char) {
									NextInput();
								};

								return true;
							}
							else if(type = ExpressionType->CHAR_CLASS_RANGE) {
								char_class := expression->GetExpression()->GetClass();
								if(InRange(char_class, @input_char)) {
									NextInput();
								};
			
								return true;
							}
							else if(type = ExpressionType->CHAR_CLASS) {
								char_class := expression->GetExpression()->GetClass();
								if(InClass(char_class, @input_char)) {
									NextInput();
								};
			
								return true;
							};
								
								
							# TODO: support any
						}
						
						#
						# starts anchor
						#
						label ExpressionType->STARTS_ANCHOR: {
# "[### starts anchor ###]"->PrintLine();							
							if(@input_pos - 1 = 0 & Evaluate(expression->GetExpression(), Nil)) {
								return true;				
							};
						}
						
						#
						# ends anchor
						#
						label ExpressionType->ENDS_ANCHOR: {
# "[### ends anchor ###]"->PrintLine();
							if(Evaluate(expression->GetExpression(), Nil) & @input_char = '\0') {
								return true;				
							};
						}
					};
				};
			};

			return false;
		}

		#----------- expression parsing -----------

		method : private : NextToken() ~ Nil {
			if(@token_pos < @tokens->Size()) {
				@token := @tokens[@token_pos];
				@token_pos += 1;
			}
			else {
				@token := '\0';
			};
		}	

		method : private : Parse() ~ Nil {
			NextToken();
			Binary();
			
			if(@starts_anchor) {
				@error := "orphan anchor token";
			};
		}	
		
		method : private : Binary() ~ Nil {
			while(@token <> '\0' & @token <> ')' & @token <> '|') {
				Unary();		
				if(@error <> Nil) {
					return;
				};

				if(@starts_anchor & @expressions->Size() > 0) {
					expression := @expressions->RemoveBack()->As(Expression);
					@expressions->AddBack(Expression->New(ExpressionType->STARTS_ANCHOR, expression));
					@starts_anchor := false;
# IO.Console->PrintLine("match: starts anchor");	
				};
			};
			
			if(@token = '|') {
				NextToken();				
				
				left := @expressions;
				@expressions := Vector->New();
				
				Binary();
				if(@error <> Nil) {
					return;
				};
				
				right := @expressions;
				@expressions := Vector->New();
				
				@expressions->AddBack(Expression->New(left, right));
# IO.Console->PrintLine("match: or_match");					
			};
		}

		method : private : Unary() ~ Nil {
			Value();
			if(@error <> Nil) {
				return;
			};

			if(@token = '*') {
				if(@expressions->Size() > 0) {
					expression := @expressions->RemoveBack()->As(Expression);
					@expressions->AddBack(Expression->New(ExpressionType->ZERO_MORE, expression));
					NextToken();
# IO.Console->PrintLine("match: zero_or_more");					
				}
				else {
					@error := "missing left-hand side operand";
					return;
				};
			}
			else if(@token = '+') {
				if(@expressions->Size() > 0) {
					expression := @expressions->RemoveBack()->As(Expression);
					@expressions->AddBack(Expression->New(ExpressionType->ONE_MORE, expression));
					NextToken();
# IO.Console->PrintLine("match: one_or_more");					
				}
				else {
					@error := "missing left-hand side operand";
					return;
				};
			}
			else if(@token = '?') {
				if(@expressions->Size() > 0) {
					expression := @expressions->RemoveBack()->As(Expression);
					@expressions->AddBack(Expression->New(ExpressionType->OPTIONAL, expression));
					NextToken();
# IO.Console->PrintLine("match: optional");					
				}
				else {
					@error := "missing left-hand side operand";
					return;
				};
			}
			else if(@token = '$') {
				if(@expressions->Size() > 0) {
					expression := @expressions->RemoveBack()->As(Expression);
					@expressions->AddBack(Expression->New(ExpressionType->ENDS_ANCHOR, expression));
					NextToken();
# IO.Console->PrintLine("match: ends anchor");				
				}
				else {
					@error := "missing left-hand side operand";
					return;
				};
			};
		}

		method : private : Value() ~ Nil {
			if(@token = '(') {
				Parentheses();				
			}
			else if(@token = '[') {
				CharacterClass();
			}
			else if(@token = '\\') {
				EscapeCharacter();
# "char: escaped"->PrintLine();
			}			
			else if(@token = '.') {
				@expressions->AddBack(Expression->New());
# "match: any"->PrintLine();			
				NextToken();
			}
			else if(@token = '^') {
				@starts_anchor := true;
				NextToken();
			}			
			else {
				@expressions->AddBack(Expression->New(@token));
# IO.Console->Print("match: char=")->PrintLine(@token);				
				NextToken();
			};
		}
		
		method : private : CharacterClass() ~ Nil {	
			NextToken();

			if(@token->IsChar() = false & @token->IsDigit() = false) {
				@error := "invalid character class";
			};
			
			start := @token_pos - 1;
			hyphen_count := 0;
			while(@token <> '\0' & @token <> ']' & (@token = '-' | @token->IsChar() | @token->IsDigit())) { 
				if(@token = '-') {
					hyphen_count += 1;
				};
				NextToken();
			};
			end := @token_pos - 1;
			char_class := String->New(@tokens, start, end - start);

			if(@token <> ']') {
				@error := "expected ')'";
				return;
			};
			NextToken();
			
			if(hyphen_count > 1) {
				@error := "invalid character class";
			};

			is_range := false;
			if(hyphen_count = 1) {
				if(char_class->Size() <> 3) {
					@error := "invalid character class";
					return; # to avoid an issue with next statement
				};
				
				if(char_class->Get(0) >= char_class->Get(2)) {
					@error := "invalid character class";
				};

				is_range := true;				
			};

# IO.Console->Print("match range: class=")->PrintLine(char_class);
			
			@expressions->AddBack(Expression->New(char_class, is_range));
		}

		method : private : EscapeCharacter() ~ Nil {
			NextToken();
			select(@token) {
				label '|':
				label '.':
				label '?':
				label '^':
				label '$': 
				label '*':
				label '+': {
					@expressions->AddBack(Expression->New(@token));
					NextToken();
				}

				label 'n': {
					@expressions->AddBack(Expression->New('\n'));
					NextToken();
				}

				label 'r': {
					@expressions->AddBack(Expression->New('\r'));
					NextToken();
				}

				label 'b': {
					@expressions->AddBack(Expression->New('\b'));
					NextToken();
				}

				label 't': {
					@expressions->AddBack(Expression->New('\t'));
					NextToken();
				}

				label '\\': {
					@expressions->AddBack(Expression->New('\\'));
					NextToken();
				}
			};
		}

		method : private : Parentheses() ~ Nil {
			NextToken();
			
			left := @expressions;
			@expressions := Vector->New();
				
			Binary();
			if(@error <> Nil) {
				return;
			};
		
			if(@token <> ')') {
				@error := "expected ')'";
				return;
			};
			NextToken();
			
			# combine lists			
			left->AddBack(@expressions);
			@expressions := left;
			
# IO.Console->PrintLine("parentheses");		
		}
	}
}
