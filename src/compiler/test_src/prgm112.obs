use IO;

bundle Default {
	enum Token := -32 {
		ZERO_MORE,
		ONE_MORE,
		SEQUENCE,
		ALTERNATION,
		OPRN,
		CPRN,
		STOP
	}

	class Postfix {
		@input : String;
		@index : Int;
		@char : Char;
		@input_stack : Int[];
		@input_index : Int;
		@error : String;

		New(input : String) {
			@input := input;
			@index := 0;
			@input_stack := Int->New[256];
			@input_index := 0;
		}

		method : Push(value : Int) ~ Nil {
			@input_stack[@input_index] := value;
			@input_index += 1;
		}

		method : Next() ~ Nil {
			if(@index < @input->Size()) {
				@char := @input->Get(@index);
				@index += 1;
			}
			else {
				@char := '\0';
			};
		}

		method : public : Compile() ~ String {
			Parse();
Dump();			
			if(@error = Nil) {
				Emit();

if(@error <> Nil) {				
	@error->PrintLine();
};
			};
			
			return "";
		}
		
		method : Emit() ~ Nil {
			calc_stack := Int->New[256];
			calc_index := 0;
			i := 0;
			c := @input_stack[0];
			emit_index := 0;
			
			while(c <> 0) {
				select(c) {
					label Token->ZERO_MORE: {
						Console->Print(emit_index)->PrintLine(": ZERO_MORE");
						emit_index += 1;
						
						top := calc_stack[calc_index - 1];
						if(top >= 40 & top <= 122) {
							calc_index -= 1;
							match := calc_stack[calc_index];
							
							Console->Print(emit_index)->Print(": MATCH id='")
								->Print(match)->PrintLine("'");
							emit_index += 1;
							
							Console->Print(emit_index)->Print(": JUMP id=")
								->PrintLine(emit_index - 2);
							
							emit_index += 1;	
						}
						else {
							calc_index -= 1;
							match := calc_stack[calc_index];
							if(match = Token->CPRN->As(Int)) {
								calc_index -= 2;
								match := calc_stack[calc_index];
								if(match = Token->OPRN->As(Int)) {
									calc_index -= 1;
									match := calc_stack[calc_index];
								};
								Console->Print(emit_index)->Print(": JUMP id=")->PrintLine(match);
								emit_index += 1;
							}
							else {
								@error := "Invalid expression";
							};
						};
						
						calc_stack[calc_index] := c;
						calc_index += 1;
					}

					label Token->ONE_MORE: {
					}

					label Token->SEQUENCE: {
						top := calc_stack[calc_index - 1];
						if(top >= 40 & top <= 122) {
							calc_index -= 1;
							match := calc_stack[calc_index];
							
							Console->Print(emit_index)->Print(": MATCH id='")
								->Print(match)->PrintLine("'");
							emit_index += 1;
						};
										
						Console->Print(emit_index)->Print(": JUMP id=")->PrintLine(emit_index + 1);
						emit_index += 1;
					}

					label Token->ALTERNATION: {		
					}
					
					label Token->OPRN: {
					
Console->Print("?? ")->PrintLine(calc_index);			
					
						calc_stack[calc_index] := emit_index;
						calc_index += 1;
						
						calc_stack[calc_index] := c;
						calc_index += 1;
					}
					
					label Token->CPRN: {
						calc_stack[calc_index] := c;
						calc_index += 1;
					}
					
					label Token->STOP: {
						calc_index -= 1;
						match := calc_stack[calc_index];			
						if(match = Token->CPRN->As(Int)) {
							calc_index -= 2;
							match := calc_stack[calc_index];
							if(match = Token->OPRN->As(Int)) {
								calc_index -= 1;
							};		
						};
						
						Console->Print(emit_index)->PrintLine(": STOP");
					}
				
					other: {					
						calc_stack[calc_index] := c;
						calc_index += 1;
					}
				};
				# update
				i += 1;
				c := @input_stack[i];	 
			};
			
			Console->Print("calc: id=")->PrintLine(calc_index);
			if(calc_index > 0) {
				@input_stack[calc_index - 1]->PrintLine();
			};
		}
		
		# TODO: validate input
		method : Parse() ~ Nil {
			Next();
			Alternation();
			Push(Token->STOP->As(Int));
		}	

		method : Alternation() ~ Nil {
			Sequence();

			if(@char = '|') {
				Next();
				Sequence();
				Push(Token->ALTERNATION->As(Int));
			};
		}

		method : Sequence() ~ Nil {
			while(@char >= 40 & @char <= 122 & @char <> ')') {
				if(Repetition()) {
					Push(Token->SEQUENCE->As(Int));
				};
			};
		}
		
		method : Repetition() ~ Bool {
			was_pushed := false;
	
			if(@char = '(') {
				Push(Token->OPRN->As(Int));
				Next();
				Alternation();
				if(@char <> ')') {
					@error := "expected ')'";
					return false;
				};
				Push(Token->CPRN->As(Int));
				Next();
			}
			else if(@char <> ')') {
				Push(@char->As(Int));
				was_pushed := true;
				Next();
			};
			
			if(@char = '*') {
				Push(Token->ZERO_MORE->As(Int));
				was_pushed := true;
				Next();
			}
			else if(@char = '+') {
				Push(Token->ONE_MORE->As(Int));
				was_pushed := true;
				Next();
			};
			
			return was_pushed;
		}
		
		method : Dump() ~ Nil {
			i := 0;
			c := @input_stack[0];	 

			while(c <> 0) {
				select(c) {
					label Token->ZERO_MORE: {
						'*'->PrintLine();
					}

					label Token->ONE_MORE: {
						'+'->PrintLine();
					}

					label Token->SEQUENCE: {
						'.'->PrintLine();
					}

					label Token->ALTERNATION: {
						'|'->PrintLine();
					}
					
					label Token->OPRN: {
						'('->PrintLine();
					}
					
					label Token->CPRN: {
						')'->PrintLine();
					}
					
					label Token->STOP: {
						"STOP"->PrintLine();
					}
				
					other: {
						v := c->As(Char);
						v->PrintLine();
					}
				};
				i += 1;
				c := @input_stack[i];	 
			};
			"-----"->PrintLine();
		}

		function : Main(args : String[]) ~ Nil {
			if(args->Size() = 1) {
				p := Postfix->New(args[0]);
				p->Compile();
			};
		}
	}
}
