use Struct;

bundle Default {
	class Node {
		@value : Int;
		@left : Node;
		@right : Node;
		
		New() {
			@value := -1;
		}
	
		New(value : Int) {
			@value := value;
		}
		
		method : public : GetValue() ~ Int {
			return @value;
		}
		
		method : public : SetLeft(left : Node) ~ Nil {
			@left := left;
		}
		
		method : public : GetLeft() ~ Node {
			return @left;
		}
		
		method : public : SetRight(right : Node) ~ Nil {
			@right := right;
		}
		
		method : public : GetRight() ~ Node {
			return @right;
		}
	}
	
	class RegEx {
		@working : Stack;
		@input : String;
		@input_pos : Int;
		
		function : Main(args : String[]) ~ Nil {
			# 1st sub-expression
			n0 := Node->New();
			n1 := Node->New('a');
			n2 := Node->New('b');
			n3 := Node->New();
			
			# 2nd sub-expression
			n4 := Node->New('c');
			n5 := Node->New();
			
			# combine
			n0->SetLeft(n1);
			n0->SetRight(n2);
			n1->SetLeft(n3);
			n2->SetLeft(n3);
			n3->SetLeft(n4);
			n4->SetLeft(n5);
			
			# evaluate
			regEx := RegEx->New(args[0]);
			regEx->Eval(n0);
			IO.Console->Print("end pos: ")->PrintLine(regEx->GetEndPos());
		}
		
		New(input : String) {
			@input := input;
			@working := Stack->New();
		}
		
		method : Eval(node : Node) ~ Nil {
			if(node = Nil) {
				"no match"->PrintLine();
				return;
			};
			
			if(node->GetLeft() <> Nil) {
				# split node
				if(node->GetRight() <> Nil) {
					"split"->PrintLine();
					@working->Push(node->GetRight());
					Eval(node->GetLeft());
				}
				# character match node
				else if(node->GetValue() <> -1) {
					if(node->GetValue()->As(Char) = @input->Get(@input_pos)) {
						IO.Console->Print("match: ")->PrintLine(node->GetValue()->As(Char));
						@input_pos += 1;
						Eval(node->GetLeft());
					}
					else {
						Eval(@working->Pop()->As(Node));
					};
				}
				# transient node 
				else if(node->GetValue() = -1) {
					Eval(node->GetLeft());
				};
			};
		}
		
		method : public : GetEndPos() ~ Int {
			return @input_pos;
		}
	}
}
