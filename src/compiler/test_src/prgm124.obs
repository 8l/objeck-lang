use Struct;

bundle Default {
	enum ExpressionType := -100 {
		CHAR_MATCH,
		ANY_MATCH,
		OR_MATCH,
		ZERO_MORE,
		ONE_MORE
	}
	
	class Expression {
		@type : ExpressionType;
		@value : Char;
		@left : Expression;
		@right : Expression;

		New(value : Char) {
			@type := ExpressionType->CHAR_MATCH;
			@value := value;
		}

		New(type : ExpressionType, left : Expression) {
			@type := type;
			@left := left;
		}

		New(left : Expression, right : Expression) {
			@type := ExpressionType->OR_MATCH;
			@left := left;
			@right := right;
		}

		method : public : GetType() ~ ExpressionType {
			return @type;
		}
	}
	
	class RegExParser {
		@tokens : Char[];
		@token : Char;
		@token_pos : Int;
		@expressions : Vector;
		@error : String;
		
		New(input : String) {
			@tokens := input->ToCharArray();
			@expressions := Vector->New();
			
			NextToken();
			Parse();
Dump();
		}

		method : private : Dump() ~ Nil {
			if(@error <> Nil) {
				@error->PrintLine();
			}
			else {
				"-------------"->PrintLine();
				each(i : @expressions) {
					select(@expressions->Get(i)->As(Expression)->GetType()) {
						label ExpressionType->CHAR_MATCH: {
							"-match-"->PrintLine();
						}
	
						label ExpressionType->ANY_MATCH: {
							"-any-"->PrintLine();
						}
	
						label ExpressionType->OR_MATCH: {
							"-or-"->PrintLine();
						}
	
						label ExpressionType->ZERO_MORE: {
							"-0 or more-"->PrintLine();
						}
	
						label ExpressionType->ONE_MORE: {
							"-1 or more-"->PrintLine();
						}
					};
				};
			};
		}
		
		method : private : Compile() ~ Nil {
			if(@expressions->Size() > 0) {

			};
		}

		method : private : NextToken() ~ Nil {
			if(@token_pos < @tokens->Size()) {
				@token := @tokens[@token_pos];
				@token_pos += 1;
			}
			else {
				@token := '\0';
			};
		}

		method : private : Parse() ~ Nil {
			Binary();
		}		
		
		method : private : Binary() ~ Nil {
			while(@token <> '\0' & @token <> ')') {
				while(@token <> '\0' & @token <> ')' & @token <> '|') {
					Unary();		
					if(@error <> Nil) {
						return;
					};
				};
				
				if(@token = '|') {
					NextToken();
IO.Console->PrintLine("match: or_match");					
					
					while(@token <> '\0' & @token <> ')' & @token <> '|') {
						Unary();						
						if(@error <> Nil) {
							return;
						};
					};
					
					left := @expressions->RemoveBack()->As(Expression);
					right := @expressions->RemoveBack()->As(Expression);
					@expressions->AddBack(Expression->New(left, right));
				};
			};
		}

		method : private : Unary() ~ Nil {
			Value();
			if(@error <> Nil) {
				return;
			};

			if(@token = '*') {
				if(@expressions->Size() > 0) {
					expression := @expressions->RemoveBack()->As(Expression);
					@expressions->AddBack(Expression->New(ExpressionType->ZERO_MORE, expression));
IO.Console->PrintLine("match: zero_or_more");
					NextToken();
				}
				else {
					@error := "missing left-hand side operand";
					return;
				};
			}
			else if(@token = '+') {
				if(@expressions->Size() > 0) {
					expression := @expressions->RemoveBack()->As(Expression);
					@expressions->AddBack(Expression->New(ExpressionType->ONE_MORE, expression));
IO.Console->PrintLine("match: one_or_more");
					NextToken();
				}
				else {
					@error := "missing left-hand side operand";
					return;
				};
			};
		}

		method : private : Value() ~ Nil {
			if(@token->IsChar() | @token->IsDigit()) {
				@expressions->AddBack(Expression->New(@token));
IO.Console->Print("match: char=")->PrintLine(@token);
				NextToken();
			}
			else if(@token = '(') {
				Parentheses();				
			}
			else {
				@error := "invalid value";
				return;
			};
		}
	
		method : private : Parentheses() ~ Nil {
			NextToken();					
			Binary();
			if(@error <> Nil) {
				return;
			};
		
			if(@token <> ')') {
				@error := "expected ')'";
				return;
			};
			NextToken();
IO.Console->PrintLine("parentheses");		
		}	
	}
	
	class Test {
		function : Main(args : String[]) ~ Nil {
			if(args->Size() = 1) {
				regex := RegExParser->New(args[0]);
			};
		}
	}


}
