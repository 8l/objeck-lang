use Struct;

bundle Default {
	class Test {
		function : Main(args : String[]) ~ Nil {
			if(args->Size() = 2) {
				regex := RegExParser->New(args[0]);
				regex->Evaluate(args[1])->PrintLine();
			};
		}
	}
	
	enum ExpressionType := -100 {
		CHAR,
		ANY,
		OPTIONAL,
		ZERO_MORE,
		ONE_MORE,		
		OR,
		SUB
	}
	
	class Expression {
		@type : ExpressionType;
		@value : Char;
		@expression : Expression;
		@left : Vector;
		@right : Vector;
		
		New() {
			@type := ExpressionType->ANY;
		}

		New(value : Char) {
			@type := ExpressionType->CHAR;
			@value := value;
		}
		
		New(left : Vector) {
			@type := ExpressionType->SUB;
			@left := left;
		}
		
		New(type : ExpressionType, expression : Expression) {
			@type := type;
			@expression := expression;
		}

		New(left : Vector, right : Vector) {
			@type := ExpressionType->OR;
			@left := left;
			@right := right;
		}

		method : public : GetType() ~ ExpressionType {
			return @type;
		}
		
		method : public : GetValue() ~ Char {
			return @value;
		}
		
		method : public : GetLeft() ~ Vector {
			return @left;
		}
		
		method : public : GetRight() ~ Vector {
			return @right;
		}
		
		method : public : GetExpression() ~ Expression {
			return @expression;
		}
	}
	
	enum EvalType := -200 {
		MATCH,
		MATCH_NEXT,
		NO_MATCH
	}
	
	class RegExParser {
		# parser variables
		@tokens : Char[];
		@token_pos : Int;
		@token : Char;		
		@expressions : Vector;
		@error : String;
		# evaluation variables
		@input : Char[];
		@input_pos : Int;
		@input_char : Char;
		
		New(input : String) {
			@tokens := input->ToCharArray();
			@expressions := Vector->New();
			
			NextToken();
			Parse();
# Dump();
		}
		
		method : private : PrintSpace(depth : Int) ~ Nil {
			for(i := 0; i < depth; i += 1;) {
				"  "->Print();
			};
		}

		method : private : Dump(expression : Expression, depth : Int) ~ Nil {
			if(expression <> Nil) {
				if(expression->GetType() = ExpressionType->SUB) {
					Dump(expression->GetLeft(), depth + 1);
				}
				else {
					
					
					select(expression->GetType()) {
						label ExpressionType->CHAR: {
							PrintSpace(depth); IO.Console->Print("[=== match: token='")
								->Print(expression->GetValue())->PrintLine("' ===]");
						}
		
						label ExpressionType->ANY: {
							PrintSpace(depth); "[=== match: any"->PrintLine();
						}

						label ExpressionType->OR: {
							PrintSpace(depth); "[=== or ===]"->PrintLine();
							
							PrintSpace(depth + 2); "[--- left ---]"->PrintLine();
							Dump(expression->GetLeft(), depth + 3);
							
							PrintSpace(depth + 2); "[--- right ---]"->PrintLine();
							Dump(expression->GetRight(), depth + 3);
						}
		
						label ExpressionType->ZERO_MORE: {
							PrintSpace(depth); "[=== zero or more ===]"->PrintLine();
							Dump(expression->GetExpression(), depth + 2);
						}
		
						label ExpressionType->ONE_MORE: {
							PrintSpace(depth); "[=== one or more ===]"->PrintLine();
							Dump(expression->GetExpression(), depth + 2);
						}

						label ExpressionType->OPTIONAL: {
							PrintSpace(depth); "[=== optional ===]"->PrintLine();
							Dump(expression->GetExpression(), depth + 2);
						}
					};
				};
			};	
		}
		
		method : private : Dump(expressions : Vector, depth : Int) ~ Nil {
			each(i : expressions) {
				Dump(expressions->Get(i)->As(Expression), depth);
			};
		}

		method : private : Dump() ~ Nil {
			"-------------------"->PrintLine();
			if(@error <> Nil) {
				@error->PrintLine();
			}
			else {
				Dump(@expressions, -1);
			};
		}

		# ----------------------
				
		method : public : Evaluate(input : String) ~ Bool {
			if(@error <> Nil) {
				@error->PrintLine();
				return false;
			};
			
			@input := input->ToCharArray();
			NextInput();
			
			# evaluate and check final position
			match := Evaluate(@expressions);

IO.Console->Print("@@@ pos=")->Print(@input_pos)->Print(", match=")
	->Print(match)->Print(", end=")->PrintLine(@input_char);

			if(match & @input_char <> '\0') {
(@input_pos - 1)->PrintLine();
				return true;
			}
			else if(match) {
@input_pos->PrintLine();
				return true;
			};

			return false;
		}
		
		method : private : NextInput() ~ Nil {
			if(@input_pos < @input->Size()) {
				@input_char := @input[@input_pos];
				@input_pos += 1;
			}
			else {
				@input_char := '\0';
			};
		}	
		
		method : private : Evaluate(expressions : Vector) ~ Bool {
			each(i : expressions) {
				result := Evaluate(expressions->Get(i)->As(Expression));
				if(result = false) {
					return false;
				};
			};
			
			return true;
		}
		
		method : private : Evaluate(expression : Expression) ~ Bool {
			if(expression <> Nil) {
				if(expression->GetType() = ExpressionType->SUB) {
					Evaluate(expression->GetLeft());
				}
				else {
					select(expression->GetType()) {
						label ExpressionType->CHAR: {
IO.Console->Print("[### matching: expr='")->Print(expression->GetValue())
	->Print("', input='")->Print(@input_char)->PrintLine("' ###]");
							if(expression->GetValue() = @input_char) {
								NextInput();
								return true;
							};
						}
		
						label ExpressionType->ANY: {
							NextInput();
							return true;							
						}

						label ExpressionType->OR: {
"[### or ###"->PrintLine();
							last := @input_pos - 1;
							if(Evaluate(expression->GetLeft()) = false) {
"@@@ ALT @@@"->PrintLine();
								@input_pos := last;
								NextInput();
								if(Evaluate(expression->GetRight())) {
									return true;
								};
							};

							return true;
						}
		
						label ExpressionType->ZERO_MORE: {
							test := expression->GetExpression()->GetValue();
IO.Console->Print("[### zero_or_more: expr='")->Print(test)
	->Print("', input='")->Print(@input_char)->PrintLine("' ###]");
							while(test = @input_char) {
IO.Console->Print("\t matching: expr='")->Print(test)
	->Print("', input='")->Print(@input_char)->PrintLine("' ###]");
								NextInput();
							};

							return true;
						}
		
						label ExpressionType->ONE_MORE: {
							test := expression->GetExpression()->GetValue();
IO.Console->Print("[### one_or_more: expr='")->Print(expression->GetValue())
	->Print("', input='")->Print(@input_char)->PrintLine("' ###]");
							if(test = @input_char) {
								NextInput();
								while(test = @input_char) {
IO.Console->Print("\t matching: expr='")->Print(test)
	->Print("', input='")->Print(@input_char)->PrintLine("' ###]");
								NextInput();
								};
	
								return true;
							};
						}
						
						label ExpressionType->OPTIONAL: {
							test := expression->GetExpression()->GetValue();
IO.Console->Print("[### optional: expr='")->Print(test)
	->Print("', input='")->Print(@input_char)->PrintLine("' ###]");
							if(test = @input_char) {
IO.Console->Print("\t matching: expr='")->Print(test)
	->Print("', input='")->Print(@input_char)->PrintLine("' ###]");
								NextInput();
							};

							return true;
						}
					};
				};
			};

			return false;
		}

		#----------- Parsing -----------
		method : private : Parse() ~ Nil {
			Binary();
		}	

		method : private : NextToken() ~ Nil {
			if(@token_pos < @tokens->Size()) {
				@token := @tokens[@token_pos];
				@token_pos += 1;
			}
			else {
				@token := '\0';
			};
		}	
		
		method : private : Binary() ~ Nil {
			while(@token <> '\0' & @token <> ')' & @token <> '|') {
				Unary();		
				if(@error <> Nil) {
					return;
				};
			};
			
			if(@token = '|') {
				NextToken();				
				
				left := @expressions;
				@expressions := Vector->New();
				
				Binary();
				if(@error <> Nil) {
					return;
				};
				
				right := @expressions;
				@expressions := Vector->New();
				
				@expressions->AddBack(Expression->New(left, right));
IO.Console->PrintLine("match: or_match");					
			};			
		}

		method : private : Unary() ~ Nil {
			Value();
			if(@error <> Nil) {
				return;
			};

			if(@token = '*') {
				if(@expressions->Size() > 0) {
					expression := @expressions->RemoveBack()->As(Expression);
					@expressions->AddBack(Expression->New(ExpressionType->ZERO_MORE, expression));
					NextToken();
IO.Console->PrintLine("match: zero_or_more");					
				}
				else {
					@error := "missing left-hand side operand";
					return;
				};
			}
			else if(@token = '+') {
				if(@expressions->Size() > 0) {
					expression := @expressions->RemoveBack()->As(Expression);
					@expressions->AddBack(Expression->New(ExpressionType->ONE_MORE, expression));
					NextToken();
IO.Console->PrintLine("match: one_or_more");					
				}
				else {
					@error := "missing left-hand side operand";
					return;
				};
			}
			else if(@token = '?') {
				if(@expressions->Size() > 0) {
					expression := @expressions->RemoveBack()->As(Expression);
					@expressions->AddBack(Expression->New(ExpressionType->OPTIONAL, expression));
					NextToken();
IO.Console->PrintLine("match: optional");					
				}
				else {
					@error := "missing left-hand side operand";
					return;
				};
			};
		}

		method : private : Value() ~ Nil {
			if(@token->IsChar() | @token->IsDigit()) {
				@expressions->AddBack(Expression->New(@token));
IO.Console->Print("match: char=")->PrintLine(@token);				
				NextToken();
			}
			else if(@token = '(') {
				Parentheses();				
			}
			else if(@token = '.') {
				@expressions->AddBack(Expression->New());
"match: any"->PrintLine();			
				NextToken();
			}			
			else {
				@error := "invalid value";
				return;
			};
		}
	
		method : private : Parentheses() ~ Nil {
			NextToken();

@expressions->Size()->PrintLine();

			left := @expressions;
			@expressions := Vector->New();
				
			Binary();
			if(@error <> Nil) {
				return;
			};
		
			if(@token <> ')') {
				@error := "expected ')'";
				return;
			};
			NextToken();
			
			# combine lists			
			left->AddBack(@expressions);
			@expressions := left;
			
IO.Console->PrintLine("parentheses");		
		}	
	}
}
