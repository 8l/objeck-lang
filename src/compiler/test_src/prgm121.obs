use IO;
use Struct;

bundle Default {
	class PageParser  {
		@index : Int;
		@page : String;
		@page_chars : Char[];
		@cur_char : Char;
		@nxt_char : Char;
		@nxt_nxt_char : Char;
		@html : String;
		@tag_stack : Stack;

		New(page : String) {
			if(page <> Nil) {
				@page := page;
				@page_chars := page->ToCharArray();
				@index := -1;
				@html := String->New();
				@tag_stack := Stack->New();
				NextChar();
			};
		}

		method : NextChar() ~ Nil {
			@index += 1;
			if(@index < @page_chars->Size()) {
				@cur_char := @page_chars[@index];
				if(@index + 1 < @page_chars->Size()) {
					@nxt_char := @page_chars[@index + 1];
					if(@index + 2 < @page_chars->Size()) {
						@nxt_nxt_char := @page_chars[@index + 2];
					}
					else {	
						@nxt_nxt_char := '\0';
					};
				}
				else {	
					@nxt_char := '\0';
				};
			}
			else {
				@cur_char := '\0';
			};
		}

		method : public : Parse() ~ Nil {
			if(@page_chars = Nil) {
				return;
			};

			tag_start := false;
			while(@cur_char <> '\0') {
				# end tag
				if(@cur_char = '<' & @nxt_char = '/' & @nxt_nxt_char = '#') {
					EndTag();
					tag_start := false;
				}
				# start tag
				else if(@cur_char = '<' & @nxt_char = '#') {
					StartTag();
					tag_start := true;
				}
				else if(tag_start & @cur_char = '/' & @nxt_char = '>') {
					UnaryEndTag();
					tag_start := false;
				}
				# html markup
				else {
					if(tag_start <> true) {
						@html->Append(@cur_char);
					};
					NextChar();	
				};
			};
@cur_char->Print('\n');
@html->PrintLine();
			if(@tag_stack->Size() = 0) {
				"OK"->PrintLine();
			}
			else {
				Console->Print("ERROR: size=")->PrintLine(@tag_stack->Size());
			};
		}

		method : UnaryEndTag() ~ Nil {
			NextChar();	NextChar();	
			top_tag := @tag_stack->Top()->As(Tag);
			if(top_tag->GetType() <> TagType->START) {
				"Expected starting tag..."->PrintLine();
				Runtime->Exit(1);
			};
			@tag_stack->Pop();
"ending unary tag "->PrintLine();
		}

		method : EndTag() ~ Nil {
			NextChar();	NextChar();	NextChar();	
			start := @index;
			while(@cur_char <> '>') {
				NextChar();	
			};
			end := @index;

			top_tag := @tag_stack->Top()->As(Tag);
			name := @page->SubString(start, end -start);
			if(top_tag->GetType() <> TagType->START | top_tag->GetName()->Equals(name) = false) {
				"Expected starting tag..."->PrintLine();
				Runtime->Exit(1);
			};
			@tag_stack->Pop();
Console->Print("ending tag: '")->Print(name)->PrintLine("'");
			NextChar();	
		}

		method : StartTag() ~ Nil {
			NextChar();	NextChar();	
			start := @index;
			while(@cur_char <> ' ' & @cur_char <> '>') {
				NextChar();	
			};
			end := @index;
			name := @page->SubString(start, end -start);
			@tag_stack->Push(Tag->New(TagType->START, name));
Console->Print("starting tag: '")->Print(name)->PrintLine("'");
		}

		function : Main(args : String[]) ~ Nil {
			if(args->Size() = 1) {
				parser := PageParser->New(FileReader->ReadFile(args[0]));
				parser->Parse();
			};
		}	
	}

	enum TagType {
		START,
		END,
		UNARY_END,
		DATA
	}

	class Tag {
		@type : TagType;
		@name : String;

		New(type : TagType) {
			@type := type;
			@name := "";
		}

		New(type : TagType, name : String) {	
			@type := type;
			@name := name;
		}
		
		method : public : GetType() ~ TagType {
			return @type;
		}

		method : public : GetName() ~ String {
			return @name;
		}
	}
}
