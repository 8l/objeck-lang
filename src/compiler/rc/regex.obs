#~
Enhanced bytecode machine implementation of Thompson's
on-the-fly regular expression compiler for Objeck.
Copyright (c) 2012 Randy Hollines

* Copyright (c) 2004 Jan Burgy.
* Can be distributed under the MIT license, see bottom of file.
~#

use IO;
use Struct;

bundle Default {
	enum Token := -16 {
		LPRN,
		RPRN,
		ALTERN,
		CONCAT,
		KLEENE
	}
	
	enum Operand := -32 {
		STOP,
  	JUMP,
		MATCH,
		BRANCH
	}
	
	class RegEx {
		@pattern : String;
		@instrs : Instr[];
		@max_size : Int;
		@error : Bool;
		
		New(pattern : String) {
			@pattern := pattern;
			@max_size := 256;
			@error := false;
			@instrs := Nil;
			
Console->Print("pattern=")->PrintLine(pattern);
			prep := Prepare();
			if(@error = false) {
				src := Convert(prep);
DumpSrc(src);
				@instrs := Compile(src);
DumpInstrs(@instrs);
			};
		}

		method : public : DumpInstrs(instrs : Instr[]) ~ Nil {
			i := 0;
			do {
				instr := instrs[i];
				select(instr->GetOperand()) {
					label Operand->STOP: {
						Console->Print(i)->PrintLine(": STOP");
					}
					
					label Operand->JUMP: {
						Console->Print(i)->Print(": JUMP, addr=")
							->PrintLine(instr->GetAddress());
					}

					label Operand->MATCH: {
						Console->Print(i)->Print(": MATCH, symb='")
							->Print(instr->GetAddress()->As(Char))->PrintLine('\'');
					}
					
					label Operand->BRANCH: {
						Console->Print(i)->Print(": BRANCH, symb='")
							->Print(instr->GetAddress()->As(Char))->PrintLine('\'');				
					}
				};
				i += 1;
			}
			while(instr->GetOperand() <> Operand->STOP);
		}
		
		method : public : DumpSrc(prep : Int[]) ~ Nil {
			"source="->Print();
			i := 0;
			t := prep[i];
			while(t <> 0) {
				select(t) {
					label Token->LPRN: {
						'('->Print();
					}
					
					label Token->RPRN: {
						')'->Print();
					}
					
					label Token->KLEENE: {
						'*'->Print();
					}
					
					label Token->ALTERN: {
						'|'->Print();
					}
					label Token->CONCAT: {
						'.'->Print();
					}
					other: {
						c := t->As(Char);
						c->Print();
					}
				};
				i += 1;
				t := prep[i];
			};
			'\n'->Print();
		}
		
		method : public : Convert(prep : Int[]) ~ Int[] {
			stack := Int->New[@max_size];
			top := 0; 
			j := 0; 
			
			postfix := Int->New[prep->Size()];			
			i := 0;
			t := prep[i];
			
			stack[top] := Token->LPRN;
			top += 1;
			while(t <> 0) {
				select(t) {
					label Token->LPRN: {
						stack[top] := t;
						top += 1;
					}
					
					label Token->RPRN: {
						while(t <= stack[top - 1]) {
							top -= 1;
							postfix[j] := stack[top];
							j += 1;
						};
						top -= 1;
					}
					
					label Token->KLEENE:
					label Token->ALTERN:
					label Token->CONCAT: {
						while(t <= stack[top - 1]) {
							top -= 1;
							postfix[j] := stack[top];
							j += 1;
						};
						stack[top] := t;
						top += 1;
					}
					
					other: {
						postfix[j] := t;
						j += 1;
					}
				};
				# update
				i += 1;
				t := prep[i];
			};
			postfix[j] := 0;
			
			return postfix;
		}
		
		method : public : Compile(src : Int[]) ~ Instr[] {
			pc := 0;
			top := 0;
			stack := Int->New[@max_size];
			code := Instr->New[src->Size() * 5];

			i := 0;
			s := src[i];
			while(s <> 0) {
    		select(s) {
					label Token->CONCAT: {
						top -= 1;
					}
					
					label Token->KLEENE: {
						code[pc] := Instr->New(Operand->BRANCH, '*'->As(Int));
						pc += 1;
						
						code[pc] := code[stack[top - 1]];
						pc += 1;

						code[stack[top - 1]] := Instr->New(Operand->JUMP, pc - 2);
					}
			
					label Token->ALTERN: {
						code[pc] := Instr->New(Operand->JUMP, pc + 4);
						pc += 1;
						
						code[pc] := Instr->New(Operand->BRANCH, '|'->As(Int));
						pc += 1;
						
						code[pc] := code[stack[top - 1]];
						pc += 1;
						
						code[pc] := code[stack[top - 2]];
						pc += 1;
						
						code[stack[top - 2]] := Instr->New(Operand->JUMP, pc - 3);
						code[stack[top - 1]] := Instr->New(Operand->JUMP, pc);
						top -= 1;
					}
					
					other: {
						stack[top] := pc;
						top += 1;

						code[pc] := Instr->New(Operand->JUMP, pc + 1);
						pc += 1;
						
						code[pc] := Instr->New(Operand->MATCH, s);
						pc += 1;
					}
				};
				i += 1;
				s := src[i];		
			};
			code[pc] := Instr->New(Operand->STOP, pc);
			pc += 1;
			
			return code;
		}
		
		method : public : Apply(string : String) ~ Nil {
			if(@instrs <> Nil) {
				Execute(@instrs, string)->PrintLine();
			};
		}
		
		method : public : Prepare() ~ Int[] {
			prep := Int->New[@max_size];
			index := 0;
			prn_count := 0;
			concat := false;
			
			each(i : @pattern) {
				c := @pattern->Get(i);
				select(c) {
					label '(': {
						prep[index] := Token->LPRN;
						index += 1;
						prn_count += 1;
						concat := false;
					}
					
					label ')': {
						prep[index] := Token->RPRN;
						index += 1;
						prn_count -= 1;
						concat := true;
					}
					
					label '*': {
						prep[index] := Token->KLEENE;
						index += 1;
						concat := true;
					}
					
					label '|': {
						prep[index] := Token->ALTERN;
						index += 1;
						concat := false;
					}
					
					other: {
						if(concat) {
							prep[index] := Token->CONCAT;
							index += 1;
						};
						prep[index] := c;
						index += 1;
						concat := true;
					}
				};
			};
			prep[index] := Token->RPRN;
			index += 1;
			prep[index] := 0;
			
			if(prn_count <> 0) {
				"unbalanced parentheses"->PrintLine();
				@error := true;
			};
			
			return prep;
		}

		method : public : Execute(code : Instr[], src : String) ~ Bool {
			i := 0;	c := src->Get(i); i += 1;	pc := 0;
			clist := Int->New[@max_size];
			cnode := 0;	shift := 0;
			nlist	:= Int->New[@max_size];
			nnode := 0;	
			match : Bool;
			
			while(i <= src->Size()) {
				select(code[pc]->GetOperand()) {
					label Operand->STOP: {
						match := true;
					}

					label Operand->JUMP: {
						pc := code[pc]->GetAddress();
						match := false;
					}

					label Operand->MATCH: {
						if(c = code[pc]->GetAddress()) {
							Console->Print("match '")->Print(c)->PrintLine("'");

							nlist[nnode] := code[pc + 1]->GetAddress();
							nnode += 1;
						};
						match := true;
					}
					
					label Operand->BRANCH: {
						clist[cnode] := code[pc + 1]->GetAddress();
						cnode += 1;
						pc := code[pc + 2]->GetAddress();
						match := false;
					}		
				};

				if(match) {
					if(shift = cnode) {
						if(nnode = 0) { "-0-"->PrintLine(); return false; };
						shift := 0;
						cnode := 0;
						while(nnode > 0) {
							nnode -= 1;
							clist[cnode] := nlist[nnode];
							cnode += 1;
						};
						c := src->Get(i);
						i += 1;
					};
					pc := clist[shift];
					shift += 1;
				};
			};

			# is any of the current states final?
			for(i := shift; i < cnode; i += 1;) {
				if(code[clist[i]]->GetOperand() = Operand->STOP) {
					return	true;
				};
			};
			
			return code[pc]->GetOperand() = Operand->STOP;
		}
		
		function : Main(args : String[]) ~ Nil {
			regex := RegEx->New("(ac|b)*aa");
			regex->Apply("acbacbaa");
		}
	}
	
	class Instr {
		@operand : Operand;
		@address : Int;
		
		New(operand : Operand, address : Int) {
			@operand := operand;
			@address := address;
		}

		method : public : GetOperand() ~ Operand {
			return @operand;
		} 
		
		method : public : GetAddress() ~ Int {
			return @address;
		} 
	}
}

#~
/*
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the
 * Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall
 * be included in all copies or substantial portions of the
 * Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS
 * OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
~#
