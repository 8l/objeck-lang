#~
Enhanced bytecode machine implementation of Thompson's
on-the-fly regular expression compiler for Objeck.
Copyright (c) 2012 Randy Hollines

* Copyright (c) 2004 Jan Burgy.
* Can be distributed under the MIT license, see bottom of file.
~#

use IO;
use Struct;

bundle Default {
	enum Token := -16 {
		LPRN,
		RPRN,
		ALTERN,
		CONCAT,
		KLEENE
	}
	
	enum Operand := -32 {
		STOP,
  	JUMP,
		MATCH,
		BRANCH
	}
	
	class RegEx {
		@string : String;
		@pattern : String;
		@error : Bool;
		
		New(pattern : String) {
			@pattern := pattern;
			@error := false;
			
pattern->PrintLine();
			prep := Prepare();
			if(@error = false) {
				src := Convert(prep);
DumpSrc(src);
				instrs := Compile(src);
DumpInstrs(instrs);
			};
		}

		method : public : DumpInstrs(instrs : Instr[]) ~ Nil {
			i := 0;
			do {
				instr := instrs[i];
				select(instr->GetOperand()) {
					label Operand->STOP: {
						Console->Print(i)->PrintLine(": STOP");
					}
					
					label Operand->JUMP: {
						Console->Print(i)->Print(": JUMP, addr=")
							->PrintLine(instr->GetAddress());
					}

					label Operand->MATCH: {
						Console->Print(i)->Print(": MATCH, symb='")
							->Print(instr->GetAddress()->As(Char))->PrintLine('\'');
					}
					
					label Operand->BRANCH: {
						Console->Print(i)->Print(": BRANCH, symb='")
							->Print(instr->GetAddress()->As(Char))->PrintLine('\'');				
					}
				};
				i += 1;
			}
			while(instr->GetOperand() <> Operand->STOP);
		}
		
		method : public : DumpSrc(prep : Int[]) ~ Nil {
			i := 0;
			t := prep[i];
			while(t <> 0) {
				select(t) {
					label Token->LPRN: {
						'('->Print();
					}
					
					label Token->RPRN: {
						')'->Print();
					}
					
					label Token->KLEENE: {
						'*'->Print();
					}
					
					label Token->ALTERN: {
						'|'->Print();
					}
					label Token->CONCAT: {
						'.'->Print();
					}
					other: {
						c := t->As(Char);
						c->Print();
					}
				};
				i += 1;
				t := prep[i];
			};
			'\n'->Print();
		}
		
		method : public : Convert(prep : Int[]) ~ Int[] {
			stack := Int->New[prep->Size()];
			top := 0; 
			j := 0; 
			
			postfix := Int->New[prep->Size()];			
			i := 0;
			t := prep[i];
			
			stack[top] := Token->LPRN;
			top += 1;
			while(t <> 0) {
				select(t) {
					label Token->LPRN: {
						stack[top] := t;
						top += 1;
					}
					
					label Token->RPRN: {
						while(t <= stack[top - 1]) {
							top -= 1;
							postfix[j] := stack[top];
							j += 1;
						};
						top -= 1;
					}
					
					label Token->KLEENE:
					label Token->ALTERN:
					label Token->CONCAT: {
						while(t <= stack[top - 1]) {
							top -= 1;
							postfix[j] := stack[top];
							j += 1;
						};
						stack[top] := t;
						top += 1;
					}
					
					other: {
						postfix[j] := t;
						j += 1;
					}
				};
				# update
				i += 1;
				t := prep[i];
			};
			postfix[j] := 0;
			
			return postfix;
		}
		
		method : public : Compile(src : Int[]) ~ Instr[] {
			pc := 0;
			top := 0;
			stack := Int->New[src->Size()];
			code := Instr->New[src->Size() * 5];

			i := 0;
			s := src[i];
			while(s <> 0) {
    		select(s) {
					label Token->CONCAT: {
						top -= 1;
					}
					
					label Token->KLEENE: {
						code[pc] := Instr->New(Operand->BRANCH, '*'->As(Int));
						pc += 1;
						
						code[pc] := code[stack[top - 1]];
						pc += 1;

						code[stack[top - 1]] := Instr->New(Operand->JUMP, pc - 2);
					}
			
					label Token->ALTERN: {
						code[pc] := Instr->New(Operand->JUMP, pc + 4);
						pc += 1;
						
						code[pc] := Instr->New(Operand->BRANCH, '|'->As(Int));
						pc += 1;
						
						code[pc] := code[stack[top - 1]];
						pc += 1;
						
						code[pc] := code[stack[top - 2]];
						pc += 1;
						
						code[stack[top - 2]] := Instr->New(Operand->JUMP, pc - 3);
						code[stack[top - 1]] := Instr->New(Operand->JUMP, pc);
						top -= 1;
					}
					
					other: {
						stack[top] := pc;
						top += 1;

						code[pc] := Instr->New(Operand->JUMP, pc + 1);
						pc += 1;
						
						code[pc] := Instr->New(Operand->MATCH, s);
						pc += 1;
					}
				};
				i += 1;
				s := src[i];		
			};
			code[pc] := Instr->New(Operand->STOP, pc);
			pc += 1;
			
			return code;
		}
		
		method : public : Apply(string : String) ~ Nil {
			@string := string;
		}
		
		method : public : Prepare() ~ Int[] {
			prep := Int->New[@pattern->Size() * 2];
			index := 0;
			prn_count := 0;
			concat := false;
			
			each(i : @pattern) {
				c := @pattern->Get(i);
				select(c) {
					label '(': {
						prep[index] := Token->LPRN;
						index += 1;
						prn_count += 1;
						concat := false;
					}
					
					label ')': {
						prep[index] := Token->RPRN;
						index += 1;
						prn_count -= 1;
						concat := true;
					}
					
					label '*': {
						prep[index] := Token->KLEENE;
						index += 1;
						concat := true;
					}
					
					label '|': {
						prep[index] := Token->ALTERN;
						index += 1;
						concat := false;
					}
					
					other: {
						if(concat) {
							prep[index] := Token->CONCAT;
							index += 1;
						};
						prep[index] := c;
						index += 1;
						concat := true;
					}
				};
			};
			prep[index] := Token->RPRN;
			index += 1;
			prep[index] := 0;
			
			if(prn_count <> 0) {
				"unbalanced parentheses"->PrintLine();
				@error := true;
			};
			
			return prep;
		}
		
		function : Main(args : String[]) ~ Nil {
			regex := RegEx->New("(a|b)*a");
			regex->Apply("ababababab");
		}
	}
	
	class Instr {
		@operand : Operand;
		@address : Int;
		
		New(operand : Operand, address : Int) {
			@operand := operand;
			@address := address;
		}

		method : public : GetOperand() ~ Operand {
			return @operand;
		} 
		
		method : public : GetAddress() ~ Int {
			return @address;
		} 
	}
}

#~
/*
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the
 * Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall
 * be included in all copies or substantial portions of the
 * Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS
 * OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
~#
