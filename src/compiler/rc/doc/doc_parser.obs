use System.IO;
use System.IO.File;
use Collection;

class DocParser {
	@buffer : String;
	@buffer_index : Int;
	@cur_char : Char;
	@nxt_char : Char;
	@file : String;
	@classes : StringHash;
	@interfaces : StringHash;
	@enums : StringHash;
	@class_inf_block : ClassBlock;
	@level : Int;
	
	New(file : String) {
		@file := file;	
		@classes := StringHash->New();
		@interfaces := StringHash->New();
		@enums := StringHash->New();
		@level := 0;
	}
	
	method : public : GetAllClasses() ~ Vector {
		all_classes := Vector->New();
		
		keys := @classes->GetKeys();
		each(i : keys) {
			klass := @classes->Find(keys->Get(i)->As(String))->As(ClassBlock);
			if(klass <> Nil) {
				all_classes->AddBack(klass);
			};
		};
				
		return all_classes;
	}

	method : public : GetAllInterfaces() ~ Vector {
		all_interfaces := Vector->New();
		
		keys := @interfaces->GetKeys();
		each(i : keys) {
			inf := @interfaces->Find(keys->Get(i)->As(String))->As(ClassBlock);
			if(inf <> Nil) {
				all_interfaces->AddBack(inf);
			};
		};
				
		return all_interfaces;
	}

	method : public : GetAllEnums() ~ Vector {
		all_enums := Vector->New();
		
		keys := @enums->GetKeys();
		each(i : keys) {
			eenum := @enums->Find(keys->Get(i)->As(String))->As(EnumBlock);
			if(eenum <> Nil) {
				all_enums->AddBack(eenum);
			};
		};
				
		return all_enums;
	}

	method : NextChar() ~ Nil {
		if(@buffer_index < @buffer->Size()) {
			@cur_char := @buffer->Get(@buffer_index);
			@buffer_index += 1;
			if(@buffer_index < @buffer->Size()) {
				@nxt_char := @buffer->Get(@buffer_index);
			}
			else {
				@nxt_char := '\0';
			};
		}
		else {
			@cur_char := '\0';
			@nxt_char := '\0';
		};
	}

	method : ParseWhiteSpace() ~ Nil {
		while(@buffer_index < @buffer->Size() & (@cur_char = ' ' | @cur_char = '\t' | 
			@cur_char = '\r' | @cur_char = '\n')) {
			NextChar();
		};
	}

	method : ParseIdent() ~ String {
		ParseWhiteSpace();

		ident := "";
		done := false;
		while(<>done) {
			select(@cur_char) {
				label ' ':
				label '\r':
				label '\n':
				label '{':
				label '}':
				label ':':
				label ',':
				label '(':
				label ')':
				label '~':
				label '#':
				label '\0': {
					done := true;
				}				
				other: {
					ident->Append(@cur_char);
					NextChar();
				}
			};
		};
		
		return ident->Trim();
	}
	
	method : public : native : ParseBundle(block : String) ~ Nil {
	}

	method : public : native : ParseEnum(block : String) ~ Nil {
		block->Append(" enum ");
		while(@cur_char <> '\0' & @cur_char <> '}') {
			block->Append(@cur_char);
			CheckLevel();
			NextChar();
		};
		block->Append(" }");					
		
		enum_block := EnumBlock->New(block);
		if(enum_block->IsParsed()) {
			@enums->Insert(enum_block->GetName(), enum_block);
		};
		
# IO.Console->Print("enum: block='")->Print(block)->PrintLine("'");
# "---"->PrintLine();

		block := "";
	}

	method : public : native : ParseClassFunction(name : String, block : String) ~ Nil {
		block->Append(' ');
		block->Append(name);
		block->Append(' ');
		while(@cur_char <> '\0' & @cur_char <> '{' & @cur_char <> ';') {
			block->Append(@cur_char);
			NextChar();
		};
		block->Append(" {");

		if(name->Equals("class")) {
			@class_inf_block := ClassBlock->New(block, false);
			if(@class_inf_block->IsParsed()) {
				@classes->Insert(@class_inf_block->GetName(), @class_inf_block);
			};
		}
		else if(name->Equals("interface")) {
			@class_inf_block := ClassBlock->New(block, true);
			if(@class_inf_block->IsParsed()) {
				@interfaces->Insert(@class_inf_block->GetName(), @class_inf_block);
			};
		}
		else if(@class_inf_block <> Nil & @class_inf_block->IsParsed()) {
			@class_inf_block->AddFunction(block);
		};

# IO.Console->Print(name)->Print(": block='")->Print(block)->PrintLine("'");
# "---"->PrintLine();

		block := "";
	}

	method : public : CheckLevel() ~ Nil {
		if(@cur_char = '{') {
			@level += 1;
		}
		else if(@cur_char = '}') {
			@level -= 1;
		};
	}

	method : public : native : Parse() ~ Bool {
		if(<>@file->EndsWith(".obs")) {
			return false;
		};
		
		@buffer := FileReader->ReadFile(@file);
		if(@buffer = Nil) {
			return false;
		};		

		state := 0;
		start := 0;
		NextChar();
		ParseWhiteSpace();
		block := "";
		while(@cur_char <> '\0') {
			# states 1-3 for outer classes and enums
			if(state = 2) {
				ident := ParseIdent();
				if(ident->Equals("bundle")) {
IO.Console->Print("bundle: level=")->Print(@level)->Print(", block='")->Print(block)->PrintLine("'");
					ParseBundle(block);				
				}
				else if(ident->Equals("class") | ident->Equals("interface")) {
IO.Console->Print("class: level=")->PrintLine(@level);				
					ParseClassFunction(ident, block);
				}
				else if(ident->Equals("enum")) {
IO.Console->Print("enum: level=")->PrintLine(@level);
					ParseEnum(block);
				}
				else if(ident->Equals("function") | ident->Equals("method") | ident->Equals("New")) {
IO.Console->Print("function: level=")->PrintLine(@level);
					ParseClassFunction(ident, block);
				};
				state := 0;
			};
			
			if(@cur_char = '#' & @nxt_char = '~') {
				state := 1;
				start := @buffer_index - 1;
			}
			else if((state = 1 | state = 4) & @cur_char = '~' & @nxt_char = '#') {
				block := @buffer->SubString(start, @buffer_index - start + 1);
				state := 2;
				NextChar();
			};
			CheckLevel();
			
			NextChar();
		};

		return true;	
	}
}

class DocBlock {
	@buffer : String;
	@buffer_index : Int;
	@cur_char : Char;
	@nxt_char : Char;
	@parsed : Bool;
	
	New(buffer : String) {
		@buffer := buffer;
		@buffer_index := 0;
		@parsed := false;
		NextChar();
	}
	
	method : NextChar() ~ Nil {
		if(@buffer_index < @buffer->Size()) {
			@cur_char := @buffer->Get(@buffer_index);
			@buffer_index += 1;
			if(@buffer_index < @buffer->Size()) {
				@nxt_char := @buffer->Get(@buffer_index);
			}
			else {
				@nxt_char := '\0';
			};
		}
		else {
			@cur_char := '\0';
			@nxt_char := '\0';
		};
	}
	
	method : ParseWhiteSpace() ~ Nil {
		while(@buffer_index < @buffer->Size() & (@cur_char = ' ' | @cur_char = '\t' | 
			@cur_char = '\r' | @cur_char = '\n')) {
			NextChar();
		};
	}

	method : MatchCommentStart() ~ Bool {
		ParseWhiteSpace();
		match := @cur_char = '#' & @nxt_char = '~';
		if(match) {
			NextChar();	NextChar();
			return true;
		};
		
		return false;
	}

	method : MatchCommentEnd() ~ Bool {
		ParseWhiteSpace();
		match := @cur_char = '~' & @nxt_char = '#';
		if(match) {
			NextChar();	NextChar();
			return true;
		};
		
		return false;
	}
	
	method : MatchChar(char : Char) ~ Bool {
		ParseWhiteSpace();
		
		match := @cur_char = char;
		if(match) {
			NextChar();
			return true;
		};
		
		return false;
	}

	method : MatchIdent(ident : String) ~ Bool {
		return ParseIdent()->Equals(ident);
	}

	method : MatchEitherIdent(checks : String[]) ~ Bool {
		ident := ParseIdent();
		each(i : checks) {
			if(checks[i]->Equals(ident)) {
				return true;
			};
		};
		
		return false;
	}

	method : ParseIdent() ~ String {
		ParseWhiteSpace();

		ident := "";
		done := false;
		while(<>done) {
			select(@cur_char) {
				label ' ':
				label '\r':
				label '\n':
				label '{':
				label '}':
				label ':':
				label ',':
				label '(':
				label ')':
				label '~':
				label '#':
				label '\0': {
					done := true;
				}
				
				other: {
					ident->Append(@cur_char);
					NextChar();
				}
			};
		};
		
		return ident->Trim();
	}
	
	method : ParseDesc() ~ String {
		ParseWhiteSpace();
		
		ident := "";
		done := false;
		while(<>done) {
			select(@cur_char) {
				label ' ':
				label '\t':
				label '\r':
				label '\n': {
					ParseWhiteSpace();
					ident->Append(' ');
				}
#~
				label '#': {
					ident->Append(' ');
					NextChar();
				}
~#
				label '{':
				label '}':
				label ':':
				label '(':
				label ')':
				label '~':
				label '@':
				label '\0': {
					done := true;
				}				
				other: {
					ident->Append(@cur_char);
					NextChar();
				}
			};
		};
		
		return ident->Trim();
	}
}

class EnumBlock from DocBlock {
	@name : String;
	@desc : String;
	@klass : String;
	@items : Vector;
	@parsed : Bool;
	
	New(buffer : String) {
		Parent(buffer);
		@items := Vector->New();
		@parsed := Parse();
	}

	method : public : IsParsed() ~ Bool {
		return @parsed;
	}

	method : public : GetName() ~ String {
		return @name;
	}

	method : public : GetClass() ~ String {
		return @klass;
	}

	method : public : GetItems() ~ Vector {
		return @items;
	}

	method : public : GetDesc() ~ String {
		return @desc;
	}

	method : native : Parse() ~ Bool {
		if(<>MatchCommentStart()) {
			return false;
		};
		@desc := ParseDesc();	

		# parse tags		
		type := ParseIdent();
		if(type->Size() > 0) {
			if(type->Equals("@class")) {
				@klass := ParseIdent();
				if(@klass->Size() = 0) {
					return false;
				};
			};
		};
		

		if(<>MatchCommentEnd()) {
			return false;
		};

		if(<>MatchIdent("enum")) {
			return false;
		};

		@name := ParseIdent();
		if(@name->Size() = 0) {
			return false;
		};

		if(@klass <> Nil) {
			name := @klass;
			name += "->";
			name += @name;
			@name := name;
		};

		if(<>MatchChar('{')) {
			return false;
		};
	
		# items
		while(@cur_char <> '}') {
			item_name := ParseIdent();
			if(item_name->Size() = 0) {
				return false;
			};

			@items->AddBack(item_name);
			MatchChar(',');
		};
		
		return true;
	}
}

class ClassBlock from DocBlock {
	@name : String;
	@from : String;
	@desc : String;
	@funcs : StringMap;
	@is_inf : Bool;
	@parsed : Bool;
	
	New(buffer : String, is_inf : Bool) {
		Parent(buffer);
		@is_inf := is_inf;
		@funcs := StringMap->New();
		@parsed := Parse();
	}

	method : public : IsParsed() ~ Bool {
		return @parsed;
	}

	method : public : IsInterface() ~ Bool {
		return @is_inf;
	}
	
	method : public : GetName() ~ String {
		return @name;
	}

	method : public : GetFrom() ~ String {
		return @from;
	}

	method : public : GetDesc() ~ String {
		return @desc;
	}

	method : public : AddEnum(block : String) ~ Nil {
	}

	method : public : AddFunction(block : String) ~ Nil {
		func := FuncBlock->New(block);
		if(func->IsParsed()) {
			funcs := @funcs->Find(func->GetName())->As(Vector);
			if(funcs = Nil) {
				funcs := Vector->New();
				@funcs->Insert(func->GetName(), funcs);
			};
			funcs->AddBack(func);
		};
	}

	method : public : GetFunction(name : String) ~ Vector {
		return @funcs->Find(name)->As(Vector);
	}

	method : public : GetFunctionNames() ~ Vector {
		return @funcs->GetKeys();
	}

	method : public : GetFunctions(name : String) ~ Vector {
		return @funcs->Find(name)->As(Vector);
	}
	
	method : public : GetAllFunctions() ~ Vector {
		all_funcs := Vector->New();
		
		keys := @funcs->GetKeys();
		each(i : keys) {
			funcs := @funcs->Find(keys->Get(i)->As(String))->As(Vector);
			each(j : funcs) {
				all_funcs->AddBack(funcs->Get(j));
			};
		};
				
		return all_funcs;
	}

	method : native : Parse() ~ Bool {
		if(<>MatchCommentStart()) {
			return false;
		};
		@desc := ParseDesc();
		if(<>MatchCommentEnd()) {
			return false;
		};

		if(<>MatchEitherIdent(["class", "interface"])) {
			return false;
		};
		
		@name := ParseIdent();
		if(@name->Size() = 0) {
			return false;
		};

		if(MatchIdent("from")) {
			@from := ParseIdent();
			if(@from->Size() = 0) {
				return false;
			};
		};
		# TODO: parse from
		#...
		
		return true;
	}
}

class FuncBlock from DocBlock {
	@name : String;
	@signature : String;
	@desc : String;
	@tags : StringHash;
	@return_type : DocType;
	@return_tag : DocTag;
	@func_types : Vector;
	@is_func : Bool;
	@is_private : Bool;
	@is_native : Bool;
	@is_virtual : Bool;
	@is_new : Bool;
	@types : static : StringHash;
	@parsed : Bool;
	
	New(buffer : String) {
		Parent(buffer);
		Initialize();
		
		@name := "";
		@desc := "";
		@tags := StringHash->New();
		@func_types := Vector->New();
		@parsed := Parse();
	}
	
	function : Initialize() ~ Nil {
		if(@types = Nil) {
			@types := StringHash->New();
			@types->Insert("Byte", IntHolder->New(DocType->Type->BYTE->As(Int)));
			@types->Insert("Char", IntHolder->New(DocType->Type->CHAR->As(Int)));
			@types->Insert("Int", IntHolder->New(DocType->Type->INT->As(Int)));
			@types->Insert("Float", IntHolder->New(DocType->Type->FLOAT->As(Int)));
			@types->Insert("Nil", IntHolder->New(DocType->Type->NIL->As(Int)));
		};
	}
	
	method : public : IsParsed() ~ Bool {
		return @parsed;
	}

	method : public : GetName() ~ String {
		return @name;
	}

	method : public : GetSignature() ~ String {
		if(@signature = Nil) {
			@signature := "";
			
			if(@is_new) {
				@signature->Append("New");
			}
			else {
				if(@is_func) {
					@signature->Append("function : ");
				}
				else {
					@signature->Append("method : ");
				};
				
				if(@is_private) {
					@signature->Append("private : ");
				}
				else {
					@signature->Append("public : ");
				};
		
				if(@is_native) {
					@signature->Append("native : ");
				};
				
				if(@is_virtual) {
					@signature->Append("virutal : ");
				};
		
				@signature->Append(@name);
			};
			@signature->Append('(');

			each(i : @func_types) {
				func_type := @func_types->Get(i)->As(DocType);
				@signature->Append(func_type->GetName());
				@signature->Append(':');
				@signature->Append(func_type->GetTypeName());
			
				if(i + 1 < @func_types->Size()) {
					@signature->Append(", ");
				};
			};
		
			if(@is_new) {
				@signature->Append(')');
			}
			else {
				@signature->Append(") ~ ");
				@signature->Append(@return_type->GetTypeName());
			};
		};
		
		return @signature;
	}

	method : public : GetReturnTag() ~ DocTag {
		return @return_tag;
	}

	method : public : GetReturnType() ~ DocType {
		return @return_type;
	}

	method : public : GetDesc() ~ String {
		return @desc;
	}

	method : public : GetParamTags() ~ StringHash {
		return @tags;
	}
	
	method : public : GetParams() ~ Vector {
		return @func_types;
	}
	
	method : native : Parse() ~ Bool {
		if(<>MatchCommentStart()) {
			return false;
		};
		@desc := ParseDesc();	

		# parse tags		
		are_tags := true;
		while(@cur_char <> '\0' & are_tags) {
			type := ParseIdent();
			if(type->Size() > 0) {
				if(type->Equals("@param")) {
					tag_name := ParseIdent();
					if(tag_name->Size() = 0) {
						return false;
					};

					tag_desc := ParseDesc();
					if(tag_desc->Size() = 0) {
						return false;
					};
					tag := DocTag->New(tag_name, tag_desc);
					@tags->Insert(tag->GetName(), tag);
				}
				else if(type->Equals("@return")) {
					tag_desc := ParseDesc();
					if(tag_desc->Size() = 0) {
						return false;
					};
					@return_tag := DocTag->New(tag_desc);
				}
				else {
					return false;
				};
			}
			else {
				are_tags := false;
			};
		};

		if(<>MatchCommentEnd()) {
			return false;
		};
		
		# parse function
		func_type := ParseIdent();
		if(func_type->Size() > 0) {
			if(func_type->Equals("function")) {
				@is_func := true;
			}
			else if(func_type->Equals("method")) {
				@is_func := false;
			}
			else if(func_type->Equals("New")) {
				@is_new := true;
				@is_func := false;
			}
			else {
				return false;
			};
		};

		if(@is_new) {
			@name := "New";
		}
		else {
			while(MatchChar(':')) {
				meta := ParseIdent();
				if(meta->Size() > 0) {
					if(meta->Equals("public")) {
						@is_public := true;
					}
					else if(meta->Equals("private")) {
						@is_public := false;
					}
					else if(meta->Equals("native")) {
						@is_native := true;
					}
					else if(meta->Equals("virtual")) {
						@is_virtual := true;
					}
					else {
						@name := meta;
					};
				};
			};
		};
		
		if(@name = Nil | <>MatchChar('(')) {
			return false;
		};
		
		# function parameters
		while(@cur_char <> ')') {
			param_name := ParseIdent();
			if(param_name->Size() = 0) {
				return false;
			};
		
			if(<>MatchChar(':')) {
				return false;
			};
		
			type_name := "";
			type_param := ParseType(param_name, type_name);
			if(type_param <> Nil) {
				@func_types->AddBack(type_param);
				MatchChar(',');
			};
		};
		
		if(<>MatchChar(')')) {
			return false;
		};
		
		if(<>@is_new) {
			if(<>MatchChar('~')) {
				return false;
			};

			# return type
			rtrn_name := ParseIdent();
			if(rtrn_name->Size() = 0) {
				return false;
			};
		
			rtrn_type := @types->Find(rtrn_name)->As(IntHolder);
			if(rtrn_type <> Nil) {
				@return_type := DocType->New("", rtrn_name, rtrn_type->Get()->As(DocType->Type));
			}
			else {
				@return_type := DocType->New("", rtrn_name, DocType->Type->CLASS);
			};
		};
		
		return true;
	}
	
	method : ParseType(param_name : String, type_name : String) ~ DocType {
		if(MatchChar('(')) {
			type_name->Append('(');

			if(ParseFuncType(type_name)) {
				return DocType->New(param_name, type_name, DocType->Type->FUNC);
			}
			else {
				return Nil;
			};
		}
		else {
			ident := ParseIdent();
			if(ident->Size() = 0) {
				return Nil;
			};
			type_name->Append(ident);
		
			param_type := @types->Find(type_name)->As(IntHolder);
			if(param_type <> Nil) {
				return DocType->New(param_name, type_name, param_type->Get()->As(DocType->Type));
			}
			else {
				return DocType->New(param_name, type_name, DocType->Type->CLASS);
			};
		};
	}
	
	method : ParseFuncType(type_name : String) ~ Bool {
		ident := ParseIdent();
		while(ident->Size() > 0) {
			type_name->Append(ident);
			if(MatchChar(',')) {
				type_name->Append(',');
			};
			ident := ParseIdent();
		};

		if(<>MatchChar(')')) {
			return false;
		};
		type_name->Append(')');

		if(<>MatchChar('~')) {
			return false;
		};
		type_name->Append('~');

		ident := ParseIdent();
		if(ident->Size() = 0) {
			return false;
		};
		type_name->Append(ident);
		
		return true;
	}
}

class DocTag {
	enum Type {
		PARAM,
		RETURN
	}	
	
	@type : Type;
	@name : String;
	@desc : String;

	New(name : String, desc : String) {
		@type := Type->PARAM;
		@name := name;
		@desc := desc;
	}

	New(desc : String) {
		@type := Type->RETURN;
		@name := "";
		@desc := desc;
	}
	
	method : public : GetType() ~ DocTag->Type {
		return @type;
	}

	method : public : GetName() ~ String {
		return @name;
	}

	method : public : GetDesc() ~ String {
		return @desc;
	}
}

class DocType {
	enum Type {
		BYTE,
		CHAR,
		INT,
		FLOAT,
		CLASS,
		FUNC,
		NIL
	}
	
	@name : String;
	@type_name : String;		
	@type : DocType->Type;
	
	New(name : String, type_name : String, type : Type) {
		@name := name;
		@type_name := type_name;
		@type := type;
	}

	method : public : GetName() ~ String {
		return @name;
	}

	method : public : GetTypeName() ~ String {
		return @type_name;
	}

	method : public : GetType() ~ Type {
		return @type;
	}
}

