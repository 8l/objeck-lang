use System.IO;
use System.IO.File;
use Collection;


class Parser {
	function : Main(args : String[]) ~ Nil {
		if(args->Size() = 1) {
			Parse(args[0]);
		};
	}
	
	function : native : Parse(file : String) ~ Nil {
		capture := 0;
		block := "";
		line_num := 0;
		comment_state := 0;							
		reader := FileReader->New(file);
		class_doc : ClassDoc;
		while(<>reader->IsEOF()) {
			line := reader->ReadString();
			line_num += 1;
			
			i := 0;	
			while(i < line->Size()) {		
				# skip whitespace
				while((line->Get(i) = ' ' | line->Get(i) = '\t') & i < line->Size()) {
					i += 1;
				};
				
				# parse the line
				if(i < line->Size()) {
					# word
					if(line->Get(i)->IsChar() = true) {
						string := "";
						while(line->Get(i)->IsChar() = true | line->Get(i) = '.') {
							string->Append(line->Get(i));
							i += 1;
						};
						
						if(capture = 2 & string->Equals("class")) {
							capture := 3;
						}
						else if(capture = 2 & (string->Equals("function") | string->Equals("method"))) {
							capture := 4;
						};						
					}
					# other
					else {
						select(line->Get(i)) {
							label '{': {
								if(capture = 3) {
									block->Append(line);
									block->Append('\n');
									class_doc := ClassDoc->New(block);								
									block := "";
"---"->PrintLine();									
								}
								else if(capture = 4) {
									block->Append(line);
									block->Append('\n');
									if(class_doc <> Nil) {
										class_doc->AddFunctionDoc(block);
										block := "";
"---"->PrintLine();										
									};
								};
								capture := 0;
								comment_state := 0;
							}
			
							label '#': {
								if(comment_state = 2) {
									capture := 2;
									comment_state := 0;
								}
								else if(comment_state = 0) {
									comment_state := 1;
								};
							}

							label '~': {
								if(comment_state = 1) {
									capture := 1;
									comment_state := 0;
								}
								else if(comment_state = 0) {
									comment_state := 2;
								};
							}
					
							other: {
								comment_state := 0;
							}
						};						
					};	
				};
				i += 1;
			};				
			
			if(capture > 0) {
				block->Append(line);
				block->Append('\n');
			};
		};
		reader->Close();
	}
}

class Doc {
	@buffer : String;
	@buffer_index : Int;
	@cur_char : Char;
	@nxt_char : Char;
	
	New(buffer : String) {
		@buffer := buffer;
		@buffer_index := 0;
		NextChar();
	}
	
	method : NextChar() ~ Nil {
		if(@buffer_index < @buffer->Size()) {
			@cur_char := @buffer->Get(@buffer_index);
			@buffer_index += 1;
			if(@buffer_index < @buffer->Size()) {
				@nxt_char := @buffer->Get(@buffer_index);
			}
			else {
				@nxt_char := '\0';
			};
		}
		else {
			@cur_char := '\0';
			@nxt_char := '\0';
		};
	}
	
	method : native : ParseFrag() ~ String {
		while(@buffer_index < @buffer->Size() & (@cur_char = ' ' | @cur_char = '\t' | @cur_char = '\n')) {
			NextChar();
		};

		start := @buffer_index - 1;
		while(@buffer_index < @buffer->Size() & @cur_char <> '\n') {
			NextChar();
		};
		
		if(@buffer_index < @buffer->Size()) {
			return @buffer->SubString(start, @buffer_index - start - 1)->Trim;
		};
		
		return Nil;
	}
}

class ClassDoc from Doc {
	enum Type {
		NONE,
		START,
		END
	}

	@functions : StringMap;
	
	New(buffer : String) {
		Parent(buffer);
		Parse()->PrintLine();
	}

	method : public : GetName() ~ String {
		return "";
	}

	method : public : AddFunctionDoc(buffer : String) ~ Nil {
		func_method := FunctionDoc->New(buffer);
	}
	
	method : native : Parse() ~ Bool {
		state := ClassDoc->Type->NONE;
		line : String;
		do {
			line_frag := ParseFrag();
			if(line_frag = Nil) {
				return false;
			};
# IO.Console->Print("frag='")->Print(line_frag)->PrintLine("'");

			if(line_frag->StartsWith("#~")) {
				state := ClassDoc->Type->START;
			}
			else if(line_frag->EndsWith("~#")) {
				state := ClassDoc->Type->END;
			}
			else {				
				if(state = ClassDoc->Type->START) {
					line := line_frag;
				}
				else {				
					line += ' ';
					line += line_frag;					
				};
			};						
		}
		while(state <> ClassDoc->Type->END);
		
		return true;
	}
}

class FunctionDoc from Doc {
	enum Type {
		NONE,
		START,
		END,
		PARAM,
		RETURN,
		FUNC,
		METHOD,
		DESC
	}
	
	@comment : String;
	@name : String;

	New(buffer : String) {
		Parent(buffer);
		Parse()->PrintLine();
	}

	method : native : Parse() ~ Bool {
		state := FunctionDoc->Type->NONE;
		line : String;
		do {
			line_frag := ParseFrag();
			if(line_frag = Nil) {
				return false;
			};
			line_frag := line_frag->Trim();
			
# IO.Console->Print("frag='")->Print(line_frag)->PrintLine("'");

			if(line_frag->StartsWith("@param")) {
				ParseLine(line, state);
				state := FunctionDoc->Type->PARAM;
				line := String->New(line_frag);
			}
			else if(line_frag->StartsWith("@return")) {
				ParseLine(line, state);
				state := FunctionDoc->Type->RETURN;
				line := String->New(line_frag);
			}
			else if(line_frag->StartsWith("function")) {
				ParseLine(line, state);
				state := FunctionDoc->Type->FUNC;
				line := String->New(line_frag);
"--function--"->PrintLine();
			}
			else if(line_frag->StartsWith("method")) {
				ParseLine(line, state);
				state := FunctionDoc->Type->METHOD;
				line := String->New(line_frag);
"--method--"->PrintLine();
			}
			else if(line_frag->StartsWith("#~")) {
				state := FunctionDoc->Type->START;
			}
			else if(line_frag->EndsWith("~#")) {
				ParseLine(line, state);
				state := FunctionDoc->Type->END;
			}
			else {				
				if(state = FunctionDoc->Type->START) {
					line := String->New(line_frag);
					state := FunctionDoc->Type->DESC;
				}
				else {
					line += ' ';
					line += line_frag;
				};
			};
		}
		while(state <> FunctionDoc->Type->END);
		
		return true;
	}	

	method : native : ParseLine(line : String, state : FunctionDoc->Type) ~ Nil {
		select(state) {
			label FunctionDoc->Type->PARAM: {
				ParseParam(line);
			}
			
			label FunctionDoc->Type->RETURN: {
				ParseReturn(line);
			}
			
			label FunctionDoc->Type->DESC: {
				IO.Console->Print("\tdesc='")->Print(line)->PrintLine("'");
			}
		};
	}	

	method : native : ParseParam(line : String) ~ Nil {
		index := "@param"->Size() + 1;
		start := index;
		while(index < line->Size() & line->Get(index) <> ' ' & line->Get(index) <> '\t') {
			index += 1;
		};
		name := line->SubString(start, index - start);
		desc := line->SubString(index + 1, line->Size() - index - 1);
IO.Console->Print("\tparam: name='")->Print(name)->Print("', desc='")->Print(desc)->PrintLine("'");
	}

	method : native : ParseReturn(line : String) ~ Nil {
		index := "@return"->Size() + 1;
		desc := line->SubString(index, line->Size() - index);
IO.Console->Print("\treturn: desc='")->Print(desc)->PrintLine("'");
	}
	
	method : public : GetName() ~ String {
		return "";
	}
}
