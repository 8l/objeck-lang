use System.IO;
use System.IO.File;
use Collection;


class Parser {
	function : Main(args : String[]) ~ Nil {
		if(args->Size() = 1) {
			Parse(args[0]);
		};
	}
	
	function : native : Parse(file : String) ~ Nil {
		capture := 0;
		block := "";
		line_num := 0;
		comment_state := 0;							
		reader := FileReader->New(file);
		class_doc : ClassElem;
		while(<>reader->IsEOF()) {
			line := reader->ReadString();
			line_num += 1;
			
			i := 0;	
			while(i < line->Size()) {		
				# skip whitespace
				while((line->Get(i) = ' ' | line->Get(i) = '\t') & i < line->Size()) {
					i += 1;
				};
				
				# parse the line
				if(i < line->Size()) {
					# word
					if(line->Get(i)->IsChar() = true) {
						string := "";
						while(line->Get(i)->IsChar() = true | line->Get(i) = '.') {
							string->Append(line->Get(i));
							i += 1;
						};
						
						if(capture = 2 & string->Equals("class")) {
							capture := 3;
						}
						else if(capture = 2 & (string->Equals("function") | string->Equals("method"))) {
							capture := 4;
						};						
					}
					# other
					else {
						select(line->Get(i)) {
							label '{': {
								if(capture = 3) {
									block->Append(line);
									block->Append('\n');
									class_doc := ClassElem->New(block);								
									block := "";
"---"->PrintLine();									
								}
								else if(capture = 4) {
									block->Append(line);
									block->Append('\n');
									if(class_doc <> Nil) {
										class_doc->AddFunction(block);
										block := "";
"---"->PrintLine();										
									};
								};
								capture := 0;
								comment_state := 0;
							}
			
							label '#': {
								if(comment_state = 2) {
									capture := 2;
									comment_state := 0;
								}
								else if(comment_state = 0) {
									comment_state := 1;
								};
							}

							label '~': {
								if(comment_state = 1) {
									capture := 1;
									comment_state := 0;
								}
								else if(comment_state = 0) {
									comment_state := 2;
								};
							}
					
							other: {
								comment_state := 0;
							}
						};						
					};	
				};
				i += 1;
			};				
			
			if(capture > 0) {
				block->Append(line);
				block->Append('\n');
			};
		};
		reader->Close();
	}
}

class DocElem {
	@buffer : String;
	@buffer_index : Int;
	@cur_char : Char;
	@nxt_char : Char;
	@parsed : Bool;
	
	New(buffer : String) {
		@buffer := buffer;
		@buffer_index := 0;
		@parsed := false;
		NextChar();
	}
	
	method : NextChar() ~ Nil {
		if(@buffer_index < @buffer->Size()) {
			@cur_char := @buffer->Get(@buffer_index);
			@buffer_index += 1;
			if(@buffer_index < @buffer->Size()) {
				@nxt_char := @buffer->Get(@buffer_index);
			}
			else {
				@nxt_char := '\0';
			};
		}
		else {
			@cur_char := '\0';
			@nxt_char := '\0';
		};
	}
	
	method : ParseWhiteSpace() ~ Nil {
		while(@buffer_index < @buffer->Size() & (@cur_char = ' ' | @cur_char = '\t' | @cur_char = '\r' | @cur_char = '\n')) {
			NextChar();
		};
	}

	method : MatchCommentStart() ~ Bool {
		ParseWhiteSpace();
		match := @cur_char = '#' & @nxt_char = '~';
		if(match) {
			NextChar();	NextChar();
			return true;
		};
		
		return false;
	}

	method : MatchCommentEnd() ~ Bool {
		ParseWhiteSpace();
		match := @cur_char = '~' & @nxt_char = '#';
		if(match) {
			NextChar();	NextChar();
			return true;
		};
		
		return false;
	}
	
	method : MatchChar(char : Char) ~ Bool {
		match := @cur_char = char;
		if(match) {
			NextChar();
			return true;
		};
		
		return false;
	}

	method : MatchIdent(ident : String) ~ Bool {
		return ParseIdent()->Equals(ident);
	}

	method : ParseIdent() ~ String {
		ParseWhiteSpace();

		ident := "";
		done := false;
		while(<>done) {
			select(@cur_char) {
				label ' ':
				label '\r':
				label '\n':
				label '{':
				label ':':
				label '(':
				label ')':
				label '~':
				label '#':
				label '\0': {
					done := true;
				}				
				other: {
					ident->Append(@cur_char);
					NextChar();
				}
			};
		};
		
		return ident->Trim();
	}
	
	method : ParseDesc() ~ String {
		ParseWhiteSpace();
		
		ident := "";
		done := false;
		while(<>done) {
			select(@cur_char) {
				label ' ':
				label '\t':
				label '\r':
				label '\n': {
					ParseWhiteSpace();
					ident->Append(' ');
				}
#~
				label '#': {
					ident->Append(' ');
					NextChar();
				}
~#
				label '{':
				label ':':
				label '(':
				label ')':
				label '~':
				label '@':
				label '\0': {
					done := true;
				}				
				other: {
					ident->Append(@cur_char);
					NextChar();
				}
			};
		};
		
		return ident->Trim();
	}

	method : WasParsed() ~ Bool {
		return @parsed;
	}
}

class ClassElem from DocElem {
	@name : String;
	@funcs : StringMap;
	
	New(buffer : String) {
		Parent(buffer);
		@funcs := StringMap->New();
		@parsed := Parse();
	}

	method : public : GetName() ~ String {
		return @name;
	}

	method : public : AddFunction(block : String) ~ Nil {
		func := FuncElem->New(block);
		if(func->WasParsed()) {
			@funcs->Insert(func->GetName(), func);
		};
	}

	method : native : Parse() ~ Bool {
		if(<>MatchCommentStart()) {
			return false;
		};
		desc := ParseDesc();
		if(<>MatchCommentEnd()) {
			return false;
		};

		if(<>MatchIdent("class")) {
			return false;
		};

		@name := ParseIdent();
		if(@name->Size() > 0) {
			return true;
		};
		
		return false;
	}
}

class FuncElem from DocElem {
	enum Type {
		FUNC,
		MTHD,
		PUBLIC,
		PRIVATE,
		NATIVE
	}

	@name : String;
	@params : List;
	
	New(buffer : String) {
		Parent(buffer);
		@params := List->New();
		@parsed := Parse();
	}

	method : public : GetName() ~ String {
		return @name;
	}

	method : native : Parse() ~ Bool {
		if(<>MatchCommentStart()) {
			return false;
		};
		desc := ParseDesc();
IO.Console->Print("func desc='")->Print(desc)->PrintLine("'");

		are_tags := true;
		while(@cur_char <> '\0' & are_tags) {
			type := ParseIdent();
			if(type->Size() > 0) {
IO.Console->Print("param type='")->Print(type)->PrintLine("'");
				if(type->Equals("@param")) {
					param_name := ParseIdent();
					if(param_name->Size() = 0) {
						return false;
					};
IO.Console->Print("\tname='")->Print(param_name)->PrintLine("'");

					param_desc := ParseDesc();
					if(param_desc->Size() = 0) {
						return false;
					};
IO.Console->Print("\tdesc='")->Print(param_desc)->PrintLine("'");
				}
				else if(type->Equals("@return")) {
					param_desc := ParseDesc();
					if(param_desc->Size() = 0) {
						return false;
					};
IO.Console->Print("\tdesc='")->Print(param_desc)->PrintLine("'");
				}
				else {
					return false;
				};
			}
			else {
				are_tags := false;
			};
		};

		if(<>MatchCommentEnd()) {
			return false;
		};

"---"->PrintLine();

		type := ParseIdent();
		if(type->Size() > 0) {
			if(type->Equals("function")) {
				@type := FuncElem->Type->FUNC;
"\tfunction"->PrintLine();
			}
			else if(type->Equals("method")) {
				@type := FuncElem->Type->MTHD;
"\tmethod"->PrintLine();
			}
			else {
				return false;
			};
		};

		ParseWhiteSpace();
		while(MatchChar(':')) {
			meta := ParseIdent();
			if(meta->Size() > 0) {
				if(meta->Equals("public")) {
"\tpublic"->PrintLine();
				}
				else if(meta->Equals("private")) {
"\tprivate"->PrintLine();
				}
				else if(meta->Equals("native")) {
"\tnative"->PrintLine();
				}
				else {
					@name := meta;
				};
			};
			ParseWhiteSpace();
		};

		if(@name = Nil | <>MatchChar('(')) {
			return false;
		};
IO.Console->Print("\tname='")->Print(@name)->PrintLine("'");

		param_name := ParseIdent();
		if(param_name->Size() = 0) {
			return false;
		};
IO.Console->Print("parsed name='")->Print(param_name)->PrintLine("'");

		ParseWhiteSpace();
		if(<>MatchChar(':')) {
			return false;
		};
		
		type_name := "";
		if(<>ParseType(type_name)) {
			return false;
		};
IO.Console->Print("parsed type='")->Print(type_name)->PrintLine("'");
		
		return true;
	}
	
	method : ParseType(type_name : String) ~ Bool {
		ParseWhiteSpace();
		
		if(MatchChar('(')) {
			type_name->Append('(');
			return ParseFuncType(type_name);
		};
		
		ident := ParseIdent();
		status := ident->Size() > 0;
		type_name->Append(ident);
		
		return status;
	}
	
	method : ParseFuncType(type_name : String) ~ Bool {
		return false;
	}
}
