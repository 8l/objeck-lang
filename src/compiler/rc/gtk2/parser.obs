use System.IO;
use System.IO.File;
use Collection;

class Parser {
	function : Main(args : String[]) ~ Nil {
		if(args->Size() = 1) {
			tokens := Scan(args[0]);
			Parse(tokens);
		};
	}

	function : Parse(tokens : Vector) ~ Nil {
		each(i : tokens) {
			token := tokens->Get(i)->As(Token);
			if(token->GetType() = TokenType->VOID | token->GetType() = TokenType->IDENT) {
				i += 1;
				token := tokens->Get(i)->As(Token);
				if(token->GetType() = TokenType->IDENT) {
					fun_name := token->GetValue();
					i += 1;
					token := tokens->Get(i)->As(Token);
					if(token->GetType() = TokenType->OPREN) {
"fun_name='{$fun_name}'"->PrintLine();
						
					};
				};
			};
		};
	}

	function : Scan(file : String) ~ Vector {
		tokens := Vector->New();

		reserved := StringMap->New();
		reserved->Insert("if", IntHolder->New(TokenType->IF->As(Int)));
		reserved->Insert("defined", IntHolder->New(TokenType->DEFINED->As(Int)));
		reserved->Insert("ifndef", IntHolder->New(TokenType->IFNDEF->As(Int)));
		reserved->Insert("endif", IntHolder->New(TokenType->ENDIF->As(Int)));
		reserved->Insert("error", IntHolder->New(TokenType->ERROR->As(Int)));
		reserved->Insert("include", IntHolder->New(TokenType->INCLUDE->As(Int)));
		reserved->Insert("typedef", IntHolder->New(TokenType->TYPEDEF->As(Int)));
		reserved->Insert("void", IntHolder->New(TokenType->VOID->As(Int)));

		line_num := 0;
		comment := false;
		reader := FileReader->New(file);	
		while(reader->IsEOF() <> true) {
			line := reader->ReadString();
			line_num := line_num + 1;
			
			i := 0;  
			while(i < line->Size()) {    
				# skip whitespace
				while((line->Get(i) = ' ' | line->Get(i) = '\t') & i < line->Size()) {
					i += 1;
				};
  
				if(i < line->Size()) {
					cur_char := line->Get(i);
					nxt_char := '\0';
					if(i + 1 < line->Size()) {
						nxt_char := line->Get(i + 1);
					};
  	
					# word
					if(cur_char->IsChar() = true | cur_char = '_') {
						string := String->New();
						while(cur_char->IsChar() = true | cur_char = '_' | cur_char = '.') {
							string->Append(cur_char);
							i += 1;  
							cur_char := line->Get(i);              
							nxt_char := '\0';
							if(i + 1 < line->Size()) {
								nxt_char := line->Get(i + 1);
							};
						};
    
						result := reserved->Find(string)->As(IntHolder);
						if(result <> Nil) {
							if(comment = false) {
# Console->PrintLine(result->Get());
								tokens->AddBack(Token->New(result->Get()->As(TokenType)));
							};
						}
						else {
							if(comment = false) {
# Console->Print("string/var:'")->Print(string)->PrintLine("'");
								tokens->AddBack(Token->New(string));
							};
						};
					}
					# number
					else if(cur_char->IsDigit() = true) {
						number := String->New();
						is_dec := false;
						while(cur_char->IsDigit() = true | cur_char = '.') {
							if(cur_char = '.') {
								is_dec := true;
							};
							number->Append(cur_char);
							i += 1;
							cur_char := line->Get(i);
							nxt_char := '\0';
							if(i + 1 < line->Size()) {
								nxt_char := line->Get(i + 1);
							};
						};

						if(is_dec) {
							if(comment = false) {
# Console->Print("decimal '")->Print(number)->PrintLine("'");
								tokens->AddBack(Token->New(TokenType->DEC, number));
							};
						}
						else {
							if(comment = false) {
# Console->Print("integer '")->Print(number)->PrintLine("'");
								tokens->AddBack(Token->New(TokenType->INT, number));
							};
						};
					}
					# other
					else {
						select(cur_char) {
							label '(': {
								if(comment = false) {
# "opren"->PrintLine();
									tokens->AddBack(Token->New(TokenType->OPREN));
								};
							}

							label ')': {
								if(comment = false) {
# "cpren"->PrintLine();
									tokens->AddBack(Token->New(TokenType->CPREN));
								};
							}

							label '{': {
								if(comment = false) {
# "ocbrace"->PrintLine();
									tokens->AddBack(Token->New(TokenType->OCPREN));
								};  
							}

							label '}': {
								if(comment = false) {
# "ccbrace"->PrintLine();
									tokens->AddBack(Token->New(TokenType->CCPREN));
								};
							}

							label ',': {
								if(comment = false) {
# "comma"->PrintLine();
									tokens->AddBack(Token->New(TokenType->COMMA));
								};
							}

							label ':': {
								if(comment = false) {
# "colon"->PrintLine();
									tokens->AddBack(Token->New(TokenType->COLON));
								};
							}

							label ';': {
								if(comment = false) {
# "semi-colon"->PrintLine();
									tokens->AddBack(Token->New(TokenType->SEMI_COLON));
								};
							}

							label '#': {
								if(comment = false) {
# "pound"->PrintLine();
									tokens->AddBack(Token->New(TokenType->POUND));
								};
							}

							label '!': {
								if(comment = false) {
# "bang"->PrintLine();
									tokens->AddBack(Token->New(TokenType->BANG));
								};
							}

							label '~': {
								if(comment = false) {
# "tilde"->PrintLine();
									tokens->AddBack(Token->New(TokenType->TILDE));
								};
							}

							label '.': {
								if(comment = false) {
# "dot"->PrintLine();
									tokens->AddBack(Token->New(TokenType->DOT));
								};
							}

							label '=': {
								if(comment = false) {
# "equal"->PrintLine();
									tokens->AddBack(Token->New(TokenType->EQUAL));
								};
							}
        
							label '\\': {
								if(comment = false) {
# "back-slash"->PrintLine();
									tokens->AddBack(Token->New(TokenType->BACK_SLASH));
								};
							}

							label '&': {
								if(comment = false) {
# "and"->PrintLine();
									tokens->AddBack(Token->New(TokenType->AND));
								};
							}

							label '-': {
								if(comment = false) {
# "minus"->PrintLine();
									tokens->AddBack(Token->New(TokenType->MINUS));
								};
							}

							label '|': {
								if(comment = false) {
# "or"->PrintLine();
									tokens->AddBack(Token->New(TokenType->OR));
								};
							}

							label '<': {
								if(comment = false) {
# "less"->PrintLine();
									tokens->AddBack(Token->New(TokenType->LESS));
								};
							}

							label '>': {
								if(comment = false) {
# "greater"->PrintLine();
									tokens->AddBack(Token->New(TokenType->GREATER));
								};
							}

							label '"': {
								if(comment = false) {
# "quote"->PrintLine();
									tokens->AddBack(Token->New(TokenType->QUOTE));
								};
							}
        
							label '/': {
								if(nxt_char = '*') {
									comment := true;
									i += 1;
									cur_char := line->Get(i);
									nxt_char := '\0';
									if(i + 1 < line->Size()) {
										nxt_char := line->Get(i + 1);
									};
# "### comment start ###"->PrintLine();
								}
								else {
									if(comment = false) {
# "div"->PrintLine();
										tokens->AddBack(Token->New(TokenType->DIV));
									};
								};
							}
        
							label '*': {
								if(nxt_char = '/') {
									comment := false;
									i += 1;
									cur_char := line->Get(i);
									nxt_char := '\0';
									if(i + 1 < line->Size()) {
										nxt_char := line->Get(i + 1);
									};
# "### comment end ###"->PrintLine();                  	
								}
								else {
									if(comment = false) {
# "mul"->PrintLine();
										tokens->AddBack(Token->New(TokenType->MUL));
									};
								};
							}
     
							other: {
								if(comment = false) {
									Console->Print("char='")->Print(cur_char)->PrintLine("'");
								};
							}
						};
						i += 1;
					};  
				};
			};
		};
		reader->Close();

		return tokens;
	}
}

class Token {
	@type : TokenType;
	@value : String;

	New(type : TokenType, value : String) {
		@type := type;
		@value := value;
	}

	New(type : TokenType) {
		@type := type;
	}

	New(value : String) {
		@type := TokenType->IDENT;
		@value := value;
	}

	method : public : GetType() ~ TokenType {
		return @type;
	}
	
	method  : public : GetValue() ~ String {
		return @value;
	}
}

enum TokenType {
	IF,
	DEFINED,
	IFNDEF,
	ENDIF,
	ERROR,
	INCLUDE,
	TYPEDEF,
	VOID,
	OPREN,
	CPREN,
	OCPREN,
	CCPREN,
	OCPREN,
	COMMA,
	COLON,
	SEMI_COLON,
	POUND,
	BANG,
	TILDE,
	DOT,
	EQUAL,
	BACK_SLASH,
	AND,
	MINUS,
	OR,
	LESS,
	GREATER,
	QUOTE,
	DIV,
	MUL,
	INT,
	DEC,
	IDENT
}

