use IO;
use Struct;

bundle Default {
	class JSONParser {
		@file : String;
		@tokens : Vector;
		@token_pos : Int;
		@cur_token : Token;
		
		New(file : String) {
			@file := file;
			@tokens : Nil;
			@token_pos := 0;
		}

		function : Main(args : String[]) ~ Nil {
			parser := JSONParser->New(args[0]);
			parser->Parse();
		}

		# parse JSON elements
		method : public : Parse() ~ JSONElement {
			@tokens := Scan();
			if(@tokens->Size() > 0) {
DumpTokens(@tokens);
				NextToken();
				
				while(@cur_token->GetType() <> TokenType->EOS) {
					ParseValue();
					NextToken();
				};
			};
			
			return Nil;
    }

		method : GetToken(pos : Int) ~ Token {
			if(pos < @tokens->Size()) {
				return @tokens->Get(pos)->As(Token);
			};
			
			return Token->New(TokenType->EOS);
		}
		
		method : Match(token : TokenType) ~ Bool {
			return @cur_token->GetType() = token;
		}
		
		method : NextToken() ~ Nil {
			if(@token_pos < @tokens->Size()) {
				@cur_token := @tokens->Get(@token_pos)->As(Token);
				@token_pos += 1;
			}
			else {
				@cur_token := Token->New(TokenType->EOS);
			};
		}
		
		method : public : ParseValue() ~ JSONElement {
			element : JSONElement;
			
			select(@cur_token->GetType()) {
				label TokenType->OBR: {
"array"->PrintLine();
					ParseArray();
				}

				label TokenType->OCBR: {
					ParseObject();
"object"->PrintLine();
				}

				label TokenType->IDENT:
				label TokenType->INT_NUM:
 				label TokenType->FLOAT_NUM: {
					element := JSONElement->New(@cur_token);
"value"->PrintLine();
					NextToken();
				}
			};

			return element;
		}

		# parse JSON array
		method : public : ParseObject() ~ JSONElement {
			return Nil;
		}

		# parse JSON array
		method : public : ParseArray() ~ JSONElement {
			elements := Vector->New();
			
			NextToken();
			while(@cur_token->GetType() <> TokenType->EOS & @cur_token->GetType() <> TokenType->CBR) {
				value := ParseValue();
				if(value = Nil) {
					return Nil;
				};
				
				if(Match(TokenType->COMMA) = false & Match(TokenType->CBR) = false) {
@cur_token->GetType()->As(Int)->PrintLine();
					"Expected ',' or ']'"->PrintLine();

					return Nil;
				};
				NextToken();
"comma"->PrintLine();
			};
			
			return JSONElement->New(elements);
		}

		# scan JSON tokens
		method : native : Scan() ~ Vector {
			tokens := Vector->New();
						
			input := FileReader->ReadFile(@file);
			if(input <> Nil) {
				index := 0;				
				while(index < input->Size()) {
					# skip whitespace
					while(index < input->Size() & (input->Get(index) = '\r' | input->Get(index) = '\n' |
						input->Get(index) = '\t' | input->Get(index) = ' ')) {
						# update
						index += 1;
					};

					# parse string
					if(input->Get(index) = '"') {
						index += 1;
						offset := index;
						# TODO: support for '\"'
						while(index < input->Size() & input->Get(index) <> '"') {
							# update
							index += 1;
						};
						len := index - offset;
						if(len > 0) {
							string := input->SubString(offset, len);
							if(string->Equals("true")) {
								tokens->AddBack(Token->New(TokenType->TRUE));
							}
							else if(string->Equals("false")) {
								tokens->AddBack(Token->New(TokenType->FALSE));
							}
							# TODO: translate escape characters
							else {							
								tokens->AddBack(Token->New(TokenType->IDENT, string));
							};
						};
						# update
						index += 1;
					}
					# parse number
					else if(input->Get(index)->IsDigit() | input->Get(index) = '-' | input->Get(index) = '.') {
						offset := index;
						minus_count := 0;
						dot_count := 0;

						# TODO: e digits
						while(index < input->Size() & 
							(input->Get(index)->IsDigit() | input->Get(index) = '-' | input->Get(index) = '.')) {
							if(input->Get(index) = '-') {
								minus_count += 1;
							}
							else if(input->Get(index) = '.') {
								dot_count += 1;
							};
							# update
							index += 1;
						};
						len := index - offset;

						if(len > 0) {
							string := input->SubString(offset, len);
						if(dot_count = 1 & minus_count < 2) {
							tokens->AddBack(Token->New(TokenType->FLOAT_NUM, string));
						}
						else if(dot_count = 0 & minus_count < 2) {
							tokens->AddBack(Token->New(TokenType->INT_NUM, string));
						}
						else {
							tokens->AddBack(Token->New(TokenType->BAD_NUM, string));
						};
					};
				}
				# parse characters
				else {
					select(input->Get(index)) {
							label '[': {
								tokens->AddBack(Token->New(TokenType->OBR));
							}
		
							label ']': {
								tokens->AddBack(Token->New(TokenType->CBR));
							}

							label '{': {
								tokens->AddBack(Token->New(TokenType->OCBR));
							}
		
							label '}': {
								tokens->AddBack(Token->New(TokenType->CCBR));
							}

							label ',': {
								tokens->AddBack(Token->New(TokenType->COMMA));
							}

							label ':': {
								tokens->AddBack(Token->New(TokenType->COLON));
							}

							other: {
								tokens->AddBack(Token->New(TokenType->OTHER));
	# input->Get(index)->As(Int)->PrintLine();
							}
						};
						# update
						index += 1;
					};
				};
			};
			
			return tokens;
	 	}

		method : DumpTokens(tokens : Vector) ~ Nil {
			if(tokens->Size() > 0) {
				each(i : tokens) {
					select(tokens->Get(i)->As(Token)->GetType()) {
						label TokenType->IDENT: {
							IO.Console->Print("token=IDENT, value=")->PrintLine(tokens->Get(i)->As(Token)->GetValue());
						}

						label TokenType->INT_NUM: {
							IO.Console->Print("token=INTEGER, value=")->PrintLine(tokens->Get(i)->As(Token)->GetValue());
						}

						label TokenType->FLOAT_NUM: {
							IO.Console->Print("token=FLOAT, value=")->PrintLine(tokens->Get(i)->As(Token)->GetValue());
						}

						label TokenType->OBR: {
							"token='['"->PrintLine();
						}

						label TokenType->CBR: {
							"token=']'"->PrintLine();
						}            

						label TokenType->OCBR: {
							"token='{'"->PrintLine();
						}

						label TokenType->CCBR: {
							"token='}'"->PrintLine();
						}

						label TokenType->PREN: {
							"token='\"'"->PrintLine();
						}

						label TokenType->COLON: {
							"token=':'"->PrintLine();
						}

						label TokenType->COMMA: {
							"token=','"->PrintLine();
						}

						label TokenType->OTHER: 
						label TokenType->BAD_NUM: {
							"token=OTHER"->PrintLine();
						}						
					};
				};
			};
		}
	}

	# JSON element
	class JSONElement {
		@token : Token;
		@elements : Vector;
		
		New(token : Token) {
			@token := token;
		}

		New(elements : Vector) {
			@elements := elements;
		}
	}

	enum JSONType {
		STRING,
		NUMBER,
		OBJECT,
		ARRAY
	}
	
	# token class
	class Token {
		@type : TokenType;
		@value : String;
		
		New(type : TokenType, value : String) {
			@type := type;
			@value := value;
		}
			
		New(type : TokenType) {
			@type := type;
			@value := Nil;
		}

		method : public : GetType() ~ TokenType {
			return @type;
		}

		method : public : GetValue() ~ String {
			return @value;
		}
	}
	
	# token type
	enum TokenType {
		IDENT,
		INT_NUM,
		FLOAT_NUM,
		BAD_NUM,
		TRUE,
		FALSE,
		COMMA,
		OBR,
		CBR,
		OCBR,
		CCBR,
		PREN,
		COLON,
		OTHER,
		EOS
	}
}
