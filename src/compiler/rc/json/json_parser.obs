use IO;
use Struct;

bundle Default {
	class Parser {
		function : Main(args : String[]) ~ Nil {
			if(args->Size() = 1) {
				tokens := Scan(args[0]);
				if(tokens->Size() > 0) {
					each(i : tokens) {
						select(tokens->Get(i)->As(Token)->GetType()) {
							label TokenType->IDENT: {
								IO.Console->Print("token=IDENT, value=")->PrintLine(tokens->Get(i)->As(Token)->GetValue());
							}

              label TokenType->INT_NUM: {
								IO.Console->Print("token=INTEGER, value=")->PrintLine(tokens->Get(i)->As(Token)->GetValue());
							}

              label TokenType->FLOAT_NUM: {
								IO.Console->Print("token=FLOAT, value=")->PrintLine(tokens->Get(i)->As(Token)->GetValue());
							}

              label TokenType->OBR: {
                "token='['"->PrintLine();
              }

              label TokenType->CBR: {
                "token=']'"->PrintLine();
              }            

              label TokenType->OCBR: {
                "token='{'"->PrintLine();
              }

              label TokenType->CCBR: {
                "token='}'"->PrintLine();
              }

              label TokenType->PREN: {
               "token='\"'"->PrintLine();
              }

              label TokenType->COLON: {
               "token=':'"->PrintLine();
              }

              label TokenType->COMMA: {
               "token=','"->PrintLine();
              }

              label TokenType->OTHER: 
              label TokenType->BAD_NUM: {
               "token=OTHER"->PrintLine();
              }						
            };
					};
				};
			};
		}
    
		function : native : Scan(file : String) ~ Vector {
			index := 0;
			tokens := Vector->New();
			
			input := FileReader->ReadFile(file);			
			while(index < input->Size()) {
				# skip whitespace
				while(index < input->Size() & (input->Get(index) = '\r' | input->Get(index) = '\n' |
					input->Get(index) = '\t' | input->Get(index) = ' ')) {
					index += 1;
				};

				# parse string
				if(input->Get(index) = '"') {
					index += 1;
					offset := index;
          # TODO: support for '\"'
					while(index < input->Size() & input->Get(index) <> '"') {
            # update
						index += 1;
					};
					len := index - offset;
					if(len > 0) {
						string := input->SubString(offset, len);
						tokens->AddBack(Token->New(TokenType->IDENT, string));
					};
          index += 1;
				}
        # parse number
        else if(input->Get(index)->IsDigit() | input->Get(index) = '-' | input->Get(index) = '.') {
          offset := index;
          # TODO: validation float vs. integer
          minus_count := 0;
          dot_count := 0;
					while(index < input->Size() & 
            (input->Get(index)->IsDigit() | input->Get(index) = '-' | input->Get(index) = '.')) {
            if(input->Get(index) = '-') {
              minus_count += 1;
            }
            else if(input->Get(index) = '.') {
              dot_count += 1;
            };
            # update
            index += 1;
					};
					len := index - offset;
          if(len > 0) {
						string := input->SubString(offset, len);
            if(dot_count = 1 & minus_count < 2) {
						  tokens->AddBack(Token->New(TokenType->FLOAT_NUM, string));
            }
            else if(dot_count = 0 & minus_count < 2) {
              tokens->AddBack(Token->New(TokenType->INT_NUM, string));
            }
            else {
              tokens->AddBack(Token->New(TokenType->BAD_NUM, string));
            };
					};
          index += 1;
        }
				# parse characters
				else {
					select(input->Get(index)) {
						label '[': {
							tokens->AddBack(Token->New(TokenType->OBR));
						}
		
						label ']': {
							tokens->AddBack(Token->New(TokenType->CBR));
						}

						label '{': {
							tokens->AddBack(Token->New(TokenType->OCBR));
						}
		
						label '}': {
							tokens->AddBack(Token->New(TokenType->CCBR));
						}

						label ',': {
							tokens->AddBack(Token->New(TokenType->COMMA));
						}

            label ':': {
							tokens->AddBack(Token->New(TokenType->COLON));
						}

						other: {
							tokens->AddBack(Token->New(TokenType->OTHER));
input->Get(index)->As(Int)->PrintLine();
						}
					};
					index += 1;
				};
			};
			
			return tokens;
	 	}
	}
	
	# token class
	class Token {
		@type : TokenType;
		@value : String;
		
		New(type : TokenType, value : String) {
			@type := type;
			@value := value;
		}
			
		New(type : TokenType) {
			@type := type;
			@value := Nil;
		}

		method : public : GetType() ~ TokenType {
			return @type;
		}

		method : public : GetValue() ~ String {
			return @value;
		}
	}
	
	# token type
	enum TokenType {
		IDENT,
    INT_NUM,
    FLOAT_NUM,
    BAD_NUM,
		COMMA,
		OBR,
		CBR,
		OCBR,
		CCBR,
		PREN,
    COLON,
		OTHER
	}
}
