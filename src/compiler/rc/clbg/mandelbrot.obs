use Concurrency;

bundle Default {

	class MandelBrot {
		function : Main(args : String[]) ~ Nil {
#			n := 200;
			n := 100;
         if (args->Size() > 0) {
            n := args[0]->ToInt();
         };

			width_bytes := n/8+1;
			output_data := Byte->New[n, width_bytes];

			CaculateThread->Init(n, output_data);

			threads := Thread->New[1];
			each(i : threads) {
				threads[i] := CaculateThread->New(i->ToString());
			};
			each(i : threads) {
				threads[i]->Execute(Nil);
			};
			each(i : threads) {
				threads[i]->Join();
			};

			IO.Console->Print("P4\n")->Print(n)->Print(' ')->Print(n)->Print('\n');
			for(i := 0; i < n; i+=1;) {
				for(j := 0; j < width_bytes; j+=1;) {
					output_data[i,j]->Print();
				};
			};
		}
	}

	class CaculateThread from Thread {
		@size : static : Int;
		@output_data : static : Byte[,];
		@bytes_per_line : static : Int[];
		@inverse_N : static : Float;
		@current_line : static : Int;
		@inc_mutex : static : ThreadMutex;

		New(id : String) {
			Parent(id);
		}

		function : Init(size : Int, output_data : Byte[,]) ~ Nil {
			@size := size;
			@output_data := output_data;
#			width_bytes := size/8+1;
#			@output_data := Byte->New[size, width_bytes];
			bytes_per_line := Int->New[size];
			@inverse_N := 2.0 / size;
			@current_line := 0;
			@inc_mutex := ThreadMutex->New("inc_mutex");

#			Compute(size, output_data, bytes_per_line);
		}

		method : public : Run(param : System.Base) ~ Nil {
			Compute();
		}

		method : native : Compute() ~ Nil {
			y : Int;

			while(true) {
				critical(@inc_mutex) {
					y := @current_line;
					@current_line+=1;
				};

				if(y >= @size) {
					return;
				};

				bit_num := 0;
				byte_count := 0;
				byte_accumulate := 0;
									
				Civ := y->As(Float) * @inverse_N - 1.0;

				for(x := 0; x < @size; x+=1;) {
					Crv := x->As(Float) * @inverse_N - 1.5;
                            
					Zrv := Crv;
					Ziv := Civ;

					Trv := Crv * Crv;
					Tiv := Civ * Civ;
                            
					i := 49;
					do {
						Ziv := (Zrv * Ziv) + (Zrv * Ziv) + Civ;
                  Zrv := Trv - Tiv + Crv;

						Trv := Zrv * Zrv;
						Tiv := Ziv * Ziv;

						i -= 1;
					}
					while(((Trv + Tiv) <= 4.0) & (i > 0));

					byte_accumulate := byte_accumulate << 1;	
					if(i = 0) {
						byte_accumulate+=1;
					};

					bit_num += 1;
					if(bit_num = 8) {					
						@output_data[y, byte_count] := byte_accumulate->As(Byte);
						byte_count += 1;
						bit_num := 0;
						byte_accumulate := 0;
					};
				};

				if(bit_num <> 0) {
					byte_accumulate := byte_accumulate << (8 - (@size and 7));
					@output_data[y, byte_count] := byte_accumulate->As(Byte);
					byte_count += 1;
				};	
			};
		}
	}
}
