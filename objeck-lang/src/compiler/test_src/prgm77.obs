use IO;
use Structure;

bundle Default {
	class Test {
		function : Main(args : String[]) ~ Nil {
			if(args->Size() = 1) {
				parser := XmlParser->New(args[0]);
				parser->Parse();
			};
		}
	}
	
	# xml parser
	class XmlParser {
		@buffer : Byte[];
		@buffer_pos : Int;
		@error_msg : String;
		
		New(file : String) {
			# read in file
			len := File->Size(file);
			@buffer := Byte->New[len];
			in := FileReader->New(file);
			if(in->IsOpen()) {
				in->ReadBuffer(0, len, @buffer);
				in->Close();
			} 
			else {
				@error_msg := "Unable to open file: ";
				@error_msg->Append(file);
			};
			@buffer_pos := 0;
		}
		
		New(buffer : Byte[]) {
			@buffer := buffer;
			@buffer_pos := 0;
		}
		
		method : public : Parse() ~ Bool {
			if(@error_msg <> Nil) {
				Console->GetInstance()->Print("error: ")->Print(@error_msg)->PrintLine();
				return false;
			};
		
			stack := Stack->New();
			tag := ParseTag();
			while(tag <> Nil) {
				if(tag->GetType() = TagType->OPENING) {
					stack->Push(tag->As(Base));
				}
				else if(tag->GetType() = TagType->CLOSING) {
					top : Tag := stack->Top()->As(Tag);
					if(top->GetType() = TagType->OPENING) {
						stack->Pop();
					}
					else {
						@error_msg := "Mismatch tag types";
					};
					
					if(top->GetName()->Equals(tag->GetName()) <> true) {
						@error_msg := "Mismatch tag names";
					};
				};
				
tag->GetName()->PrintLine();
if(tag->GetContents() <> Nil) {
	'\t'->Print(); tag->GetContents()->PrintLine();
};
				
				if(@error_msg <> Nil) {
					Console->GetInstance()->Print("error: ")->Print(@error_msg)->PrintLine();
					return false;
				};
				
				# update
				tag := ParseTag();
			};
			
			if(@error_msg = Nil) {
				"\nsuccess!"->PrintLine();
			}
			else {
				Console->GetInstance()->Print("\nerror: ")->Print(@error_msg)->PrintLine();
			};
			
			return true;
		}
		
		method : IgnoreWhiteSpace() ~ Nil {
			# ignore whitespace
			while(@buffer_pos < @buffer->Size() & WhiteSpace(@buffer[@buffer_pos])) {
				@buffer_pos += 1;
			};
		}
		
		method : WhiteSpace(c : Byte) ~ Bool {
			if(c = ' ' | c = '\t' | c = '\r' | c = '\n') {
				return true;
			};
			
			return false;
		}
		
		method : public : ParseTag() ~ Tag {
			IgnoreWhiteSpace();
			while(@buffer_pos >= @buffer->Size()) {
				return Nil;
			};
			
			if(@buffer_pos < @buffer->Size() & @buffer_pos < @buffer->Size() & 
				@buffer[@buffer_pos] <> '<') {
				@error_msg := "Expected opening tag...";
				return Nil;
			};
			@buffer_pos += 1;
			
			IgnoreWhiteSpace();
			is_end_tag := false;
			if(@buffer_pos < @buffer->Size() & @buffer[@buffer_pos] = '/') {
				is_end_tag := true;
				@buffer_pos += 1;
			};
			
			IgnoreWhiteSpace();
			start_pos := @buffer_pos;
			while(@buffer_pos < @buffer->Size() & @buffer[@buffer_pos] <> '/' & 
				@buffer[@buffer_pos] <> '>' & WhiteSpace(@buffer[@buffer_pos]) = false) {
				@buffer_pos += 1;
			};
			# copy tag name
			tag_name := String->New();
			for(i := start_pos; i < @buffer_pos; i += 1;) {
				tag_name->Append(@buffer[i]);
			};
			
			# unary
			IgnoreWhiteSpace();
			is_unary_tag := false;
			if(@buffer_pos < @buffer->Size() & @buffer[@buffer_pos] = '/') {
				is_unary_tag := true;
				@buffer_pos += 1;
			};
			
			if(is_unary_tag & is_end_tag) {
				@error_msg := "Invalid tag: end and unary tag...";
				return Nil;
			};
			
			if(@buffer_pos < @buffer->Size() & @buffer[@buffer_pos] = '>') {
				@buffer_pos += 1;
			}
			else {
			@buffer[@buffer_pos]->PrintLine();
				@error_msg := "Expected closing tag..";
				return Nil;
			};
			
			# copy tag conents
			IgnoreWhiteSpace();
			start_pos := @buffer_pos;
			while(@buffer_pos < @buffer->Size() & @buffer[@buffer_pos] <> '<') {
				@buffer_pos += 1;
			};
			tag_contents : String := Nil;
			if(@buffer_pos > start_pos) {
				tag_contents := String->New();
				for(i := start_pos; i < @buffer_pos; i += 1;) {
					tag_contents->Append(@buffer[i]);
				};
			};				
			
#~			
			if(tag_contents <> Nil) {
				Console->GetInstance()->Print("contents: ")->Print(tag_contents)->PrintLine();
			};
~#

			type : TagType;
			if(is_unary_tag) {
				type := TagType->UNARY;
			}
			else if(is_end_tag) {
				type := TagType->CLOSING;
			}
			else {
				type := TagType->OPENING;
			};
			
			return Tag->New(tag_name, type, tag_contents);
		}
	}
	
	# tag class
	class Tag {
		@name : String;
		@type : TagType;
		@contents : String;
		
		New(name : String, type : TagType, contents : String) {
			@name := name;
			@type := type;
			@contents := contents;
		}
		
		method : public : GetName() ~ String {
			return @name;
		}
		
		method : public : GetType() ~ TagType {
			return @type;
		}
		
		method : public : GetContents() ~ String {
			return @contents;
		}
	}
	
	# tag type
	enum TagType {
		OPENING,
		CLOSING,
		UNARY
	}
}

