use IO;
use Structure;

bundle Default {
	class Test {
		function : Main(args : String[]) ~ Nil {
			len := File->Size("in.xml");
			buffer := Byte->New[len];
			in := FileReader->New("in.xml");
			if(in <> Nil) {
				in->ReadBuffer(0, len, buffer);
				in->Close();
				
				parser := XmlParser->New(buffer);
				parser->Parse();
			};
		}
	}
	
	class XmlParser {
		@buffer : Byte[];
		@buffer_pos : Int;
		@error_msg : String;
		
		New(buffer : Byte[]) {
			@buffer := buffer;
			@buffer_pos := 0;
		}
		
		method : public : Parse() ~ Nil {
			tag := ParseTag();
			while(tag <> Nil) {
				tag->GetName()->PrintLine();
				# update
				tag := ParseTag();
			};
		}
		
		method : IgnoreWhiteSpace() ~ Nil {
			# ignore whitespace
			while(@buffer_pos < @buffer->Size() & (@buffer[@buffer_pos] = ' ' | 
				@buffer[@buffer_pos] = '\t' | @buffer[@buffer_pos] = '\r' |
				@buffer[@buffer_pos] = '\n')) {
				@buffer_pos += 1;
			};
		}
		
		method : public : ParseTag() ~ Tag {
			IgnoreWhiteSpace();
			if(@buffer_pos < @buffer->Size() & @buffer_pos < @buffer->Size() & 
				@buffer[@buffer_pos] <> '<') {
				@error_msg := "Expected opening tag...";
				return Nil;
			};
			@buffer_pos += 1;
			
			IgnoreWhiteSpace();
			is_end_tag := false;
			if(@buffer_pos < @buffer->Size() & @buffer[@buffer_pos] = '/') {
				is_end_tag := true;
				@buffer_pos += 1;
			};
			
			IgnoreWhiteSpace();
			start_pos := @buffer_pos;
			while(@buffer_pos < @buffer->Size() & @buffer[@buffer_pos] <> '\\' & 
				@buffer[@buffer_pos] <> '>' & @buffer[@buffer_pos] <> ' ' & 
				@buffer[@buffer_pos] <> '\t' & @buffer[@buffer_pos] <> '\r' & 
				@buffer[@buffer_pos] <> '\n') {
				@buffer_pos += 1;
			};
			
			tag_name := String->New();
			for(i := start_pos; i < @buffer_pos; i += 1;) {
				tag_name->Append(@buffer[i]);
			};
			
			IgnoreWhiteSpace();
			is_unary_tag := false;
			if(@buffer_pos < @buffer->Size() & @buffer[@buffer_pos] = '/') {
				is_unary_tag := true;
				@buffer_pos += 1;
			};
			
			if(is_unary_tag & is_end_tag) {
				@error_msg := "Invalid tag: end and unary tag...";
				return Nil;
			};
			
			if(@buffer_pos < @buffer->Size() & @buffer[@buffer_pos] = '>') {
				@buffer_pos += 1;
			}
			else {
				@error_msg := "Expected closing tag..";
				return Nil;
			};
			
#			Console->GetInstance()->Print("tag: ")->Print(tag_name)->Print(", is_end: ")->PrintLine(is_end_tag);

			type : TagType;
			if(is_unary_tag) {
				type := TagType->UNARY;
			}
			else if(is_end_tag) {
				type := TagType->CLOSING;
			}
			else {
				type := TagType->OPENING;
			};
			
			return Tag->New(tag_name, type);
		}
	}
	
	enum TagType {
		OPENING,
		CLOSING,
		UNARY
	}
	
	class Tag {
		@name : String;
		@type : TagType;
		
		New(name : String, type : TagType) {
			@name := name;
			@type := type;
		}
		
		method : public : GetName() ~ String {
			return @name;
		}
	}
}

