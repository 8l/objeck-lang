#~~
# R. Hollines
# XML parsing library
~~#

use IO;
use Structure;

bundle XML {
	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	# XML Parser class
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~# 
	class XmlParser {
		@buffer : Byte[];
		@buffer_pos : Int;
		@error_msg : String;
		@root : XMLElement;
		@declarations : StringHash;
		
		New(file : String) {
			# read in file
			len := File->Size(file);
			@buffer := Byte->New[len];
			in := FileReader->New(file);
			if(in->IsOpen()) {
				in->ReadBuffer(0, len, @buffer);
				in->Close();
			} 
			else {
				@error_msg := "Unable to open file: ";
				@error_msg->Append(file);
			};
			
			@buffer_pos := 0;
			@declarations := StringHash->New();
		}
		
		New(buffer : Byte[]) {
			@buffer := buffer;
			@buffer_pos := 0;
			@declarations := StringHash->New();
		}
		
		method : public : GetError() ~ String {
			return @error_msg;
		}
		
		function : EncodeString(in : String) ~ String {
			out := String->New();
			
			each(i : in) {
				c := in->Get(i);
				select(c) {
					label ' ': {
						out->Append("&#x20;");
					}
					
					label '\t': {
						out->Append("&#x9;");
					}
					
					label '\n': {
						out->Append("&#xA;");
					}
					
					label '\r': {
						out->Append("&#xD;");
					}
					
					other: {
						out->Append(c);
					}
				};
			};
			
			return out;
		}
		
		function : DecodeString(in : String) ~ String {
			max := in->Size();
			i := 0;
			
			out := String->New();
			while(i < max) {
				c := in->Get(i);
				# &lt;
				if(c = '&') {
					i += 1;
					if(i < max & in->Get(i) = 'l') {
						i += 1;
						if(i < max & in->Get(i) = 't') {
							i += 1;
							if(i < max & in->Get(i) = ';') {
								out->Append('<');
							}
							else {
								out->Append(c);
							};
						}
						else {
							out->Append(c);
						};
					}
					# &gt;
					else if(i < max & in->Get(i) = 'g') {
						i += 1;
						if(i < max & in->Get(i) = 't') {
							i += 1;
							if(i < max & in->Get(i) = ';') {
								out->Append('>');
							}
							else {
								out->Append(c);
							};
						}
						else {
							out->Append(c);
						};
					}
					# &amp;
					else if(i < max & in->Get(i) = 'a') {
						i += 1;
						if(i < max & in->Get(i) = 'm') {
							i += 1;
							if(i < max & in->Get(i) = 'p') {
								i += 1;
								if(i < max & in->Get(i) = ';') {
									out->Append('&');
								}
								else {
									out->Append(c);
								};
							}
							else {
								out->Append(c);
							};
						}
						else if(i < max & in->Get(i) = 'p') {
							i += 1;
							if(i < max & in->Get(i) = 'o') {
								i += 1;
								if(i < max & in->Get(i) = 's') {
									i += 1;
									if(i < max & in->Get(i) = ';') {
										out->Append('\'');
									}
									else {
										out->Append(c);
									};
								}
								else {
									out->Append(c);
								};
							}
							else {
								out->Append(c);
							};
						};
					}
					# &quot;
					else if(i < max & in->Get(i) = 'q') {
						i += 1;
						if(i < max & in->Get(i) = 'u') {
							i += 1;
							if(i < max & in->Get(i) = 'o') {
								i += 1;
								if(i < max & in->Get(i) = 't') {
									i += 1;
									if(i < max & in->Get(i) = ';') {
										out->Append('"');
									}
									else {
										out->Append(c);
									};
								}
								else {
									out->Append(c);
								};
							}
							else {
								out->Append(c);
							};
						}
						else {
							out->Append(c);
						};
					}
					# &quot;
					else if(i < max & in->Get(i) = '#') {
						i += 1;
						if(i < max & in->Get(i) = 'x') {
							i += 1;
							str_num := "0x";
							while(i < max & (in->Get(i)->IsDigit() | 
								(in->Get(i) >= 'a' & in->Get(i) <= 'f') |
								(in->Get(i) >= 'A' & in->Get(i) <= 'F'))) {
								str_num->Append(in->Get(i));
								i += 1;
							};
							
							if(i < max & in->Get(i) = ';') {
								str_num->ToInt()->PrintLine();
								out->Append(str_num->ToInt()->As(Char));
							}
							else {
								out->Append(str_num);
							};
						};
					}
					else {
						out->Append(c);
					};
				}
				else {
					out->Append(c);
				};
				
				# update
				i += 1;
			};
			
			return out;
		}
		
		method : public : GetVersion() ~ String {
			element : XMLElement := @declarations->Find("xml")->As(XMLElement);
			if(element <> Nil) {
				return element->GetAttribute("version");
			};
			
			return "unknown";
		}
		
		method : public : GetEncoding() ~ String {
			element : XMLElement := @declarations->Find("xml")->As(XMLElement);
			if(element <> Nil) {
				return element->GetAttribute("encoding");
			};
			
			return "unknown";
		}
		
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# parses element tags
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~# 
		method : public : Parse() ~ Bool {
			if(@error_msg <> Nil) {
				return false;
			};
			
			# parser first tag
			tag := ParseElement();
			if(@error_msg <> Nil) {
				return false;
			};

			# parse declarations
			while(tag->GetType() = XMLElementType->DECLARATION) {
				@declarations->Insert(tag->GetName(), tag->As(Base));
				# update
				tag := ParseElement();
				if(@error_msg <> Nil) {
					return false;
				};
			};
			
			# find root
			if(tag->GetType() = XMLElementType->OPENING_ELEMENT) {
				@root := tag;
			}
			else {
				@error_msg := "Invalid root element...";
				return false;
			};
			
			stack := Stack->New();
			while(tag <> Nil) {
				# update element stack
				if(tag->GetType() = XMLElementType->OPENING_ELEMENT) {
					parent : XMLElement;
					if(stack->IsEmpty() = false) {
						parent := stack->Top()->As(XMLElement);
						parent->AddChild(tag);
					};
					stack->Push(tag->As(Base));
				}
				else if(tag->GetType() = XMLElementType->UNARY_ELEMENT | 
					tag->GetType() = XMLElementType->CDATA) {
					parent : XMLElement;
					if(stack->IsEmpty() = false) {
						parent := stack->Top()->As(XMLElement);
						parent->AddChild(tag);
					};
				}
				else if(tag->GetType() = XMLElementType->CLOSING_ELEMENT) {
					top : XMLElement := stack->Top()->As(XMLElement);
					if(top->GetType() = XMLElementType->OPENING_ELEMENT) {
						stack->Pop();
					}
					else {
						@error_msg := "Mismatch tag types...";
						return false;
					};
					
					if(top->GetName()->Equals(tag->GetName()) <> true) {
						@error_msg := "Mismatch tag names...";
						return false;
					};
				}
				else {
					@error_msg := "Invalid tag type...";
					return false;
				};
				
				if(@error_msg <> Nil) {
					return false;
				};
				
				# update
				tag := ParseElement();
				if(@error_msg <> Nil) {
					return false;
				};
			};
			
			return true;
		}
		
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# ignores whitespace
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~# 
		method : native : IgnoreWhiteSpace() ~ Nil {
			# ignore whitespace
			while(@buffer_pos < @buffer->Size() & WhiteSpace(@buffer[@buffer_pos])) {
				@buffer_pos += 1;
			};
		}
		
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# parse attribute name
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~# 
		method : native : ParseName() ~ String {
			# check name start
			if(@buffer_pos < @buffer->Size() & (@buffer[@buffer_pos]->As(Char)->IsChar() |
				@buffer[@buffer_pos] = ':' | @buffer[@buffer_pos] = '_')) {
				# look for name end
				start_pos := @buffer_pos;
				while(@buffer_pos < @buffer->Size() &	(@buffer[@buffer_pos]->As(Char)->IsChar() | 
					@buffer[@buffer_pos]->As(Char)->IsDigit() |
					@buffer[@buffer_pos] = '-' | @buffer[@buffer_pos] = '_' | 
					@buffer[@buffer_pos] = '.')) {
					@buffer_pos += 1;
				};
				
				# copy buffer
				name := String->New();
				for(i := start_pos; i < @buffer_pos; i += 1;) {
					name->Append(@buffer[i]);
				};
				
				return name;
			};
			
			return Nil;
		}
		
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# parse attribute value
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~# 
		method : native : ParseValue() ~ String {
			# check name start
			if(Match('"')) {
				# look for name end
				@buffer_pos += 1;
				start_pos := @buffer_pos;
				while(Unmatch('"')) {
					@buffer_pos += 1;
				};
				
				if(Match('"')) {
					# copy buffer
					name := String->New();
					for(i := start_pos; i < @buffer_pos; i += 1;) {
						c : Byte := @buffer[i];
						select(c) {
							label ' ': {
								name->Append("&#x20;");
							}
							
							label '\t': {
								name->Append("&#x9;");
							}
							
							label '\n': {
								name->Append("&#xA;");
							}
							
							label '\r': {
								name->Append("&#xD;");
							}
							
							other: {
								name->Append(@buffer[i]);
							}
						};
					};
					@buffer_pos += 1;
					
					return name;
				};
				
				return Nil;
			}
			else if(Match('\'')) {
				# look for name end
				@buffer_pos += 1;
				start_pos := @buffer_pos;
				while(Unmatch('\'')) {
					@buffer_pos += 1;
				};
				
				if(Match('\'')) {
					# copy buffer
					name := String->New();
					for(i := start_pos; i < @buffer_pos; i += 1;) {
						c : Byte := @buffer[i];
						select(c) {
							label ' ': {
								name->Append("&#x20;");
							}
							
							label '\t': {
								name->Append("&#x9;");
							}
							
							label '\n': {
								name->Append("&#xA;");
							}
							
							label '\r': {
								name->Append("&#xD;");
							}
							
							other: {
								name->Append(@buffer[i]);
							}
						};
					};
					@buffer_pos += 1;
					
					return name;
				};
				
				return Nil;
			};
			
			return Nil;
		}
		
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# define whitespce
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~# 
		method : native : WhiteSpace(c : Byte) ~ Bool {
			if(c = ' ' | c = '\t' | c = '\r' | c = '\n') {
				return true;
			};
			
			return false;
		}
		
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# match and unmatch
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~# 
		method : native : Match(c : Char) ~ Bool {
			if(@buffer_pos < @buffer->Size() & @buffer[@buffer_pos] = c) {
				return true;
			};
			
			return false;
		}
		
		method : native : Unmatch(c : Char) ~ Bool {
			if(@buffer_pos < @buffer->Size() & @buffer[@buffer_pos] <> c) {
				return true;
			};
			
			return false;
		}
		
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# parse element
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~# 
		method : public : native : ParseElement() ~ XMLElement {
			# are we done?
			IgnoreWhiteSpace();
			if(@buffer_pos = @buffer->Size()) {
				return Nil;
			};
			
			# looks for '<'
			if(Unmatch('<')) {
				@error_msg := "Expected '<'...";
				return Nil;
			};
			@buffer_pos += 1;
			IgnoreWhiteSpace();
			
			
			is_end_tag := false;
			is_dclr_tag := false;
			
			# looks for '</'
			if(Match('/')) {
				is_end_tag := true;
				@buffer_pos += 1;
			}
			# looks for '<?xml'
			else if(Match('?')) {
				@buffer_pos += 1;
				is_dclr_tag := true;
			}
			# looks for '<!'
			else if(Match('!')) {
				@buffer_pos += 1;
			
      	# comment
      	if(Match('-')) {
					@buffer_pos += 1;
					
					if(Unmatch('-')) {
						@error_msg := "Unsupported tag...";
						return Nil;
      		};
      		@buffer_pos += 1;
      	
      		# ignore commented chars
      		state := 0;
					while(@buffer_pos < @buffer->Size() & state < 3) {
						@buffer_pos += 1;
										
						# match comment end
						if(Match('-')) {
							if(state = 0) {
								state := 1;
							}
							else if(state = 1) {
								state := 2;
							}
							else {
								state := 0;
							};
						}
						else if(Match('>') & state = 2) {
							state := 3;
							@buffer_pos += 1;
						}
						else {
							state := 0;
						};
					};
					
					# reset for comment
					IgnoreWhiteSpace();
					if(@buffer_pos = @buffer->Size()) {
						return Nil;
					};
					
					# looks for '<'
					if(Unmatch('<')) {
						@error_msg := "Expected '<'...";
						return Nil;
					};
					@buffer_pos += 1;
					IgnoreWhiteSpace();
					
					# looks for '</'
					is_end_tag := false;
					if(Match('/')) {
						is_end_tag := true;
						@buffer_pos += 1;
					};
				}
				# cdata section
				else if(Match('[')) {
					@buffer_pos += 1;
					
					if(Unmatch('C')) {
						@error_msg := "Unsupported tag...";
						return Nil;
      		};
      		@buffer_pos += 1;
      		
      		if(Unmatch('D')) {
						@error_msg := "Unsupported tag...";
						return Nil;
      		};
      		@buffer_pos += 1;
      		
      		if(Unmatch('A')) {
						@error_msg := "Unsupported tag...";
						return Nil;
      		};
      		@buffer_pos += 1;
      		
      		if(Unmatch('T')) {
						@error_msg := "Unsupported tag...";
						return Nil;
      		};
      		@buffer_pos += 1;
      		
      		if(Unmatch('A')) {
						@error_msg := "Unsupported tag...";
						return Nil;
      		};
      		@buffer_pos += 1;
      		
      		if(Unmatch('[')) {
						@error_msg := "Unsupported tag...";
						return Nil;
      		};
      		@buffer_pos += 1;
				
					# ignore commented chars
      		state := 0;
      		start_pos := 0;
					while(@buffer_pos < @buffer->Size() & state < 3) {
						@buffer_pos += 1;
										
						# match comment end
						if(Match(']')) {
							if(state = 0) {
								state := 1;
							}
							else if(state = 1) {
								state := 2;
							}
							else {
								state := 0;
							};
						}
						else if(Match('>') & state = 2) {
							state := 3;
							@buffer_pos += 1;
						};
					};
					
					# copy data
					data := String->New();
					for(i := start_pos; i < @buffer_pos - 3; i += 1;) {
						data->Append(@buffer[i]);
					};
					
					return XMLElement->New(Nil->As(String), XMLElementType->CDATA, 
						Nil->As(StringHash), data);
				}
				else {
					@error_msg := "Unsupported tag...";
					return Nil;
				};
			};
			
			# looks for tag name
			IgnoreWhiteSpace();
			tag_name := ParseName();
			if(tag_name = Nil) {
				@error_msg := "Invalid tag name...";
				return Nil;
      };
      
# Console->GetInstance()->Print("name: ")->PrintLine(tag_name); 
      
      # look for attributes
      IgnoreWhiteSpace();
      attrib_key := ParseName();
      if(attrib_key <> Nil & is_end_tag) {
      	@error_msg := "End tags may not have attributes...";
				return Nil;
      };
      
      attribs : StringHash := Nil; 
      if(attrib_key <> Nil) {
      	attribs := StringHash->New();
      	while(attrib_key <> Nil) {	
      	
# Console->GetInstance()->Print("key: ")->PrintLine(attrib_key);    
				
					IgnoreWhiteSpace();
					if(Unmatch('=')) {
						@error_msg := "Expected '='...";
						return Nil;
					};
					@buffer_pos += 1;
					
					# looks for tag value
					IgnoreWhiteSpace();
					attrib_value := ParseValue();
					if(attrib_value = Nil) {
						@error_msg := "Invalid tag name...";
						return Nil;
					};
					
# Console->GetInstance()->Print("value: ")->PrintLine(attrib_value);    
					
					attribs->Insert(attrib_key, attrib_value->As(Base));
					
					# update
					IgnoreWhiteSpace();
					attrib_key := ParseName();
				};
      };
      
			# unary
			is_unary_tag := false;
			if(Match('/')) {
				is_unary_tag := true;
				@buffer_pos += 1;
			};
			if(is_unary_tag & is_end_tag) {
				@error_msg := "Tag cannot be an end and unary tag...";
				return Nil;
			};
			
			if(Match('?')) {
			
				if(is_dclr_tag = false) {
					@error_msg := "Invalid declaration tag...";
					return Nil;
				};
				@buffer_pos += 1;
			};
			
			IgnoreWhiteSpace();
			if(Match('>')) {
				@buffer_pos += 1;
			}
			else {
				@error_msg := "Expected closing tag...";
				return Nil;
			};
			
			# copy tag contents
			start_pos := @buffer_pos;
			while(Unmatch('<')) {
				@buffer_pos += 1;
			};
			
			tag_contents : String := Nil;
			if(@buffer_pos > start_pos) {
				tag_contents := String->New();
				for(i := start_pos; i < @buffer_pos; i += 1;) {
					tag_contents->Append(@buffer[i]);
				};
			};				

			type : XMLElementType;
			if(is_unary_tag) {
				type := XMLElementType->UNARY_ELEMENT;
			}
			else if(is_dclr_tag) {
				type := XMLElementType->DECLARATION;
			}
			else if(is_end_tag) {
				type := XMLElementType->CLOSING_ELEMENT;
			}
			else {
				type := XMLElementType->OPENING_ELEMENT;
			};
			
			return XMLElement->New(tag_name, type, attribs, tag_contents);
		}
		
		method : public : GetRoot() ~ XMLElement {
			return @root;
		}
		
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# finds all elements in a
		# given path
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~# 
		method : public : FindElements(path : String) ~ Vector {
			filters := Vector->New();
			start := 0;
			each(i : path) {
					if(path->Get(i) = '/') {
						if(i - start > 0) {
							filter := path->SubString(start, i - start);
							filters->AddBack(filter->As(Base));
						};
						start := i + 1;
					};
			};
			
			if(start < path->Size() & path->Size() - start > 0) {
				filter := path->SubString(start, path->Size() - start);
				filters->AddBack(filter->As(Base));
			};
			
			children := Vector->New();
			if(filters->Size() > 0 & filters->Get(0)->As(String)->Equals(@root->GetName())) {
				if(filters->Size() = 1) {
					children->AddBack(@root->As(Base));
				}
				else {
					# process root
					filter := filters->Get(1)->As(String);
					children := @root->GetChildren(filter);
					
					# process children
					for(i := 2; i < filters->Size(); i += 1;) {
						# get filter
						filter := filters->Get(i)->As(String);
						# filter children
						all_filtered := Vector->New();
						each(j : children) {
							element : XMLElement := children->Get(j)->As(XMLElement);
							filtered := element->GetChildren(filter);	
							all_filtered->AddBack(filtered);
						};
						children := all_filtered;
					};
				};				
				
			};

# Console->GetInstance()->Print("found: ")->PrintLine(children->Size());
			
			return children;
		}
	}
	
	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	# XMLElement types
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~# 
	enum XMLElementType {
		DECLARATION,
		CDATA,
		OPENING_ELEMENT,
		CLOSING_ELEMENT,
		UNARY_ELEMENT
	}
	
	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	# XMLElement class
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~# 
	class XMLElement {
		@name : String;
		@type : XMLElementType;
		@attribs : StringHash;
		@content : String;
		@children : Vector;
		
		New(name : String, type : XMLElementType, attribs : StringHash, content : String) {
			@name := name;
			@type := type;
			@attribs := attribs;
			@content := content;
			@children := Vector->New();
		}
		
		method : public : GetName() ~ String {
			return @name;
		}
		
		method : public : GetType() ~ XMLElementType {
			return @type;
		}
		
		method : public : GetContent() ~ String {
			return @content;
		}
		
		method : public : AddChild(tag : XMLElement) ~ Nil {
			@children->AddBack(tag->As(Base));
		}
		
		method : public : GetChildCount() ~ Int {
			return @children->Size();
		}
		
		method : public : GetChild(i : Int) ~ XMLElement {
			if(i < @children->Size()) {
				return @children->Get(i)->As(XMLElement);
			};
			
			return Nil;
		}
		
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# get all children that 
		# match the given filter
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~# 
		method : public : native : GetChildren(name : String) ~ Vector {
			filtered := Vector->New();
			each(i : @children) {
				element : XMLElement := @children->Get(i);
				if(element->GetName()->Equals(name)) {
					filtered->AddBack(element->As(Base));
				};
			};
			
			return filtered;
		}
		
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# get all children
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~# 
		method : public : GetChildren() ~ Vector {
			return @children;
		}
		
		method : public : AddAttribute(key : String, value : String) ~ Nil {
			if(@attribs = Nil) {
				@attribs := StringHash->New();
			};
			@attribs->Insert(key, value->As(Base));
		}
		
		method : public : GetAttribute(key : String) ~ String {
			return @attribs->Find(key)->As(String);
		}
	}
}

