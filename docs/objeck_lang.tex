\title{An Introduction to the Objeck Programming Language}
\author{
        Randy Hollines \\
        objeck@gmail.com\\
}
\date{\today}

\documentclass[12pt]{article}

\usepackage{aliascnt}
\usepackage{hyperref}
\usepackage{MnSymbol}
\usepackage[pdftex]{graphicx}

\begin{document}

\maketitle
\thispagestyle{empty}

\vspace{\baselineskip}

\begin{abstract}
A brief introduction to the Objeck programming language and it's features.  This article is intended to introduce programmers and compiler designers to the unique features and design of the Objeck language.   Unless otherwise noted, this article covers functionality that is included in release \textit{0.9.6}.  For additional information please refer to the \htmladdnormallink{general}{http://sourceforge.net/projects/objeck-lang/} and \htmladdnormallink{technical}{http://code.google.com/p/objeck-lang/} project websites.
\end{abstract}

\newpage
\tableofcontents
\newpage

\label{Introduction}
\section{Introduction}
The Objeck program language is an object-oriented computer language that is designed to be a general purpose programming system.  The Objeck language allows programmers to quickly create solutions by leveraging pre-existing class libraries.  The syntax for the language was designed with symmetry in mind and enforces the notion that there should only be one way to do something. Features of this release include:
\begin{itemize}
	\item Support for object-oriented programming (all data types are treated as objects)
	\item Cross platform independence (OS X, Linux and Windows)
	\item Concurrent runtime JIT support for Intel based computers
	\item Multi-threaded memory management (garbage collection)
	\item Support for static shared library
	\item Basic block compiler optimizations
\end{itemize}

\section{Getting Started}

The Objeck computer language consist of a compiler and virtual machine.  The compiler program is named \texttt{obc}, while the runtime virtual machine (VM) program is named \texttt{obr}.  Here is the world famous ``Hello World" program written in the Objeck language:

\begin{verbatim}
bundle Default {
  class Test {
    function : Main(), Nil {
      "Hello World!"->PrintLine();
    }
  }
}
\end{verbatim}

\subsection{Compiling Source}
The example below compiles the source program \texttt{hello.obs} into the target binary file \texttt{hello.obe}.  The two output file types that the compilers supports are executables and shared libraries.  Shared libraries are binary files that contain all of the metadata needed by the compiler to relink them into programs.  Both executables and shared libraries contain enough metadata to support runtime introspection (a feature that will be added in a future release).  As a naming convention, executables must end in \texttt{*.obe} while shared libraries must end in \texttt{*.obl}.

Below is an example of compiling the ``Hello World" program
\begin{verbatim}
obc -src tests\hello.obs -dest hello.obe
\end{verbatim}

Additional compiler options are listed below:
\begin{center}
\begin{tabular}{| l | l |}
\hline
\emph{Option} & \emph{Description} \\ \hline \hline
\texttt{-src} & path to source files, delimited by the `\texttt{,}' character \\ \hline
\texttt{-lib} & path to library files, delimited by the `\texttt{,}' character \\ \hline
\texttt{-tar} & target output \texttt{exe} for executable and \texttt{lib} for library; default is  \texttt{exe} \\ \hline
\texttt{-opt} & optimization level \texttt{s0}--\texttt{s3} with \texttt{s3} being the most aggressive; default is \texttt{s0} \\ \hline
\texttt{-dest} & output file name \\ \hline
\end{tabular}
\end{center}

\subsection{Executing}
The command line example below executes the \texttt{hello.obe} executable. Note, for executables all required libraries are statically linked in the target output file.  When compiling shared libraries, other shared libraries are \underline{not} linked into the target output library file.

\begin{verbatim}
obr hello.obe
\end{verbatim}

\section{The Basics}
Now lets introduce you the core features of the Objeck programming language.
\vspace{\baselineskip}

In Objeck, all data types are treated as objects. Basic objects provide supports for boolean, character, byte, integer and decimal types.  These basic objects can be used to create complex user defined objects.  The listing below defines the basic objects that are supported in the language:

\begin{center}
\begin{tabular}{| l | l |}
\hline
\emph{Type} & \emph{Description} \\ \hline \hline
\texttt{Char} &  1--byte character \\ \hline
\texttt{Char[]} &  character array \\ \hline
\texttt{Bool} &  boolean value \\ \hline
\texttt{Bool[]} &  boolean array \\ \hline
\texttt{Byte} &  1--byte integer \\ \hline
\texttt{Byte[]} &  byte array \\ \hline
\texttt{Int} &  4--byte integer \\ \hline
\texttt{Int[]} &  integer array \\ \hline
\texttt{Float} &  8--byte decimal \\ \hline
\texttt{Float[]} &  decimal array \\ \hline
\end{tabular}
\end{center}

As mentioned above, basic types are objects and have associated methods for each basic class type.  For example:

\begin{verbatim}
13->Min(3)->PrintLine();
13->Max(3)->PrintLine();
-22->Abs()->PrintLine();
Float->Pi()->PrintLine();
\end{verbatim}

\subsection{Variable Declarations}
Variables can be declared for all of the basic types described above and for user defined objects. Variables can be declared anywhere in a program and are bound to traditional block scoping rules.  Variable assignments can be made during a declaration or at any other point in a program. Variables may be declared as local, class instance or class variables.  Class level variables are declared using the \texttt{static} keyword. A class that is derived from another class may access it's parents variables if the parent class is declared in one of the source programs.  \textit{If a class is derived from a class declared in a shared library then that class cannot access it's parents variables, unless an accessor method is provided.}  Local variables can be declared without specifying their data type, such variables are bound to a type following their first assignment. Three different declaration styles are shown below:

\begin{verbatim}
a : Int;
b : Int := 13;
c := 7;
\end{verbatim}

Types that are not initialized at declaration time are initialized with the following default values:

\vspace{\baselineskip}
\begin{center}
\begin{tabular}{| l | c |}
\hline
\emph{Type} & \emph{Initialization} \\ \hline \hline
\texttt{Char} & `\textbackslash0' \\ \hline
\texttt{Byte} & 0 \\ \hline
\texttt{Int} & 0 \\ \hline
\texttt{Float} & 0.0 \\ \hline
Array & \texttt{Nil} \\ \hline
Object & \texttt{Nil} \\ \hline
\end{tabular}
\end{center}

\subsection{Expressions}
The Objeck language supports various expression types.  Some of these expression types include mathematical, logical, array and method call expressions.  The preceding sections describe some of the expressions that are supported in the Objeck language.

\subsubsection{Mathematical and Logical Expressions}
The following code example demonstrates two ways to printing the number \texttt{42}.  The first way invokes the \texttt{PrintLine()} method for the literal \texttt{42}.  The second prints the product of a variable and a literal.

\begin{verbatim}
bundle Default {
  class Test {
    function : Main(), Nil {
      42->PrintLine();
      eight := 8;
      (eight * 7)->PrintLine();
    }
  }
}
\end{verbatim}

The following mathematical operators are supported in the Objeck language for integers and decimal values:
\begin{itemize}
    \item addition (\texttt{+})
    \item subtraction (\texttt{-})
    \item multiplication (\texttt{*})
    \item division (\texttt{/})
    \item modulus -- (\texttt{\%} - for integer values only)
\end{itemize}

The [\texttt{*}, \texttt{/}, \texttt{\%}] operators have a higher precedence than  the [\texttt{+}, \texttt{-}] operators. Operators of the same precedence are evaluated from left-to-right.  Logical operations are of lower precedence than mathematical operations. All logical operators are of the same precedence and order is determined via left--to--right evaluation.  The [\texttt{\&}, \texttt{|}] logical operators use short-circuit logic; meaning that some expressions may not be executed if evaluation criteria is not satisfied.

The following logical operators are supported in the Objeck language:
\begin{itemize}
    \item and (\texttt{\&})
    \item or (\texttt{|})
    \item equal (\texttt{=})
    \item not--equal (\texttt{<>})
    \item less--than (\texttt{<})
    \item greater--than (\texttt{>})
    \item less--than--equal (\texttt{<=})
    \item greater--than--equal (\texttt{>=})
\end{itemize}

\subsubsection{Arrays}
The Objeck language supports single and multi-dimensional arrays.  Arrays are allocated dynamically from the system heap.  The memory that is allocated for arrays is managed automatically by the runtime garbage collector.  All of the basic types described above (as well as user defined types) can be allocated as arrays.  The code example below shows how a two-dimensional array of type \texttt{Int} is allocated and dereferenced.


\begin{verbatim}
array := Int[,] = Int->New[2,3];
array[0,2] := 13;
array[1,0] := 7;
\end{verbatim}

The size of an array can be obtained by calling the array's \texttt{GetSize()} method.  The \texttt{GetSize()} method will return the number of elements in a given array.  For a multi-dimensional array the size method returns the number of elements in the first dimension.  Character array literals are allocated as \texttt{String} objects.  It should also be noted that language has a \texttt{String} class that provides support for advanced string operations.

\begin{verbatim}
str := "Hello World!";
str->GetSize()->PrintLine();
\end{verbatim}

\subsection{Statements}
Besides providing support for declaration statements the language has support for conditional and control statements.  As with other languages, control statements can be nested in order to provide finer grain logical control. General control statements include \texttt{if} and \texttt{select} statements. Basic looping statements include \texttt{while}, \texttt{do/while} and \texttt{for} loops.  Note, all statements rather decelerations or controls end with a `\texttt{;}'.

\subsubsection{If Statement}

An \texttt{if} statement is a control statement that executes the associated block of code if it evaluates to \texttt{true}.  If the evaluation statement does not evaluate to \texttt{true} than an \texttt{else if} statement may be evaluated (if it exists), otherwise an \texttt{else} statement will be executed (if it exists).  The example below demonstrates an \texttt{if} statement.

\begin{verbatim}
value : Int := Console.ReadLine()->ToInt();
if(value <> 3) {
  "Not equal to 3"->PrintLine();
}
else if(value < 13) {
  "Less than 13"->PrintLine();
}
else {
  "Some other number"->PrintLine();
};
\end{verbatim}

\subsubsection{Select Statement}

A \texttt{select} statement maps a value to 1 or more labels.  Labels are associated to statement blocks.  A label may either be a literal or an \texttt{enum} value.  Multiple labels can be mapped to the same statement block.  Below is an example of a \texttt{select} statement.

\begin{verbatim}
select(v) {
   label Color->Red: {
      "Red"->PrintLine();
   }

   label 9:
   label 19: {
      v->PrintLine();
   }

   label 27: {
      (3 * 9)->PrintLine();
   }
};
\end{verbatim}

\subsubsection{While Statement}

A \texttt{while} statement is a control statement that will continue to execute its main body as long as its conditional expression evaluates to \texttt{true}.  When its conditional expression evaluates to \texttt{false} than the loop body will cease to execute.

\begin{verbatim}
i : Int := 10;
while(i > 0) {
   i->PrintLine();
   i := i - 1;
}
\end{verbatim}

\subsubsection{Do/While Statement}

A \texttt{do/while} statement is a control statement that will execute its main body at least once and continue to execute its main body as long as its conditional expression evaluates to \texttt{true}.  When its conditional expression evaluates to \texttt{false} than the loop body will cease to execute.

\begin{verbatim}
i : Int := 10;
do { 
   i->PrintLine();
   i := i - 1;
} 
while(i > 0);
\end{verbatim}

\subsubsection{For Statements}

The \texttt{for} statement is another common looping construct.  The \texttt{for} loop consists of a pre-condition statement followed by an evaluation expression and an update statement.

\begin{verbatim}
name : Char[] := "John"->ToCharArray();
for(i : Int := 0; i < name->GetSize(); i := i + 1;) {
  name[i]->PrintLine();
}
\end{verbatim}

\section{User Defined Types}

\subsection{Enums}
Enums are user defined enumerated types.  The main use of an  \texttt{enum}  is to group a class of countable values, for example colors, into a distinct class.  Once \texttt{enum}  values have been defined they may not be assigned or associated to a other \texttt{enum}  groups or integer classes.  The valid operations for enums are as follows:

\begin{itemize}
    \item assignment (\texttt{:=})
    \item equal (\texttt{=})
    \item not--equal (\texttt{<>})
\end{itemize}

In addition, enum values may be used in \texttt{select} statements as conditional tests or labels.

\begin{verbatim}
enum Color {
   Red,
   Black,
   Green
}
\end{verbatim}

\subsection{Classes}
Classes are user defined types that allow programmers to create specialized data types.  Classes are made up of attributes (data) and operations (methods).  Classes are used to encapsulate programming logic and localize information.  Operations that are associated to a class may either be at the class level or instance level.  Class instances are created by calling an object's \texttt{New()} function.  Note, an object instance can only be created if one or more \texttt{New()} functions have been defined.

\subsubsection{Class Inheritance}
Classes may be derived from other classes using the \texttt{from} keyword.  Class inheritance allows classes to share common functionality.  The Objeck language supports single class inheritance, meaning that a derived class may only have one parent.  The language also supports virtual classes, which assures that derived classes have been defined for all required operations declared in the base class.  Virtual classes also allow the programmer to define non-virtual methods that contain program behavior.  Virtual classes are dynamically bound to implementation classes at runtime.
\begin{verbatim}
class Foo {
  @lhs : Int;

  New(lhs : Int) {
    @lhs := lhs;
  }

  method : native : AddTwo(rhs : Int), Int {
    return 2 + rhs;
  }

  method : virtual : AddThree(int rhs), Int;

  method : GetLhs(), Int {
    return lhs;
  }
}

class Bar from Foo {
  New(value : Int) {
    Parent(value);
  }

  method : native : AddThree(rhs : Int), Int {
    return 3 + rhs;
  }

  function : Main(), Nil {
    bar : b := Bar->New(31);
    b->AddThree(9)->PrintLine();
  }
}
\end{verbatim}

\subsubsection{Class Casting and Identification}
An object that is inherited from another object may be either upcasted or downcasted.  Object casting can be performed using the \texttt{As()} operator.  The Object language detects upcasting and downcastng at compile time. Upcasting requires a runtime check, while down casting does not. If cross casting is detected then a compile time error will be generated.

\begin{verbatim}
method : public : Compare(right : Base), Int {
  if(right <> Nil) {
    if(GetClassID() = right->GetClassID()) {
      a : A := right->As(A);

      if(@value = a->GetValue()) {
        return 0;
      };
    ...	
\end{verbatim}

The class that a given object instance belongs to can found by calling its \texttt{GetClassID} method.  This method returns an enum that is associated with that instance's class type.  This method is generally used to determine if two object instances are of the same or different classes.

\subsubsection{Methods and Functions}
The Objeck language support both methods and functions.  Functions are public static procedures that may be executed by any class.  Methods are operations that may be performed on an object instance.  Methods have \texttt{public} and \texttt{private} qualifiers.  Methods that are \texttt{private} may only be called from within the same class, while \texttt{public} methods may be called from other classes.  Note, methods are \texttt{private} by default. The Objeck language supports polymorphic methods and functions, meaning that there can be multiple methods with the same name within the same class as long as their declaration arguments vary.

Methods and functions can either be executed in an interpreted or JIT compiled mode. Interpreted execution mimics microprocessor functions in a platform independent manner. JIT execution takes the compiled stack code an produces native machine code. Note, that there is initial overhead involved in the JIT compilation process since it occurs at runtime. In addition, some methods can not be compiled into native machine code but this is a rare case.  The keyword \texttt{native} is used to JIT compile methods and function at runtime.

A function or method may be defined as \texttt{virtual} meaning that any class that originates from that class must implement all of the class's \texttt{virtual} methods or functions.  \texttt{Virtual} methods are a way to ensure that certain operations are available to a family of classes. If a class declares a \texttt{virtual} method then the class become \texttt{virtual}, meaning that it cannot be directly instantiated.

Below is an example of declaring a virtual method:
\begin{verbatim}
method : virtual : public : Compare(right : Base), Int;
\end{verbatim}

\section{Class Libraries}
Objeck includes class libraries that provides access to system resources, such as files and sockets, while also providing support for  basic data structures like lists and vectors.  As new class libraries are added they will be documented in this section.

\subsection{Char}
\begin{itemize}
    \item \texttt{IsDigit} - determines if the character is a digit (in the range of \texttt{0-9})
    \item \texttt{IsChar} - determines if the character is a alpha (in the range of \texttt{A-Z} or \texttt{a-z})
    \item \texttt{Min} - returns the smallest of the two numbers; returns the same number if they are equal
    \item \texttt{Max} - returns the largest of the two numbers; returns the same number if they are equal
    \item \texttt{Print} - prints the current value
    \item \texttt{PrintLine} - prints the current value along with a line return
    \item \texttt{ToString} - converts the current value to a \texttt{String} object instance
\end{itemize}

\subsection{Byte/Int}
\begin{itemize}
    \item \texttt{Min} - returns the smallest of the two numbers; returns the same number if they are equal
    \item \texttt{Max} - returns the largest of the two numbers; returns the same number if they are equal
    \item \texttt{Abs} - returns the absolute value of the current number
    \item \texttt{Print} - prints the current value
    \item \texttt{PrintLine} - prints the current value along with a line return
    \item \texttt{ToString} - converts the current value to a \texttt{String} object instance
\end{itemize}

\subsection{Float}
\begin{itemize}
    \item \texttt{Min} - returns the smallest of the two numbers; returns the same number if they are equal
    \item \texttt{Max} - returns the largest of the two numbers; returns the same number if they are equal
    \item \texttt{Abs} - returns the absolute value of the current number
    \item \texttt{Floor} - returns the floor of the current number
    \item \texttt{Ceiling} - returns the ceiling of the current number
    \item \texttt{Pi} - returns the value of Pi
    \item \texttt{Print} - prints the current value
    \item \texttt{PrintLine} - prints the current value along with a line return
    \item \texttt{ToString} - converts the current value to a \texttt{String} object instance
\end{itemize}

\subsection{String}
\begin{itemize}
    \item \texttt{Append} - Appends a \texttt{String}, \texttt{Char[]}, \texttt{Char}, \texttt{Int} or \texttt{Float} to the current String instance
    \item \texttt{GetIndex} - returns the index of the first occurrence of a given Character
    \item \texttt{GetSize} - returns the size of the String
    \item \texttt{ToCharArray} - converts a string to a \texttt{Char[]}
    \item \texttt{ToInt} - converts a string to a \texttt{Int}
    \item \texttt{ToFloat} - converts a string to a \texttt{Float}
    \item \texttt{SubString} - creates a new string that contains a subset of the string's contents
    \item \texttt{Equals} - compares two string returns \texttt{true} if they are equal
    \item \texttt{Compare} - compares two string returns 0 if they are equal
    \item \texttt{Print} - prints the String object's contents
    \item \texttt{PrintLine} - prints the String object's contents along with a line return
\end{itemize}

\subsection{System Libraries and Data Structures}
The following data structures are supported:
\begin{itemize}
    \item Console
	\item Time
    \item LinkedList
    \item IntLinkedList
    \item FloatLinkedList
    \item Vector
    \item IntVector
    \item FloatVector
    \item BinaryTree
\end{itemize}


\subsubsection{Console}
The Console class allows programmers to read and write information to the system console.    The class supports the following operations:
\begin{itemize}
    \item \texttt{Print} - prints all basic types including \texttt{String} and \texttt{Char[]} to standard out.
    \item \texttt{PrintLine} - prints all basic types including \texttt{String} and \texttt{Char[]} to standard out followed by a newline.
    \item \texttt{ReadLine} - reads in a line of text as a \texttt{Char[]} from standard in.
\end{itemize}

\subsubsection{Time}
The Time class allows programmers gain access to the current system time.    The class supports the following operations:
\begin{itemize}
    \item \texttt{GetDay} - return the current day as an \texttt{Int}.
    \item \texttt{GetMonth} - return the current month as an \texttt{Int}.
    \item \texttt{GetYear} - return the current year as an \texttt{Int}.
	\item \texttt{GetHours} - return the current hour as an \texttt{Int}.
    \item \texttt{GetMinutes} - return the current minutes as an \texttt{Int}.
    \item \texttt{GetSeconds} - return the current seconds as an \texttt{Int}.
	\item \texttt{IsSavingsTime} - return true if daylights saving time, false otherwise \texttt{Int}.
\end{itemize}

\subsubsection{File}
The File class allows programmers manipulate system files.    The class supports the following operations:
\begin{itemize}
    \item \texttt{IsOpen} - returns true if file is open.
    \item \texttt{IsEOF} - returns true if the file pointer is at the EOF.
    \item \texttt{Seek} - seeks to a position in a file.
    \item \texttt{Rewind} - moves the file pointer to the beginning of a file.
    \item \texttt{GetSize} - returns the size of the file.
    \item \texttt{Delete} - deletes a file.
    \item \texttt{Exists} - returns true if the file exists.
    \item \texttt{Rename} - renames a file
\end{itemize}

\subsubsection{FileReader}
The FileReader is inherited from the File class and allows programmers read files.    The class supports the following operations:
\begin{itemize}
    \item \texttt{Close} - closes a file.
    \item \texttt{ReadByte} - reads a byte from a file.
    \item \texttt{ReadBuffer} - reads n number of bytes from a file.
    \item \texttt{ReadString} - reads a line from a file.
\end{itemize}

\subsubsection{FileWriter}
The FileReader is inherited from the File class and allows programmers read files.    The class supports the following operations:
\begin{itemize}
    \item \texttt{Close} - closes a file.
    \item \texttt{WriteByte} - writes a byte to a file.
    \item \texttt{WriteBuffer} - writes n number of bytes to a file.
    \item \texttt{WriteString} - writes a string to a file.
\end{itemize}

\subsubsection{Directory}
The Directory class allows programmers manipulate filesystem directories.    The class supports the following operations:
\begin{itemize}
    \item \texttt{Create} - creates a new directory.
    \item \texttt{Exists} - returns true if the directory exists.
    \item \texttt{List} - returns vector of file and directory names.
\end{itemize}

\subsubsection{LinkedList/IntLinkedList/FloatLinkedList}
The LinkedList class allow values inserted and add to the front and back of a list.  The class supports the following operations:
\begin{itemize}
    \item \texttt{AddBack} - adds a new value to the back of the list
    \item \texttt{AddFront} - adds a new value to the front of the list
    \item \texttt{InsertElement} - inserts a new value in the position pointed to the cursor
    \item \texttt{RemoveBack} - removes the last element in the list
    \item \texttt{RemoveFront} - removes the first element in the list
    \item \texttt{RemoveElement} - removes the element pointed to the cursor
    \item \texttt{Next} - advances the internal cursor by one element
    \item \texttt{Pervious} - retreats the internal cursor by one element
    \item \texttt{GetValue} - returns the value of the element  pointed to by the cursor
    \item \texttt{Forward} - moves the cursor to the end of the list
    \item \texttt{Rewind} - moves the cursor to the start of the list
    \item \texttt{GetSize} - returns the size of the list
\end{itemize}

\subsubsection{Vector/IntVector/FloatVector}
The Vector class support the concept of a growing array.  The class supports the following operations:
\begin{itemize}
    \item \texttt{AddBack} - adds a new value to the back of the vector
    \item \texttt{RemoveBack} - removes the last element in the vector
    \item \texttt{GetValue} - returns the value of the element  pointed to by the cursor
    \item \texttt{SetValue} - replaces the list value based upon the given index
    \item \texttt{GetSize} - returns the size of the list
\end{itemize}

\subsubsection{BinaryTree}
The BinaryTree class supports the concept of an associative array with key/value pairs.  The class implements a balance binary tree algorithm such that inserts, deletes and searches are $\log_2 n$:
\begin{itemize}
    \item \texttt{Insert} - adds a new value to the tree
    \item \texttt{Delete} - removes a value from the tree
    \item \texttt{Find} - searches for a value based upon a key
    \item \texttt{SetValue} - replaces the list value based upon the given index
    \item \texttt{GetKeys} - returns a vector of keys
    \item \texttt{GetValue} - returns a vector of values
\end{itemize}

\section{Examples}

\subsection{Binary Search Tree Example}
\begin{verbatim}
use System;

bundle Default {
  class Test {
    function : Main(args : String[]), Nil {
      Run();
      "Done!"->PrintLine();
    }

    function : native : Run(), Nil {
      tree := BinaryTree->New();
      for(i : Int := 0; i < 1000; i := i + 1;) {
        v := IntHolder->New(i);
        s := String->New("Pug-");
        s->Append((i + 2)->ToString()->ToCharArray());
        tree->Insert(v->As(Compare), s->As(Base));
      };

      v := tree->GetKeys();
      for(i : Int := 0; i < v->GetSize(); i := i + 1;) {
        h := v->GetValue(i)->As(Structure.IntHolder);
        h->GetValue()->PrintLine();
      };

      v := tree->GetValues();
      for(i : Int := 0; i < v->GetSize(); i := i + 1;) {
        v->GetValue(i)->As(String)->PrintLine();
      };
    }
  }
}
\end{verbatim}
\subsection{Prime Number Example}
\begin{verbatim}
bundle Default {
  class FindPrime {
    function : Main(), Nil {
      Run(1000000);
    }

    function : native : Run(topCandidate : Int), Nil {
      candidate : Int := 2;
      while(candidate <= topCandidate) {
        trialDivisor : Int := 2;
        prime : Int := 1;

        found : Bool := true;
        while(trialDivisor * trialDivisor <= candidate & found) {
          if(candidate % trialDivisor = 0) {
            prime := 0;
            found := false;
          }
          else {
            trialDivisor := trialDivisor + 1;
          };
        };

        if(found) {
          candidate->PrintLine();
        };
        candidate := candidate + 1;
      };
    }
  }
}
\end{verbatim}

\newpage

\section{Appendix A: General Compiler Design}
\includegraphics[scale=0.60]{../images/compiler_data_flow.png}

The following section gives a brief overview of the major architectural components the comprise the Objeck language compiler and virtual machine.

\subsection{Compiler}
The language compiler is written in C++ and makes heavy use of the C++ STL for portable across platforms.  As mentioned in the introduction, the compiler accepts source files and shared libraries as inputs and produces either Objeck executables or Objeck shared libraries.  Note, the compiler has two modes of operation: \texttt{User Mode} compiles traditional end-user programs, while the \texttt{System Mode} compiles system libraries and processes special system language directives.

\subsubsection{Scanner and Parser}
The scanner component reads source files and parses the text into tokens.  The scanner works in conjugation with the \emph{LL(k)} parser by providing \emph{k} lookahead tokens for parsing.  Note, the scanner can scan system language directives when in \texttt{System Mode}.  The source parser is a recursive-decent parser, which generates an abstract parser tree that is passed to the Contextual Analyser for validation.

\subsubsection{Contextual Analyser}
The Contextual Analyser is responsible for ensuring that a source program is valid.  In addition, the context analyser also creates relationships between contextually resolved entities (i.e. methods $\longleftrightarrow$ method calls).  The analyser accepts an abstract parser tree and shared libraries as input and produces a decorated parse tree as output.  The decorated parse tree is then passed to the Intermediate Code Generator for the production of VM instructions.

\subsubsection{Intermediate Code Generator and Optimzier}
The Intermediate Code Generator accpets a decorated parse and produces a flat list of VM stack instructions.  These instructions lists are then passed to the Optimizer for basic block optimizations (constant folding, strength reduction, instruction simplification and method inlining).

\subsubsection{Target Emitter}
Finally, the improved intermediate code is passed to code emitter component, which writes it to a file.

\subsection{Virtual Machine}
The language VM is written in C/C++ and was designed to be highly portable.  The VM makes heavy use of operating system specific APIs (i.e. WIN32 and POSIX) but does so in an abstracted manner.  The JIT compiler is targeted to produce machine code for the Intel IA-32 and AMD64 (future) hardware architectures.  

\subsubsection{Loader}
The loader component allows the VM to read program code such as classes, methods and instructions.  The loader create an in-memory representation of this information, which is used by the VM interpreter and JIT compiler.  In addition, the loader processes command-line parameters that are passed into the VM prior to execution.

\subsubsection{Interpreter}
The Interpreter executes stack based VM instructions (listed below) and manages two primary stacks: the execution and call stacks.  The execution stack is used to manage the data that is needed for VM calculations.  The call stack is used to manage function/method calls and the states between those calls.

\subsubsection{JIT Compiler}
The JIT compiler translates stack based VM instruction into processor specific machine code (i.e. IA-32).  The JIT compiler is evoked by the interpreter and methods are translated in a separate execution thread.  This process allow methods to be executed concurrently in an interpreted manner while they are being compiled into machine code.  Note, methods are only converted into machine code once.

\subsubsection{Memory Manager}
The Memory Manager component allows the runtime system to manage the user allocation/deallocation of heap memory.  The memory mangers implementes a multi-thread ``mark and sweep'' algorithm.  The marking stage of the process is multi-thread, such that, each root in scanned in a separate thread.  The sweeping stage is done in a single thread since data structures that are need to manage the state of the running program are modified.

\section{Appendix B: VM Instructions}
The appendix below lists the types of stack instructions that are executed by the Objeck VM.  The VM was designed to be portable and language independent.  Early development versions of the VM included an inline assembler, which may be re-added in future releases.

\begin{center}
{\small{
\begin{tabular}{| l | l | p{6 cm} |}
\hline
\multicolumn{3}{|c|}{\textbf{Stack Operators}} \\
\hline
\emph{Mnemonic}  &  \emph{Opcode(s)}  &  \emph{Description} \\ \hline \hline
LOAD\_INT\_LIT & 4-byte integer & pushes integer onto stack  \\ \hline
LOAD\_FLOAT\_LIT & 8-byte float & pushes float onto stack \\ \hline
LOAD\_INT\_VAR & variable index & pushes integer onto stack \\ \hline
LOAD\_FLOAT\_VAR & variable index & pushes float onto stack \\ \hline
LOAD\_SELF & n/a & pushes self integer on stack \\ \hline
STOR\_INT\_VAR & variable index & pops integer from stack and saves to index location \\ \hline
STOR\_FLOAT\_VAR & variable index & pops float from stack and saves to index location \\ \hline
COPY\_INT\_VAR & variable index & copies an integer from stack and saves to index location \\ \hline
COPY\_FLOAT\_VAR & variable index & copies a float from stack and saves to index location \\ \hline
LOAD\_BYTE\_ARY\_ELM & array dimension & pushes byte onto stack; assumes array address was pushed prior \\ \hline
LOAD\_INT\_ARY\_ELM & array dimension & pushes integer onto stack; assumes array address was pushed prior \\ \hline
LOAD\_FLOAT\_ARY\_ELM & array dimension & pushes float onto stack; assumes array address was pushed prior \\ \hline
LOAD\_ARY\_SIZE & n/a & pushes array size as integer onto stack; assumes array address was pushed prior \\ \hline
STOR\_BYTE\_ARY\_ELM & variable index & stores byte at index location; assumes array address was pushed prior \\ \hline
STOR\_INT\_ARY\_ELM & variable index & stores integer at index location ; assumes array address was pushed prior \\ \hline
STOR\_FLOAT\_ARY\_ELM & variable index & stores float at index location; assumes array address was pushed prior \\ \hline
\end{tabular}

\vspace{\baselineskip}
\begin{tabular}{| l | l | p{6 cm} |}
\hline
\multicolumn{3}{|c|}{\textbf{Logical Operators}} \\
\hline
\emph{Mnemonic}  &  \emph{Opcode(s)}  &  \emph{Description} \\ \hline \hline
EQL\_INT & n/a & pops top two integer values and pushes result of equal operation \\ \hline
NEQL\_INT & n/a & pops top two integer values and pushes result of not-equal operation \\ \hline
LES\_INT & n/a & pops top two integer values and pushes result of less-than operation \\ \hline
GTR\_INT & n/a & pops top two integer values and pushes result of greater-than operation \\ \hline
LES\_EQL\_INT & n/a & pops top two integer values and pushes result of less-than-equal operation \\ \hline
GTR\_EQL\_INT & n/a & pops top two integer values and pushes result of greater-than-equal operation \\ \hline
EQL\_FLOAT & n/a & pops top two floats values and pushes result of equal operation \\ \hline
NEQL\_FLOAT & n/a & pops top two floats values and pushes result of not-equal operation \\ \hline
LES\_FLOAT & n/a & pops top two floats values and pushes result of less-than operation \\ \hline
GTR\_FLOAT & n/a & pops top two floats values and pushes result of greater-than operation \\ \hline
LES\_EQL\_FLOAT & n/a & pops top two floats values and pushes result of less-than-equal operation \\ \hline
GTR\_EQL\_FLOAT & n/a & pops top two floats values and pushes result of greater-than-equal operation \\ \hline
AND\_INT & n/a & pops top two integer values and pushes result of add operation \\ \hline
OR\_INT & n/a & pops top two integer values and pushes result of or operation \\ \hline
\end{tabular}

\vspace{\baselineskip}
\begin{tabular}{| l | l | p{6 cm} |}
\hline
\multicolumn{3}{|c|}{\textbf{Mathematical Operators}} \\
\hline
\emph{Mnemonic}  &  \emph{Opcode(s)}  &  \emph{Description} \\ \hline \hline
ADD\_INT & n/a & pops top two integer values and pushes result of add operation \\ \hline
SUB\_INT & n/a & pops top two integer values and pushes result of subtract operation \\ \hline
MUL\_INT & n/a & pops top two integer values and pushes result of multiply operation \\ \hline
DIV\_INT & n/a & pops top two integer values and pushes result of divide operation \\ \hline
SHL\_INT & n/a & pops top two floats values and pushes result of shift left operation \\ \hline
SHR\_INT & n/a & pops top two floats values and pushes result of shift right operation \\ \hline
MOD\_INT & n/a & pops top two integer values and pushes result of modulus operation \\ \hline
ADD\_FLOAT & n/a & pops top two floats values and pushes result of greater-than-equal operation \\ \hline
SUB\_FLOAT & n/a & pops top two floats values and pushes result of subtract operation \\ \hline
MUL\_FLOAT & n/a & pops top two floats values and pushes result of multiply operation \\ \hline
DIV\_FLOAT & n/a & pops top two floats values and pushes result of divide operation \\ \hline
I2F & n/a & pop top integer and pushes result of float cast \\ \hline
F2I & n/a & pop top float and pushes result of integer cast \\ \hline
\end{tabular}

\vspace{\baselineskip}
\begin{tabular}{| l | p{4 cm} | p{6 cm} |}
\hline
\multicolumn{3}{|c|}{\textbf{Objects/Methods/Traps}} \\
\hline
\emph{Mnemonic}  &  \emph{Opcode(s)}  &  \emph{Description} \\ \hline \hline
RTRN & n/a & exits existing method returning control to callee \\ \hline
MTHD\_CALL & integer values for class id and method id & synchronous call to given method releasing control \\ \hline
ASYNC\_MTHD\_CALL & integer values for class id and method id; pushes new thread id & asynchronous call to given method \\ \hline
ASYNC\_JOIN & thread id & waits for identified thread to end execution \\ \hline
LBL & label id & identifies a jump label \\ \hline
JMP & label id and conditional context (1=true, 0=unconditional, -1=false) & jump to label id \\ \hline
NEW\_BYTE\_ARY & array dimension & pushes address of new byte array \\ \hline
NEW\_INT\_ARY & array dimension & pushes address of new integer array \\ \hline
NEW\_FLOAT\_ARY & array dimension & pushes address of new float array \\ \hline
NEW\_OBJ\_INST & integer value for class id & pushes address of new class instance \\ \hline
OBJ\_INST\_CAST & integer values for ``from'' class and ``to'' class & performs runtime class cast check (note: only required for up casting) \\ \hline
THREAD\_CREATE & n/a & creates an new thread instance (calculation stack and  stack pointer) \\ \hline
THREAD\_WAIT & n/a & waits for worker threads to stop execution \\ \hline
CRITICAL\_START & n/a & creates a mutex such that only one thread can execute in a given section \\ \hline
CRITICAL\_END & n/a & releases a system mutex \\ \hline
TRAP & integer value for trap id & calls runtime subroutine releasing control \\ \hline
TRAP\_RTRN & integer value for trap id and number of arguments & calls runtime subroutine releasing control and then process an integer return value \\ \hline
LIB\_NEW\_OBJ\_INST & n/a & symbolic library link for a new object instance  \\ \hline
LIB\_MTHD\_CALL & n/a & symbolic library link for a method call  \\ \hline
LIB\_OBJ\_INST\_CAST & n/a & symbolic library link for an object cast  \\ \hline
\end{tabular}
}}
\end{center}

\end{document}
